
build/dedes.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002b9 	.word	0x080002b9
 8000008:	080002bb 	.word	0x080002bb
 800000c:	080002ba 	.word	0x080002ba
 8000010:	080002ba 	.word	0x080002ba
 8000014:	080002ba 	.word	0x080002ba
 8000018:	080002ba 	.word	0x080002ba
 800001c:	080002ba 	.word	0x080002ba
 8000020:	080002ba 	.word	0x080002ba
 8000024:	080002ba 	.word	0x080002ba
 8000028:	080002ba 	.word	0x080002ba
 800002c:	08001f21 	.word	0x08001f21
 8000030:	080002ba 	.word	0x080002ba
 8000034:	080002ba 	.word	0x080002ba
 8000038:	080002ba 	.word	0x080002ba
 800003c:	080002ba 	.word	0x080002ba
 8000040:	080002ba 	.word	0x080002ba
 8000044:	080002ba 	.word	0x080002ba
 8000048:	080002ba 	.word	0x080002ba
 800004c:	080002ba 	.word	0x080002ba
 8000050:	080002ba 	.word	0x080002ba
 8000054:	080002ba 	.word	0x080002ba
 8000058:	08001151 	.word	0x08001151
 800005c:	08001121 	.word	0x08001121
 8000060:	080010f1 	.word	0x080010f1
 8000064:	080010c1 	.word	0x080010c1
 8000068:	08001091 	.word	0x08001091
 800006c:	08000ef1 	.word	0x08000ef1
 8000070:	08000ec1 	.word	0x08000ec1
 8000074:	08000e91 	.word	0x08000e91
 8000078:	08000e61 	.word	0x08000e61
 800007c:	08000e31 	.word	0x08000e31
 8000080:	08000e01 	.word	0x08000e01
 8000084:	08000dd1 	.word	0x08000dd1
 8000088:	08000f21 	.word	0x08000f21
 800008c:	080002ba 	.word	0x080002ba
 8000090:	080002ba 	.word	0x080002ba
 8000094:	080002ba 	.word	0x080002ba
 8000098:	080002ba 	.word	0x080002ba
 800009c:	08001021 	.word	0x08001021
 80000a0:	080002ba 	.word	0x080002ba
 80000a4:	08000a81 	.word	0x08000a81
 80000a8:	080002ba 	.word	0x080002ba
 80000ac:	08000aa1 	.word	0x08000aa1
 80000b0:	08000ab1 	.word	0x08000ab1
 80000b4:	08000a61 	.word	0x08000a61
 80000b8:	08000a41 	.word	0x08000a41
 80000bc:	080002ba 	.word	0x080002ba
 80000c0:	080002ba 	.word	0x080002ba
 80000c4:	080002ba 	.word	0x080002ba
 80000c8:	080002ba 	.word	0x080002ba
 80000cc:	080002ba 	.word	0x080002ba
 80000d0:	080002ba 	.word	0x080002ba
 80000d4:	080002ba 	.word	0x080002ba
 80000d8:	08000871 	.word	0x08000871
 80000dc:	080002ba 	.word	0x080002ba
 80000e0:	08000fa1 	.word	0x08000fa1
 80000e4:	080002ba 	.word	0x080002ba
 80000e8:	080002ba 	.word	0x080002ba
 80000ec:	080002ba 	.word	0x080002ba
 80000f0:	080002ba 	.word	0x080002ba
 80000f4:	080002ba 	.word	0x080002ba
 80000f8:	080002ba 	.word	0x080002ba
 80000fc:	08000da1 	.word	0x08000da1
 8000100:	080002ba 	.word	0x080002ba
 8000104:	080002ba 	.word	0x080002ba
 8000108:	080002ba 	.word	0x080002ba
 800010c:	080002ba 	.word	0x080002ba
 8000110:	080002ba 	.word	0x080002ba
 8000114:	080002ba 	.word	0x080002ba
 8000118:	080002ba 	.word	0x080002ba
 800011c:	080002ba 	.word	0x080002ba
 8000120:	08000d71 	.word	0x08000d71
 8000124:	08000d41 	.word	0x08000d41
 8000128:	08000d11 	.word	0x08000d11
 800012c:	08000ce1 	.word	0x08000ce1
 8000130:	08000cb1 	.word	0x08000cb1
 8000134:	080002ba 	.word	0x080002ba
 8000138:	080002ba 	.word	0x080002ba
 800013c:	080002ba 	.word	0x080002ba
 8000140:	080002ba 	.word	0x080002ba
 8000144:	080002ba 	.word	0x080002ba
 8000148:	080002ba 	.word	0x080002ba
 800014c:	080002ba 	.word	0x080002ba
 8000150:	08000c81 	.word	0x08000c81
 8000154:	08000c51 	.word	0x08000c51
 8000158:	08000c21 	.word	0x08000c21
 800015c:	080002ba 	.word	0x080002ba
 8000160:	080002ba 	.word	0x080002ba
 8000164:	080002ba 	.word	0x080002ba
 8000168:	080002ba 	.word	0x080002ba
 800016c:	080002ba 	.word	0x080002ba
 8000170:	080002ba 	.word	0x080002ba
 8000174:	080002ba 	.word	0x080002ba
 8000178:	080002ba 	.word	0x080002ba
 800017c:	080002ba 	.word	0x080002ba
 8000180:	080002ba 	.word	0x080002ba
 8000184:	080002ba 	.word	0x080002ba
 8000188:	080002ba 	.word	0x080002ba
 800018c:	080002ba 	.word	0x080002ba
 8000190:	080002ba 	.word	0x080002ba
 8000194:	080002ba 	.word	0x080002ba
 8000198:	080002ba 	.word	0x080002ba
 800019c:	080002ba 	.word	0x080002ba
 80001a0:	080002ba 	.word	0x080002ba
 80001a4:	080002ba 	.word	0x080002ba
 80001a8:	080002ba 	.word	0x080002ba
 80001ac:	080002ba 	.word	0x080002ba
 80001b0:	080002ba 	.word	0x080002ba
 80001b4:	080002ba 	.word	0x080002ba
 80001b8:	080002ba 	.word	0x080002ba
 80001bc:	080002ba 	.word	0x080002ba
 80001c0:	080002ba 	.word	0x080002ba
 80001c4:	080002ba 	.word	0x080002ba
 80001c8:	080002ba 	.word	0x080002ba
 80001cc:	080002ba 	.word	0x080002ba
 80001d0:	080002ba 	.word	0x080002ba
 80001d4:	080002ba 	.word	0x080002ba
 80001d8:	080002ba 	.word	0x080002ba
 80001dc:	080002ba 	.word	0x080002ba

Disassembly of section .text:

080001e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001e2:	4827      	ldr	r0, [pc, #156]	; (8000280 <endfiniloop+0x4>)
                msr     MSP, r0
 80001e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e8:	4826      	ldr	r0, [pc, #152]	; (8000284 <endfiniloop+0x8>)
                msr     PSP, r0
 80001ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001ee:	4826      	ldr	r0, [pc, #152]	; (8000288 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80001f0:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80001f4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001f8:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001fa:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001fc:	f380 8814 	msr	CONTROL, r0
                isb
 8000200:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000204:	f001 f804 	bl	8001210 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000208:	f002 f842 	bl	8002290 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800020c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000210:	491e      	ldr	r1, [pc, #120]	; (800028c <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 8000212:	4a1b      	ldr	r2, [pc, #108]	; (8000280 <endfiniloop+0x4>)

08000214 <msloop>:
msloop:
                cmp     r1, r2
 8000214:	4291      	cmp	r1, r2
                itt     lo
 8000216:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000218:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 800021c:	e7fa      	bcc.n	8000214 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800021e:	491c      	ldr	r1, [pc, #112]	; (8000290 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 8000220:	4a18      	ldr	r2, [pc, #96]	; (8000284 <endfiniloop+0x8>)

08000222 <psloop>:
psloop:
                cmp     r1, r2
 8000222:	4291      	cmp	r1, r2
                itt     lo
 8000224:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000226:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800022a:	e7fa      	bcc.n	8000222 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 800022c:	4919      	ldr	r1, [pc, #100]	; (8000294 <endfiniloop+0x18>)
                ldr     r2, =_data_start
 800022e:	4a1a      	ldr	r2, [pc, #104]	; (8000298 <endfiniloop+0x1c>)
                ldr     r3, =_data_end
 8000230:	4b1a      	ldr	r3, [pc, #104]	; (800029c <endfiniloop+0x20>)

08000232 <dloop>:
dloop:
                cmp     r2, r3
 8000232:	429a      	cmp	r2, r3
                ittt    lo
 8000234:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000236:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800023a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800023e:	e7f8      	bcc.n	8000232 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000240:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000242:	4917      	ldr	r1, [pc, #92]	; (80002a0 <endfiniloop+0x24>)
                ldr     r2, =_bss_end
 8000244:	4a17      	ldr	r2, [pc, #92]	; (80002a4 <endfiniloop+0x28>)

08000246 <bloop>:
bloop:
                cmp     r1, r2
 8000246:	4291      	cmp	r1, r2
                itt     lo
 8000248:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800024a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800024e:	e7fa      	bcc.n	8000246 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000250:	f000 ff96 	bl	8001180 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000254:	f000 ffd4 	bl	8001200 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8000258:	4c13      	ldr	r4, [pc, #76]	; (80002a8 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end
 800025a:	4d14      	ldr	r5, [pc, #80]	; (80002ac <endfiniloop+0x30>)

0800025c <initloop>:
initloop:
                cmp     r4, r5
 800025c:	42ac      	cmp	r4, r5
                bge     endinitloop
 800025e:	da03      	bge.n	8000268 <endinitloop>
                ldr     r1, [r4], #4
 8000260:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000264:	4788      	blx	r1
                b       initloop
 8000266:	e7f9      	b.n	800025c <initloop>

08000268 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000268:	f001 fa8a 	bl	8001780 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 800026c:	4c10      	ldr	r4, [pc, #64]	; (80002b0 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end
 800026e:	4d11      	ldr	r5, [pc, #68]	; (80002b4 <endfiniloop+0x38>)

08000270 <finiloop>:
finiloop:
                cmp     r4, r5
 8000270:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000272:	da03      	bge.n	800027c <endfiniloop>
                ldr     r1, [r4], #4
 8000274:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000278:	4788      	blx	r1
                b       finiloop
 800027a:	e7f9      	b.n	8000270 <finiloop>

0800027c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800027c:	f000 bfb8 	b.w	80011f0 <__default_exit>
                ldr     r0, =__main_stack_end__
 8000280:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000284:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000288:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 800028c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000290:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
 8000294:	08002cc0 	.word	0x08002cc0
                ldr     r2, =_data_start
 8000298:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 800029c:	20000838 	.word	0x20000838
                ldr     r1, =_bss_start
 80002a0:	20000838 	.word	0x20000838
                ldr     r2, =_bss_end
 80002a4:	20001140 	.word	0x20001140
                ldr     r4, =__init_array_start
 80002a8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end
 80002ac:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_start
 80002b0:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end
 80002b4:	080001e0 	.word	0x080001e0

080002b8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002b8:	e792      	b.n	80001e0 <_crt0_entry>

080002ba <NMI_Handler>:
Vector3F0:
Vector3F4:
Vector3F8:
Vector3FC:
#endif
        bl          _unhandled_exception
 80002ba:	f000 f800 	bl	80002be <_unhandled_exception>

080002be <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002be:	e7fe      	b.n	80002be <_unhandled_exception>

080002c0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002c4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002c8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ca:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002d0 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002d0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002d2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002d6:	4628      	mov	r0, r5
                blx     r4
 80002d8:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80002da:	2000      	movs	r0, #0
                bl      chThdExit
 80002dc:	f001 ffb0 	bl	8002240 <chThdExit>

080002e0 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 80002e0:	f001 fe56 	bl	8001f90 <chSchDoReschedule>

080002e4 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002e4:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002e6:	e7fe      	b.n	80002e6 <_port_exit_from_isr+0x2>

080002e8 <memcpy>:
 80002e8:	e352000f 	cmp	r2, #15
 80002ec:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 80002f0:	9a000029 	bls	800039c <memcpy+0xb4>
 80002f4:	e1813000 	orr	r3, r1, r0
 80002f8:	e3130003 	tst	r3, #3
 80002fc:	1a000031 	bne	80003c8 <memcpy+0xe0>
 8000300:	e1a0e002 	mov	lr, r2
 8000304:	e280c010 	add	ip, r0, #16
 8000308:	e2813010 	add	r3, r1, #16
 800030c:	e5137010 	ldr	r7, [r3, #-16]
 8000310:	e513600c 	ldr	r6, [r3, #-12]
 8000314:	e5135008 	ldr	r5, [r3, #-8]
 8000318:	e5134004 	ldr	r4, [r3, #-4]
 800031c:	e24ee010 	sub	lr, lr, #16
 8000320:	e35e000f 	cmp	lr, #15
 8000324:	e50c7010 	str	r7, [ip, #-16]
 8000328:	e50c600c 	str	r6, [ip, #-12]
 800032c:	e50c5008 	str	r5, [ip, #-8]
 8000330:	e50c4004 	str	r4, [ip, #-4]
 8000334:	e2833010 	add	r3, r3, #16
 8000338:	e28cc010 	add	ip, ip, #16
 800033c:	8afffff2 	bhi	800030c <memcpy+0x24>
 8000340:	e2423010 	sub	r3, r2, #16
 8000344:	e3c3300f 	bic	r3, r3, #15
 8000348:	e202600f 	and	r6, r2, #15
 800034c:	e2833010 	add	r3, r3, #16
 8000350:	e3560003 	cmp	r6, #3
 8000354:	e0811003 	add	r1, r1, r3
 8000358:	e0803003 	add	r3, r0, r3
 800035c:	9a00001b 	bls	80003d0 <memcpy+0xe8>
 8000360:	e1a04001 	mov	r4, r1
 8000364:	e1a0c006 	mov	ip, r6
 8000368:	e243e004 	sub	lr, r3, #4
 800036c:	e24cc004 	sub	ip, ip, #4
 8000370:	e4945004 	ldr	r5, [r4], #4
 8000374:	e35c0003 	cmp	ip, #3
 8000378:	e5ae5004 	str	r5, [lr, #4]!
 800037c:	8afffffa 	bhi	800036c <memcpy+0x84>
 8000380:	e246c004 	sub	ip, r6, #4
 8000384:	e3ccc003 	bic	ip, ip, #3
 8000388:	e28cc004 	add	ip, ip, #4
 800038c:	e083300c 	add	r3, r3, ip
 8000390:	e081100c 	add	r1, r1, ip
 8000394:	e2022003 	and	r2, r2, #3
 8000398:	ea000000 	b	80003a0 <memcpy+0xb8>
 800039c:	e1a03000 	mov	r3, r0
 80003a0:	e3520000 	cmp	r2, #0
 80003a4:	0a000005 	beq	80003c0 <memcpy+0xd8>
 80003a8:	e2433001 	sub	r3, r3, #1
 80003ac:	e0812002 	add	r2, r1, r2
 80003b0:	e4d1c001 	ldrb	ip, [r1], #1
 80003b4:	e1510002 	cmp	r1, r2
 80003b8:	e5e3c001 	strb	ip, [r3, #1]!
 80003bc:	1afffffb 	bne	80003b0 <memcpy+0xc8>
 80003c0:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
 80003c4:	e12fff1e 	bx	lr
 80003c8:	e1a03000 	mov	r3, r0
 80003cc:	eafffff5 	b	80003a8 <memcpy+0xc0>
 80003d0:	e1a02006 	mov	r2, r6
 80003d4:	eafffff1 	b	80003a0 <memcpy+0xb8>
	...

080003e0 <notify2.lto_priv.40>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 80003e0:	4a02      	ldr	r2, [pc, #8]	; (80003ec <notify2.lto_priv.40+0xc>)
 80003e2:	68d3      	ldr	r3, [r2, #12]
 80003e4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80003e8:	60d3      	str	r3, [r2, #12]
 80003ea:	4770      	bx	lr
 80003ec:	40004400 	.word	0x40004400

080003f0 <pwm_lld_serve_interrupt>:
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 80003f0:	6983      	ldr	r3, [r0, #24]
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 80003f2:	b570      	push	{r4, r5, r6, lr}
  sr  = pwmp->tim->SR;
 80003f4:	691c      	ldr	r4, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 80003f6:	68da      	ldr	r2, [r3, #12]
 80003f8:	4014      	ands	r4, r2
 80003fa:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 80003fc:	43d2      	mvns	r2, r2
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80003fe:	07a6      	lsls	r6, r4, #30
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8000400:	4605      	mov	r5, r0
  pwmp->tim->SR = ~sr;
 8000402:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8000404:	d503      	bpl.n	800040e <pwm_lld_serve_interrupt+0x1e>
      (pwmp->config->channels[0].callback != NULL))
 8000406:	6843      	ldr	r3, [r0, #4]
 8000408:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800040a:	b103      	cbz	r3, 800040e <pwm_lld_serve_interrupt+0x1e>
    pwmp->config->channels[0].callback(pwmp);
 800040c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 800040e:	0760      	lsls	r0, r4, #29
 8000410:	d504      	bpl.n	800041c <pwm_lld_serve_interrupt+0x2c>
      (pwmp->config->channels[1].callback != NULL))
 8000412:	686b      	ldr	r3, [r5, #4]
 8000414:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8000416:	b10b      	cbz	r3, 800041c <pwm_lld_serve_interrupt+0x2c>
    pwmp->config->channels[1].callback(pwmp);
 8000418:	4628      	mov	r0, r5
 800041a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800041c:	0721      	lsls	r1, r4, #28
 800041e:	d504      	bpl.n	800042a <pwm_lld_serve_interrupt+0x3a>
      (pwmp->config->channels[2].callback != NULL))
 8000420:	686b      	ldr	r3, [r5, #4]
 8000422:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8000424:	b10b      	cbz	r3, 800042a <pwm_lld_serve_interrupt+0x3a>
    pwmp->config->channels[2].callback(pwmp);
 8000426:	4628      	mov	r0, r5
 8000428:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800042a:	06e2      	lsls	r2, r4, #27
 800042c:	d504      	bpl.n	8000438 <pwm_lld_serve_interrupt+0x48>
      (pwmp->config->channels[3].callback != NULL))
 800042e:	686b      	ldr	r3, [r5, #4]
 8000430:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8000432:	b10b      	cbz	r3, 8000438 <pwm_lld_serve_interrupt+0x48>
    pwmp->config->channels[3].callback(pwmp);
 8000434:	4628      	mov	r0, r5
 8000436:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8000438:	07e3      	lsls	r3, r4, #31
 800043a:	d506      	bpl.n	800044a <pwm_lld_serve_interrupt+0x5a>
 800043c:	686b      	ldr	r3, [r5, #4]
 800043e:	689b      	ldr	r3, [r3, #8]
 8000440:	b11b      	cbz	r3, 800044a <pwm_lld_serve_interrupt+0x5a>
    pwmp->config->callback(pwmp);
 8000442:	4628      	mov	r0, r5
}
 8000444:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pwmp->config->callback(pwmp);
 8000448:	4718      	bx	r3
 800044a:	bd70      	pop	{r4, r5, r6, pc}
 800044c:	0000      	movs	r0, r0
	...

08000450 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 8000450:	b430      	push	{r4, r5}

  dmaStreamDisable(adcp->dmastp);
 8000452:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8000454:	6822      	ldr	r2, [r4, #0]
 8000456:	6813      	ldr	r3, [r2, #0]
 8000458:	f023 031f 	bic.w	r3, r3, #31
 800045c:	6013      	str	r3, [r2, #0]
 800045e:	6813      	ldr	r3, [r2, #0]
 8000460:	f013 0301 	ands.w	r3, r3, #1
 8000464:	d1fb      	bne.n	800045e <adc_lld_stop_conversion+0xe>
 8000466:	7a25      	ldrb	r5, [r4, #8]
  adcp->adc->CR1 = 0;
 8000468:	6a82      	ldr	r2, [r0, #40]	; 0x28
  dmaStreamDisable(adcp->dmastp);
 800046a:	6860      	ldr	r0, [r4, #4]
 800046c:	213d      	movs	r1, #61	; 0x3d
 800046e:	40a9      	lsls	r1, r5
 8000470:	6001      	str	r1, [r0, #0]
  adcp->adc->CR1 = 0;
 8000472:	6053      	str	r3, [r2, #4]
  /* Because ticket #822, preserving injected conversions.*/
  adcp->adc->CR2 &= ~(ADC_CR2_SWSTART);
 8000474:	6893      	ldr	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 8000476:	2101      	movs	r1, #1
  adcp->adc->CR2 &= ~(ADC_CR2_SWSTART);
 8000478:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800047c:	6093      	str	r3, [r2, #8]
}
 800047e:	bc30      	pop	{r4, r5}
  adcp->adc->CR2 = ADC_CR2_ADON;
 8000480:	6091      	str	r1, [r2, #8]
}
 8000482:	4770      	bx	lr
	...

08000490 <_ctl.lto_priv.52>:
#else
    break;
#endif
  }
  return MSG_OK;
}
 8000490:	2000      	movs	r0, #0
 8000492:	4770      	bx	lr
	...

080004a0 <adc_lld_serve_rx_interrupt.lto_priv.41>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80004a0:	f011 0f0c 	tst.w	r1, #12
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 80004a4:	b570      	push	{r4, r5, r6, lr}
 80004a6:	4604      	mov	r4, r0
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80004a8:	d118      	bne.n	80004dc <adc_lld_serve_rx_interrupt.lto_priv.41+0x3c>
    if (adcp->grpp != NULL) {
 80004aa:	6903      	ldr	r3, [r0, #16]
 80004ac:	b1ab      	cbz	r3, 80004da <adc_lld_serve_rx_interrupt.lto_priv.41+0x3a>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 80004ae:	068d      	lsls	r5, r1, #26
 80004b0:	d511      	bpl.n	80004d6 <adc_lld_serve_rx_interrupt.lto_priv.41+0x36>
        _adc_isr_full_code(adcp);
 80004b2:	781a      	ldrb	r2, [r3, #0]
 80004b4:	2a00      	cmp	r2, #0
 80004b6:	d042      	beq.n	800053e <adc_lld_serve_rx_interrupt.lto_priv.41+0x9e>
 80004b8:	685d      	ldr	r5, [r3, #4]
 80004ba:	b175      	cbz	r5, 80004da <adc_lld_serve_rx_interrupt.lto_priv.41+0x3a>
 80004bc:	68c2      	ldr	r2, [r0, #12]
 80004be:	2a01      	cmp	r2, #1
 80004c0:	d938      	bls.n	8000534 <adc_lld_serve_rx_interrupt.lto_priv.41+0x94>
 80004c2:	885e      	ldrh	r6, [r3, #2]
 80004c4:	6883      	ldr	r3, [r0, #8]
 80004c6:	0852      	lsrs	r2, r2, #1
 80004c8:	0051      	lsls	r1, r2, #1
 80004ca:	fb06 3101 	mla	r1, r6, r1, r3
 80004ce:	462b      	mov	r3, r5
}
 80004d0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_full_code(adcp);
 80004d4:	4718      	bx	r3
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 80004d6:	06ca      	lsls	r2, r1, #27
 80004d8:	d423      	bmi.n	8000522 <adc_lld_serve_rx_interrupt.lto_priv.41+0x82>
 80004da:	bd70      	pop	{r4, r5, r6, pc}
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 80004dc:	f7ff ffb8 	bl	8000450 <adc_lld_stop_conversion>
 80004e0:	6923      	ldr	r3, [r4, #16]
 80004e2:	689b      	ldr	r3, [r3, #8]
 80004e4:	2b00      	cmp	r3, #0
 80004e6:	d04a      	beq.n	800057e <adc_lld_serve_rx_interrupt.lto_priv.41+0xde>
 80004e8:	2205      	movs	r2, #5
 80004ea:	7022      	strb	r2, [r4, #0]
 80004ec:	2100      	movs	r1, #0
 80004ee:	4620      	mov	r0, r4
 80004f0:	4798      	blx	r3
 80004f2:	7823      	ldrb	r3, [r4, #0]
 80004f4:	2b05      	cmp	r3, #5
 80004f6:	bf04      	itt	eq
 80004f8:	2302      	moveq	r3, #2
 80004fa:	7023      	strbeq	r3, [r4, #0]
 80004fc:	2300      	movs	r3, #0
 80004fe:	6123      	str	r3, [r4, #16]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000500:	2320      	movs	r3, #32
 8000502:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8000506:	6963      	ldr	r3, [r4, #20]
 8000508:	b13b      	cbz	r3, 800051a <adc_lld_serve_rx_interrupt.lto_priv.41+0x7a>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 800050a:	2100      	movs	r1, #0
    tp->u.rdymsg = msg;
 800050c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    *trp = NULL;
 8000510:	6161      	str	r1, [r4, #20]
    (void) chSchReadyI(tp);
 8000512:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
 8000514:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000516:	f001 fe2b 	bl	8002170 <chSchReadyI>
 800051a:	2300      	movs	r3, #0
 800051c:	f383 8811 	msr	BASEPRI, r3
 8000520:	bd70      	pop	{r4, r5, r6, pc}
        _adc_isr_half_code(adcp);
 8000522:	685b      	ldr	r3, [r3, #4]
 8000524:	2b00      	cmp	r3, #0
 8000526:	d0d8      	beq.n	80004da <adc_lld_serve_rx_interrupt.lto_priv.41+0x3a>
 8000528:	68c2      	ldr	r2, [r0, #12]
 800052a:	6881      	ldr	r1, [r0, #8]
 800052c:	0852      	lsrs	r2, r2, #1
}
 800052e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_half_code(adcp);
 8000532:	4718      	bx	r3
        _adc_isr_full_code(adcp);
 8000534:	462b      	mov	r3, r5
 8000536:	6881      	ldr	r1, [r0, #8]
}
 8000538:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_full_code(adcp);
 800053c:	4718      	bx	r3
 800053e:	f7ff ff87 	bl	8000450 <adc_lld_stop_conversion>
 8000542:	6923      	ldr	r3, [r4, #16]
 8000544:	685b      	ldr	r3, [r3, #4]
 8000546:	b1ab      	cbz	r3, 8000574 <adc_lld_serve_rx_interrupt.lto_priv.41+0xd4>
 8000548:	2204      	movs	r2, #4
 800054a:	7022      	strb	r2, [r4, #0]
 800054c:	68a1      	ldr	r1, [r4, #8]
 800054e:	68e2      	ldr	r2, [r4, #12]
 8000550:	4620      	mov	r0, r4
 8000552:	4798      	blx	r3
 8000554:	7823      	ldrb	r3, [r4, #0]
 8000556:	2b04      	cmp	r3, #4
 8000558:	d00c      	beq.n	8000574 <adc_lld_serve_rx_interrupt.lto_priv.41+0xd4>
 800055a:	2320      	movs	r3, #32
 800055c:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
 8000560:	6963      	ldr	r3, [r4, #20]
 8000562:	2b00      	cmp	r3, #0
 8000564:	d0d9      	beq.n	800051a <adc_lld_serve_rx_interrupt.lto_priv.41+0x7a>
    *trp = NULL;
 8000566:	2200      	movs	r2, #0
 8000568:	6162      	str	r2, [r4, #20]
    (void) chSchReadyI(tp);
 800056a:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
 800056c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800056e:	f001 fdff 	bl	8002170 <chSchReadyI>
 8000572:	e7d2      	b.n	800051a <adc_lld_serve_rx_interrupt.lto_priv.41+0x7a>
 8000574:	2202      	movs	r2, #2
 8000576:	2300      	movs	r3, #0
 8000578:	7022      	strb	r2, [r4, #0]
 800057a:	6123      	str	r3, [r4, #16]
 800057c:	e7ed      	b.n	800055a <adc_lld_serve_rx_interrupt.lto_priv.41+0xba>
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 800057e:	2202      	movs	r2, #2
 8000580:	6123      	str	r3, [r4, #16]
 8000582:	7022      	strb	r2, [r4, #0]
 8000584:	e7bc      	b.n	8000500 <adc_lld_serve_rx_interrupt.lto_priv.41+0x60>
 8000586:	bf00      	nop
	...

08000590 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8000590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000592:	4604      	mov	r4, r0
 8000594:	460f      	mov	r7, r1
 8000596:	4616      	mov	r6, r2
 8000598:	2320      	movs	r3, #32
 800059a:	f383 8811 	msr	BASEPRI, r3
 800059e:	e003      	b.n	80005a8 <oqPutTimeout+0x18>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
 80005a0:	f001 fdbe 	bl	8002120 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 80005a4:	2800      	cmp	r0, #0
 80005a6:	db19      	blt.n	80005dc <oqPutTimeout+0x4c>
  while (oqIsFullI(oqp)) {
 80005a8:	68a5      	ldr	r5, [r4, #8]
 80005aa:	4631      	mov	r1, r6
 80005ac:	4620      	mov	r0, r4
 80005ae:	2d00      	cmp	r5, #0
 80005b0:	d0f6      	beq.n	80005a0 <oqPutTimeout+0x10>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 80005b2:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
 80005b4:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80005b6:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 80005b8:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 80005ba:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
 80005bc:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80005be:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80005c0:	6923      	ldr	r3, [r4, #16]
 80005c2:	6962      	ldr	r2, [r4, #20]
 80005c4:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 80005c6:	bf24      	itt	cs
 80005c8:	68e3      	ldrcs	r3, [r4, #12]
 80005ca:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 80005cc:	69e3      	ldr	r3, [r4, #28]
 80005ce:	b10b      	cbz	r3, 80005d4 <oqPutTimeout+0x44>
    oqp->q_notify(oqp);
 80005d0:	4620      	mov	r0, r4
 80005d2:	4798      	blx	r3
 80005d4:	2000      	movs	r0, #0
 80005d6:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
 80005da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80005dc:	f385 8811 	msr	BASEPRI, r5
 80005e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80005e2:	bf00      	nop
	...

080005f0 <_putt.lto_priv.48>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80005f0:	3030      	adds	r0, #48	; 0x30
 80005f2:	f7ff bfcd 	b.w	8000590 <oqPutTimeout>
 80005f6:	bf00      	nop
	...

08000600 <_put.lto_priv.46>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000600:	3030      	adds	r0, #48	; 0x30
 8000602:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000606:	f7ff bfc3 	b.w	8000590 <oqPutTimeout>
 800060a:	bf00      	nop
 800060c:	0000      	movs	r0, r0
	...

08000610 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8000610:	b570      	push	{r4, r5, r6, lr}
 8000612:	2320      	movs	r3, #32
 8000614:	4604      	mov	r4, r0
 8000616:	460e      	mov	r6, r1
 8000618:	f383 8811 	msr	BASEPRI, r3
 800061c:	e003      	b.n	8000626 <iqGetTimeout+0x16>
 800061e:	f001 fd7f 	bl	8002120 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8000622:	2800      	cmp	r0, #0
 8000624:	db1a      	blt.n	800065c <iqGetTimeout+0x4c>
  while (iqIsEmptyI(iqp)) {
 8000626:	68a5      	ldr	r5, [r4, #8]
 8000628:	4631      	mov	r1, r6
 800062a:	4620      	mov	r0, r4
 800062c:	2d00      	cmp	r5, #0
 800062e:	d0f6      	beq.n	800061e <iqGetTimeout+0xe>
  b = *iqp->q_rdptr++;
 8000630:	69a1      	ldr	r1, [r4, #24]
  iqp->q_counter--;
 8000632:	68a3      	ldr	r3, [r4, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000634:	6920      	ldr	r0, [r4, #16]
  b = *iqp->q_rdptr++;
 8000636:	1c4a      	adds	r2, r1, #1
  iqp->q_counter--;
 8000638:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 800063a:	4282      	cmp	r2, r0
  iqp->q_counter--;
 800063c:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 800063e:	61a2      	str	r2, [r4, #24]
    iqp->q_rdptr = iqp->q_buffer;
 8000640:	bf28      	it	cs
 8000642:	68e3      	ldrcs	r3, [r4, #12]
  b = *iqp->q_rdptr++;
 8000644:	780d      	ldrb	r5, [r1, #0]
    iqp->q_rdptr = iqp->q_buffer;
 8000646:	bf28      	it	cs
 8000648:	61a3      	strcs	r3, [r4, #24]
  if (iqp->q_notify != NULL) {
 800064a:	69e3      	ldr	r3, [r4, #28]
 800064c:	b10b      	cbz	r3, 8000652 <iqGetTimeout+0x42>
    iqp->q_notify(iqp);
 800064e:	4620      	mov	r0, r4
 8000650:	4798      	blx	r3
 8000652:	2300      	movs	r3, #0
 8000654:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 8000658:	4628      	mov	r0, r5
}
 800065a:	bd70      	pop	{r4, r5, r6, pc}
 800065c:	f385 8811 	msr	BASEPRI, r5
 8000660:	bd70      	pop	{r4, r5, r6, pc}
 8000662:	bf00      	nop
	...

08000670 <_gett.lto_priv.49>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000670:	300c      	adds	r0, #12
 8000672:	f7ff bfcd 	b.w	8000610 <iqGetTimeout>
 8000676:	bf00      	nop
	...

08000680 <_get.lto_priv.47>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000680:	300c      	adds	r0, #12
 8000682:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8000686:	f7ff bfc3 	b.w	8000610 <iqGetTimeout>
 800068a:	bf00      	nop
 800068c:	0000      	movs	r0, r0
	...

08000690 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8000690:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000694:	b083      	sub	sp, #12
 8000696:	4617      	mov	r7, r2
 8000698:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 800069a:	f8d0 a01c 	ldr.w	sl, [r0, #28]
 800069e:	f04f 0b20 	mov.w	fp, #32
 80006a2:	f38b 8811 	msr	BASEPRI, fp

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (wr < n) {
 80006a6:	2a00      	cmp	r2, #0
 80006a8:	d051      	beq.n	800074e <oqWriteTimeout+0xbe>
 80006aa:	4604      	mov	r4, r0
 80006ac:	460e      	mov	r6, r1
 80006ae:	f04f 0800 	mov.w	r8, #0
 80006b2:	e017      	b.n	80006e4 <oqWriteTimeout+0x54>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80006b4:	462a      	mov	r2, r5
 80006b6:	4631      	mov	r1, r6
 80006b8:	f7ff fe16 	bl	80002e8 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 80006bc:	68e3      	ldr	r3, [r4, #12]
 80006be:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 80006c0:	68a3      	ldr	r3, [r4, #8]
 80006c2:	1b5b      	subs	r3, r3, r5
 80006c4:	60a3      	str	r3, [r4, #8]
    size_t done;

    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
 80006c6:	b36d      	cbz	r5, 8000724 <oqWriteTimeout+0x94>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 80006c8:	f1ba 0f00 	cmp.w	sl, #0
 80006cc:	d001      	beq.n	80006d2 <oqWriteTimeout+0x42>
        nfy(oqp);
 80006ce:	4620      	mov	r0, r4
 80006d0:	47d0      	blx	sl
 80006d2:	2300      	movs	r3, #0
 80006d4:	f383 8811 	msr	BASEPRI, r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      wr += done;
 80006d8:	44a8      	add	r8, r5
      bp += done;
 80006da:	442e      	add	r6, r5
 80006dc:	f38b 8811 	msr	BASEPRI, fp
  while (wr < n) {
 80006e0:	4547      	cmp	r7, r8
 80006e2:	d925      	bls.n	8000730 <oqWriteTimeout+0xa0>
  if (n > oqGetEmptyI(oqp)) {
 80006e4:	68a3      	ldr	r3, [r4, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 80006e6:	6960      	ldr	r0, [r4, #20]
  if (n > oqGetEmptyI(oqp)) {
 80006e8:	429f      	cmp	r7, r3
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 80006ea:	6923      	ldr	r3, [r4, #16]
    n = oqGetEmptyI(oqp);
 80006ec:	bf8c      	ite	hi
 80006ee:	68a5      	ldrhi	r5, [r4, #8]
  if (n > oqGetEmptyI(oqp)) {
 80006f0:	463d      	movls	r5, r7
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 80006f2:	1a1b      	subs	r3, r3, r0
  if (n < s1) {
 80006f4:	42ab      	cmp	r3, r5
 80006f6:	d822      	bhi.n	800073e <oqWriteTimeout+0xae>
  else if (n > s1) {
 80006f8:	d2dc      	bcs.n	80006b4 <oqWriteTimeout+0x24>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 80006fa:	461a      	mov	r2, r3
 80006fc:	4631      	mov	r1, r6
    s2 = n - s1;
 80006fe:	eba5 0903 	sub.w	r9, r5, r3
 8000702:	9300      	str	r3, [sp, #0]
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8000704:	f7ff fdf0 	bl	80002e8 <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8000708:	9b00      	ldr	r3, [sp, #0]
 800070a:	68e0      	ldr	r0, [r4, #12]
 800070c:	18f1      	adds	r1, r6, r3
 800070e:	464a      	mov	r2, r9
 8000710:	f7ff fdea 	bl	80002e8 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8000714:	68e3      	ldr	r3, [r4, #12]
 8000716:	444b      	add	r3, r9
 8000718:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 800071a:	68a3      	ldr	r3, [r4, #8]
 800071c:	1b5b      	subs	r3, r3, r5
 800071e:	60a3      	str	r3, [r4, #8]
    if (done == (size_t)0) {
 8000720:	2d00      	cmp	r5, #0
 8000722:	d1d1      	bne.n	80006c8 <oqWriteTimeout+0x38>
 8000724:	9901      	ldr	r1, [sp, #4]
 8000726:	4620      	mov	r0, r4
 8000728:	f001 fcfa 	bl	8002120 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 800072c:	2800      	cmp	r0, #0
 800072e:	d0d7      	beq.n	80006e0 <oqWriteTimeout+0x50>
 8000730:	2300      	movs	r3, #0
 8000732:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return wr;
}
 8000736:	4640      	mov	r0, r8
 8000738:	b003      	add	sp, #12
 800073a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 800073e:	462a      	mov	r2, r5
 8000740:	4631      	mov	r1, r6
 8000742:	f7ff fdd1 	bl	80002e8 <memcpy>
    oqp->q_wrptr += n;
 8000746:	6963      	ldr	r3, [r4, #20]
 8000748:	442b      	add	r3, r5
 800074a:	6163      	str	r3, [r4, #20]
 800074c:	e7b8      	b.n	80006c0 <oqWriteTimeout+0x30>
  size_t wr = 0;
 800074e:	4690      	mov	r8, r2
 8000750:	e7ee      	b.n	8000730 <oqWriteTimeout+0xa0>
 8000752:	bf00      	nop
	...

08000760 <_writet.lto_priv.50>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000760:	3030      	adds	r0, #48	; 0x30
 8000762:	f7ff bf95 	b.w	8000690 <oqWriteTimeout>
 8000766:	bf00      	nop
	...

08000770 <_write.lto_priv.44>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000770:	3030      	adds	r0, #48	; 0x30
 8000772:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000776:	f7ff bf8b 	b.w	8000690 <oqWriteTimeout>
 800077a:	bf00      	nop
 800077c:	0000      	movs	r0, r0
	...

08000780 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 8000780:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000784:	b083      	sub	sp, #12
 8000786:	4617      	mov	r7, r2
 8000788:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = iqp->q_notify;
 800078a:	f8d0 a01c 	ldr.w	sl, [r0, #28]
 800078e:	f04f 0b20 	mov.w	fp, #32
 8000792:	f38b 8811 	msr	BASEPRI, fp
  while (rd < n) {
 8000796:	2a00      	cmp	r2, #0
 8000798:	d051      	beq.n	800083e <iqReadTimeout+0xbe>
 800079a:	4604      	mov	r4, r0
 800079c:	460e      	mov	r6, r1
 800079e:	f04f 0800 	mov.w	r8, #0
 80007a2:	e017      	b.n	80007d4 <iqReadTimeout+0x54>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 80007a4:	462a      	mov	r2, r5
 80007a6:	4630      	mov	r0, r6
 80007a8:	f7ff fd9e 	bl	80002e8 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 80007ac:	68e3      	ldr	r3, [r4, #12]
 80007ae:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 80007b0:	68a3      	ldr	r3, [r4, #8]
 80007b2:	1b5b      	subs	r3, r3, r5
 80007b4:	60a3      	str	r3, [r4, #8]
    if (done == (size_t)0) {
 80007b6:	b36d      	cbz	r5, 8000814 <iqReadTimeout+0x94>
      if (nfy != NULL) {
 80007b8:	f1ba 0f00 	cmp.w	sl, #0
 80007bc:	d001      	beq.n	80007c2 <iqReadTimeout+0x42>
        nfy(iqp);
 80007be:	4620      	mov	r0, r4
 80007c0:	47d0      	blx	sl
 80007c2:	2300      	movs	r3, #0
 80007c4:	f383 8811 	msr	BASEPRI, r3
      rd += done;
 80007c8:	44a8      	add	r8, r5
      bp += done;
 80007ca:	442e      	add	r6, r5
 80007cc:	f38b 8811 	msr	BASEPRI, fp
  while (rd < n) {
 80007d0:	4547      	cmp	r7, r8
 80007d2:	d925      	bls.n	8000820 <iqReadTimeout+0xa0>
  if (n > iqGetFullI(iqp)) {
 80007d4:	68a3      	ldr	r3, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 80007d6:	69a1      	ldr	r1, [r4, #24]
  if (n > iqGetFullI(iqp)) {
 80007d8:	429f      	cmp	r7, r3
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 80007da:	6923      	ldr	r3, [r4, #16]
    n = iqGetFullI(iqp);
 80007dc:	bf8c      	ite	hi
 80007de:	68a5      	ldrhi	r5, [r4, #8]
  if (n > iqGetFullI(iqp)) {
 80007e0:	463d      	movls	r5, r7
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 80007e2:	1a5b      	subs	r3, r3, r1
  if (n < s1) {
 80007e4:	42ab      	cmp	r3, r5
 80007e6:	d822      	bhi.n	800082e <iqReadTimeout+0xae>
  else if (n > s1) {
 80007e8:	d2dc      	bcs.n	80007a4 <iqReadTimeout+0x24>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 80007ea:	461a      	mov	r2, r3
 80007ec:	4630      	mov	r0, r6
    s2 = n - s1;
 80007ee:	eba5 0903 	sub.w	r9, r5, r3
 80007f2:	9300      	str	r3, [sp, #0]
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 80007f4:	f7ff fd78 	bl	80002e8 <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 80007f8:	9b00      	ldr	r3, [sp, #0]
 80007fa:	68e1      	ldr	r1, [r4, #12]
 80007fc:	18f0      	adds	r0, r6, r3
 80007fe:	464a      	mov	r2, r9
 8000800:	f7ff fd72 	bl	80002e8 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 8000804:	68e3      	ldr	r3, [r4, #12]
 8000806:	444b      	add	r3, r9
 8000808:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 800080a:	68a3      	ldr	r3, [r4, #8]
 800080c:	1b5b      	subs	r3, r3, r5
 800080e:	60a3      	str	r3, [r4, #8]
    if (done == (size_t)0) {
 8000810:	2d00      	cmp	r5, #0
 8000812:	d1d1      	bne.n	80007b8 <iqReadTimeout+0x38>
 8000814:	9901      	ldr	r1, [sp, #4]
 8000816:	4620      	mov	r0, r4
 8000818:	f001 fc82 	bl	8002120 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 800081c:	2800      	cmp	r0, #0
 800081e:	d0d7      	beq.n	80007d0 <iqReadTimeout+0x50>
 8000820:	2300      	movs	r3, #0
 8000822:	f383 8811 	msr	BASEPRI, r3
}
 8000826:	4640      	mov	r0, r8
 8000828:	b003      	add	sp, #12
 800082a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 800082e:	462a      	mov	r2, r5
 8000830:	4630      	mov	r0, r6
 8000832:	f7ff fd59 	bl	80002e8 <memcpy>
    iqp->q_rdptr += n;
 8000836:	69a3      	ldr	r3, [r4, #24]
 8000838:	442b      	add	r3, r5
 800083a:	61a3      	str	r3, [r4, #24]
 800083c:	e7b8      	b.n	80007b0 <iqReadTimeout+0x30>
  size_t rd = 0;
 800083e:	4690      	mov	r8, r2
 8000840:	e7ee      	b.n	8000820 <iqReadTimeout+0xa0>
 8000842:	bf00      	nop
	...

08000850 <_readt.lto_priv.51>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000850:	300c      	adds	r0, #12
 8000852:	f7ff bf95 	b.w	8000780 <iqReadTimeout>
 8000856:	bf00      	nop
	...

08000860 <_read.lto_priv.45>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000860:	300c      	adds	r0, #12
 8000862:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000866:	f7ff bf8b 	b.w	8000780 <iqReadTimeout>
 800086a:	bf00      	nop
 800086c:	0000      	movs	r0, r0
	...

08000870 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8000870:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  USART_TypeDef *u = sdp->usart;
 8000874:	4d6e      	ldr	r5, [pc, #440]	; (8000a30 <VectorD8+0x1c0>)
 8000876:	6f6e      	ldr	r6, [r5, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8000878:	f8d6 900c 	ldr.w	r9, [r6, #12]
  uint16_t sr = u->SR;
 800087c:	6833      	ldr	r3, [r6, #0]
  if (sr & USART_SR_LBD) {
 800087e:	05da      	lsls	r2, r3, #23
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8000880:	b082      	sub	sp, #8
  uint16_t sr = u->SR;
 8000882:	b29c      	uxth	r4, r3
  if (sr & USART_SR_LBD) {
 8000884:	f100 8083 	bmi.w	800098e <VectorD8+0x11e>
 8000888:	2320      	movs	r3, #32
 800088a:	f383 8811 	msr	BASEPRI, r3
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800088e:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8000892:	d04d      	beq.n	8000930 <VectorD8+0xc0>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000894:	4f67      	ldr	r7, [pc, #412]	; (8000a34 <VectorD8+0x1c4>)

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8000896:	f04f 0a00 	mov.w	sl, #0
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 800089a:	f107 0808 	add.w	r8, r7, #8
 800089e:	e007      	b.n	80008b0 <VectorD8+0x40>
    if (sr & USART_SR_RXNE)
 80008a0:	06a0      	lsls	r0, r4, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 80008a2:	6873      	ldr	r3, [r6, #4]
    if (sr & USART_SR_RXNE)
 80008a4:	d41d      	bmi.n	80008e2 <VectorD8+0x72>
    sr = u->SR;
 80008a6:	6834      	ldr	r4, [r6, #0]
 80008a8:	b2a4      	uxth	r4, r4
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80008aa:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80008ae:	d03f      	beq.n	8000930 <VectorD8+0xc0>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80008b0:	0723      	lsls	r3, r4, #28
 80008b2:	d0f5      	beq.n	80008a0 <VectorD8+0x30>
    sts |= SD_OVERRUN_ERROR;
 80008b4:	f014 0f08 	tst.w	r4, #8
 80008b8:	bf0c      	ite	eq
 80008ba:	2100      	moveq	r1, #0
 80008bc:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 80008be:	07e0      	lsls	r0, r4, #31
    sts |= SD_PARITY_ERROR;
 80008c0:	bf48      	it	mi
 80008c2:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 80008c6:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 80008c8:	bf48      	it	mi
 80008ca:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 80008ce:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 80008d0:	bf48      	it	mi
 80008d2:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 80008d6:	4638      	mov	r0, r7
 80008d8:	f001 fc62 	bl	80021a0 <chEvtBroadcastFlagsI>
    if (sr & USART_SR_RXNE)
 80008dc:	06a0      	lsls	r0, r4, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 80008de:	6873      	ldr	r3, [r6, #4]
    if (sr & USART_SR_RXNE)
 80008e0:	d5e1      	bpl.n	80008a6 <VectorD8+0x36>
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80008e2:	696a      	ldr	r2, [r5, #20]
    b = (uint8_t)u->DR & sdp->rxmask;
 80008e4:	f895 4078 	ldrb.w	r4, [r5, #120]	; 0x78
 80008e8:	2a00      	cmp	r2, #0
 80008ea:	d03d      	beq.n	8000968 <VectorD8+0xf8>
  if (!iqIsFullI(iqp)) {
 80008ec:	6a2a      	ldr	r2, [r5, #32]
 80008ee:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80008f0:	428a      	cmp	r2, r1
 80008f2:	d043      	beq.n	800097c <VectorD8+0x10c>
    iqp->q_counter++;
 80008f4:	6969      	ldr	r1, [r5, #20]
 80008f6:	4023      	ands	r3, r4
    *iqp->q_wrptr++ = b;
 80008f8:	1c50      	adds	r0, r2, #1
    iqp->q_counter++;
 80008fa:	3101      	adds	r1, #1
    *iqp->q_wrptr++ = b;
 80008fc:	6228      	str	r0, [r5, #32]
    iqp->q_counter++;
 80008fe:	6169      	str	r1, [r5, #20]
    *iqp->q_wrptr++ = b;
 8000900:	7013      	strb	r3, [r2, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8000902:	6a2a      	ldr	r2, [r5, #32]
 8000904:	69eb      	ldr	r3, [r5, #28]
 8000906:	429a      	cmp	r2, r3
 8000908:	d301      	bcc.n	800090e <VectorD8+0x9e>
      iqp->q_wrptr = iqp->q_buffer;
 800090a:	69ab      	ldr	r3, [r5, #24]
 800090c:	622b      	str	r3, [r5, #32]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800090e:	68eb      	ldr	r3, [r5, #12]
 8000910:	4543      	cmp	r3, r8
 8000912:	d0c8      	beq.n	80008a6 <VectorD8+0x36>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000914:	681a      	ldr	r2, [r3, #0]
 8000916:	60ea      	str	r2, [r5, #12]
  (void) chSchReadyI(tp);
 8000918:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
 800091a:	f8c2 8004 	str.w	r8, [r2, #4]
  tp->u.rdymsg = msg;
 800091e:	f8c3 a024 	str.w	sl, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000922:	f001 fc25 	bl	8002170 <chSchReadyI>
    sr = u->SR;
 8000926:	6834      	ldr	r4, [r6, #0]
 8000928:	b2a4      	uxth	r4, r4
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800092a:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800092e:	d1bf      	bne.n	80008b0 <VectorD8+0x40>
 8000930:	2300      	movs	r3, #0
 8000932:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8000936:	f019 0f80 	tst.w	r9, #128	; 0x80
 800093a:	d001      	beq.n	8000940 <VectorD8+0xd0>
 800093c:	0622      	lsls	r2, r4, #24
 800093e:	d435      	bmi.n	80009ac <VectorD8+0x13c>
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 8000940:	f019 0f40 	tst.w	r9, #64	; 0x40
 8000944:	d00b      	beq.n	800095e <VectorD8+0xee>
 8000946:	0663      	lsls	r3, r4, #25
 8000948:	d509      	bpl.n	800095e <VectorD8+0xee>
 800094a:	2320      	movs	r3, #32
 800094c:	f383 8811 	msr	BASEPRI, r3
    if (oqIsEmptyI(&sdp->oqueue)) {
 8000950:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8000952:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8000954:	429a      	cmp	r2, r3
 8000956:	d04e      	beq.n	80009f6 <VectorD8+0x186>
 8000958:	2300      	movs	r3, #0
 800095a:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
}
 800095e:	b002      	add	sp, #8
 8000960:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 8000964:	f001 baac 	b.w	8001ec0 <_port_irq_epilogue>
 8000968:	2104      	movs	r1, #4
 800096a:	4638      	mov	r0, r7
 800096c:	9301      	str	r3, [sp, #4]
 800096e:	f001 fc17 	bl	80021a0 <chEvtBroadcastFlagsI>
  if (!iqIsFullI(iqp)) {
 8000972:	6a2a      	ldr	r2, [r5, #32]
 8000974:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8000976:	9b01      	ldr	r3, [sp, #4]
 8000978:	428a      	cmp	r2, r1
 800097a:	d1bb      	bne.n	80008f4 <VectorD8+0x84>
 800097c:	6969      	ldr	r1, [r5, #20]
 800097e:	2900      	cmp	r1, #0
 8000980:	d0b8      	beq.n	80008f4 <VectorD8+0x84>
 8000982:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000986:	4638      	mov	r0, r7
 8000988:	f001 fc0a 	bl	80021a0 <chEvtBroadcastFlagsI>
 800098c:	e78b      	b.n	80008a6 <VectorD8+0x36>
 800098e:	2320      	movs	r3, #32
 8000990:	f383 8811 	msr	BASEPRI, r3
 8000994:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000998:	1d28      	adds	r0, r5, #4
 800099a:	f001 fc01 	bl	80021a0 <chEvtBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 800099e:	f46f 7380 	mvn.w	r3, #256	; 0x100
 80009a2:	6033      	str	r3, [r6, #0]
 80009a4:	2300      	movs	r3, #0
 80009a6:	f383 8811 	msr	BASEPRI, r3
 80009aa:	e76d      	b.n	8000888 <VectorD8+0x18>
 80009ac:	2320      	movs	r3, #32
 80009ae:	f383 8811 	msr	BASEPRI, r3
  if (!oqIsEmptyI(oqp)) {
 80009b2:	6cab      	ldr	r3, [r5, #72]	; 0x48
 80009b4:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 80009b6:	429a      	cmp	r2, r3
 80009b8:	d02a      	beq.n	8000a10 <VectorD8+0x1a0>
    oqp->q_counter++;
 80009ba:	6baa      	ldr	r2, [r5, #56]	; 0x38
    if (oqp->q_rdptr >= oqp->q_top) {
 80009bc:	6c29      	ldr	r1, [r5, #64]	; 0x40
    b = *oqp->q_rdptr++;
 80009be:	1c58      	adds	r0, r3, #1
    oqp->q_counter++;
 80009c0:	3201      	adds	r2, #1
 80009c2:	63aa      	str	r2, [r5, #56]	; 0x38
    b = *oqp->q_rdptr++;
 80009c4:	64a8      	str	r0, [r5, #72]	; 0x48
    if (oqp->q_rdptr >= oqp->q_top) {
 80009c6:	4288      	cmp	r0, r1
    b = *oqp->q_rdptr++;
 80009c8:	781f      	ldrb	r7, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 80009ca:	d301      	bcc.n	80009d0 <VectorD8+0x160>
      oqp->q_rdptr = oqp->q_buffer;
 80009cc:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 80009ce:	64ab      	str	r3, [r5, #72]	; 0x48
  return (bool)(tqp->next != (const thread_t *)tqp);
 80009d0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80009d2:	4a19      	ldr	r2, [pc, #100]	; (8000a38 <VectorD8+0x1c8>)
 80009d4:	4293      	cmp	r3, r2
 80009d6:	d009      	beq.n	80009ec <VectorD8+0x17c>
  tqp->next             = tp->queue.next;
 80009d8:	6819      	ldr	r1, [r3, #0]
 80009da:	6329      	str	r1, [r5, #48]	; 0x30
  tp->u.rdymsg = msg;
 80009dc:	f04f 0e00 	mov.w	lr, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80009e0:	604a      	str	r2, [r1, #4]
  (void) chSchReadyI(tp);
 80009e2:	4618      	mov	r0, r3
  tp->u.rdymsg = msg;
 80009e4:	f8c3 e024 	str.w	lr, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 80009e8:	f001 fbc2 	bl	8002170 <chSchReadyI>
      u->DR = b;
 80009ec:	6077      	str	r7, [r6, #4]
 80009ee:	2300      	movs	r3, #0
 80009f0:	f383 8811 	msr	BASEPRI, r3
 80009f4:	e7a4      	b.n	8000940 <VectorD8+0xd0>
    if (oqIsEmptyI(&sdp->oqueue)) {
 80009f6:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80009f8:	2b00      	cmp	r3, #0
 80009fa:	d0ad      	beq.n	8000958 <VectorD8+0xe8>
 80009fc:	2110      	movs	r1, #16
 80009fe:	480d      	ldr	r0, [pc, #52]	; (8000a34 <VectorD8+0x1c4>)
 8000a00:	f001 fbce 	bl	80021a0 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000a04:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8000a08:	ea09 0303 	and.w	r3, r9, r3
 8000a0c:	60f3      	str	r3, [r6, #12]
 8000a0e:	e7a3      	b.n	8000958 <VectorD8+0xe8>
  if (!oqIsEmptyI(oqp)) {
 8000a10:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8000a12:	2a00      	cmp	r2, #0
 8000a14:	d0d1      	beq.n	80009ba <VectorD8+0x14a>
 8000a16:	2108      	movs	r1, #8
 8000a18:	4806      	ldr	r0, [pc, #24]	; (8000a34 <VectorD8+0x1c4>)
 8000a1a:	f001 fbc1 	bl	80021a0 <chEvtBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000a1e:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8000a22:	ea09 0303 	and.w	r3, r9, r3
 8000a26:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000a2a:	60f3      	str	r3, [r6, #12]
 8000a2c:	e7df      	b.n	80009ee <VectorD8+0x17e>
 8000a2e:	bf00      	nop
 8000a30:	2000104c 	.word	0x2000104c
 8000a34:	20001050 	.word	0x20001050
 8000a38:	2000107c 	.word	0x2000107c
 8000a3c:	00000000 	.word	0x00000000

08000a40 <VectorB8>:
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8000a40:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD4);
 8000a42:	4803      	ldr	r0, [pc, #12]	; (8000a50 <VectorB8+0x10>)
 8000a44:	f7ff fcd4 	bl	80003f0 <pwm_lld_serve_interrupt>
}
 8000a48:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8000a4c:	f001 ba38 	b.w	8001ec0 <_port_irq_epilogue>
 8000a50:	20000870 	.word	0x20000870
	...

08000a60 <VectorB4>:
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8000a60:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD3);
 8000a62:	4803      	ldr	r0, [pc, #12]	; (8000a70 <VectorB4+0x10>)
 8000a64:	f7ff fcc4 	bl	80003f0 <pwm_lld_serve_interrupt>
}
 8000a68:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8000a6c:	f001 ba28 	b.w	8001ec0 <_port_irq_epilogue>
 8000a70:	20000854 	.word	0x20000854
	...

08000a80 <VectorA4>:
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8000a80:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD1);
 8000a82:	4803      	ldr	r0, [pc, #12]	; (8000a90 <VectorA4+0x10>)
 8000a84:	f7ff fcb4 	bl	80003f0 <pwm_lld_serve_interrupt>
}
 8000a88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8000a8c:	f001 ba18 	b.w	8001ec0 <_port_irq_epilogue>
 8000a90:	20000838 	.word	0x20000838
	...

08000aa0 <VectorAC>:
 8000aa0:	f7ff bfee 	b.w	8000a80 <VectorA4>
	...

08000ab0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000ab0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000ab4:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 8000ab8:	693b      	ldr	r3, [r7, #16]
 8000aba:	079b      	lsls	r3, r3, #30
 8000abc:	d403      	bmi.n	8000ac6 <VectorB0+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8000abe:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 8000ac2:	f001 b9fd 	b.w	8001ec0 <_port_irq_epilogue>
    STM32_ST_TIM->SR = 0U;
 8000ac6:	2100      	movs	r1, #0
 8000ac8:	6139      	str	r1, [r7, #16]
 8000aca:	2320      	movs	r3, #32
 8000acc:	f383 8811 	msr	BASEPRI, r3
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8000ad0:	4c1e      	ldr	r4, [pc, #120]	; (8000b4c <VectorB0+0x9c>)
 8000ad2:	46a1      	mov	r9, r4
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000ad4:	46b8      	mov	r8, r7
 8000ad6:	f859 3f1c 	ldr.w	r3, [r9, #28]!
 8000ada:	689a      	ldr	r2, [r3, #8]
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 8000adc:	460f      	mov	r7, r1
 8000ade:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8000ae2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8000ae4:	1a45      	subs	r5, r0, r1
    if (nowdelta < vtp->delta) {
 8000ae6:	4295      	cmp	r5, r2
 8000ae8:	d31b      	bcc.n	8000b22 <VectorB0+0x72>
 8000aea:	2620      	movs	r6, #32
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000aec:	6818      	ldr	r0, [r3, #0]
      fn = vtp->func;
 8000aee:	f8d3 a00c 	ldr.w	sl, [r3, #12]
      ch.vtlist.lasttime += vtp->delta;
 8000af2:	4411      	add	r1, r2

      /* if the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000af4:	4548      	cmp	r0, r9
      ch.vtlist.lasttime += vtp->delta;
 8000af6:	62a1      	str	r1, [r4, #40]	; 0x28
      nowdelta -= vtp->delta;
 8000af8:	eba5 0502 	sub.w	r5, r5, r2
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000afc:	f8c0 9004 	str.w	r9, [r0, #4]
      ch.vtlist.next = vtp->next;
 8000b00:	61e0      	str	r0, [r4, #28]
      vtp->func = NULL;
 8000b02:	60df      	str	r7, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000b04:	bf08      	it	eq
 8000b06:	f8c8 700c 	streq.w	r7, [r8, #12]
 8000b0a:	f387 8811 	msr	BASEPRI, r7
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 8000b0e:	6918      	ldr	r0, [r3, #16]
 8000b10:	47d0      	blx	sl
 8000b12:	f386 8811 	msr	BASEPRI, r6
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 8000b16:	69e3      	ldr	r3, [r4, #28]
    }
    while (vtp->delta <= nowdelta);
 8000b18:	689a      	ldr	r2, [r3, #8]
 8000b1a:	4295      	cmp	r5, r2
 8000b1c:	d3df      	bcc.n	8000ade <VectorB0+0x2e>
 8000b1e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000b20:	e7e4      	b.n	8000aec <VectorB0+0x3c>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000b22:	69e2      	ldr	r2, [r4, #28]
 8000b24:	454a      	cmp	r2, r9
 8000b26:	d00a      	beq.n	8000b3e <VectorB0+0x8e>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 8000b28:	6891      	ldr	r1, [r2, #8]
  ch.vtlist.lasttime += nowdelta;
 8000b2a:	62a0      	str	r0, [r4, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 8000b2c:	1b4d      	subs	r5, r1, r5
 8000b2e:	6095      	str	r5, [r2, #8]
  return systime + (systime_t)interval;
 8000b30:	689b      	ldr	r3, [r3, #8]
 8000b32:	2b02      	cmp	r3, #2
 8000b34:	bf2c      	ite	cs
 8000b36:	18c0      	addcs	r0, r0, r3
 8000b38:	3002      	addcc	r0, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000b3a:	f8c8 0034 	str.w	r0, [r8, #52]	; 0x34
 8000b3e:	2300      	movs	r3, #0
 8000b40:	f383 8811 	msr	BASEPRI, r3
}
 8000b44:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 8000b48:	f001 b9ba 	b.w	8001ec0 <_port_irq_epilogue>
 8000b4c:	200010c8 	.word	0x200010c8

08000b50 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8000b50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000b54:	f002 0a03 	and.w	sl, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8000b58:	f3c2 0880 	ubfx	r8, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8000b5c:	f3c2 0cc1 	ubfx	ip, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8000b60:	f3c2 1e41 	ubfx	lr, r2, #5, #2
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000b64:	46d1      	mov	r9, sl
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8000b66:	f3c2 12c3 	ubfx	r2, r2, #7, #4
  uint32_t bit     = 0;
 8000b6a:	2700      	movs	r7, #0
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8000b6c:	f04f 0b0f 	mov.w	fp, #15
 8000b70:	e00f      	b.n	8000b92 <_pal_lld_setgroupmode+0x42>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000b72:	6a03      	ldr	r3, [r0, #32]
 8000b74:	ea23 0404 	bic.w	r4, r3, r4
 8000b78:	4325      	orrs	r5, r4
 8000b7a:	6205      	str	r5, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 8000b7c:	0849      	lsrs	r1, r1, #1
 8000b7e:	d039      	beq.n	8000bf4 <_pal_lld_setgroupmode+0xa4>
      return;
    otyper <<= 1;
 8000b80:	ea4f 0848 	mov.w	r8, r8, lsl #1
    ospeedr <<= 2;
 8000b84:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    pupdr <<= 2;
 8000b88:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    moder <<= 2;
 8000b8c:	ea4f 0989 	mov.w	r9, r9, lsl #2
    bit++;
 8000b90:	3701      	adds	r7, #1
    if ((mask & 1) != 0) {
 8000b92:	07cb      	lsls	r3, r1, #31
 8000b94:	d5f2      	bpl.n	8000b7c <_pal_lld_setgroupmode+0x2c>
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000b96:	6843      	ldr	r3, [r0, #4]
      m1 = 1 << bit;
 8000b98:	2401      	movs	r4, #1
 8000b9a:	40bc      	lsls	r4, r7
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000b9c:	ea23 0304 	bic.w	r3, r3, r4
 8000ba0:	ea43 0308 	orr.w	r3, r3, r8
 8000ba4:	6043      	str	r3, [r0, #4]
      m2 = 3 << (bit * 2);
 8000ba6:	2503      	movs	r5, #3
 8000ba8:	007b      	lsls	r3, r7, #1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000baa:	6884      	ldr	r4, [r0, #8]
      m2 = 3 << (bit * 2);
 8000bac:	fa05 f303 	lsl.w	r3, r5, r3
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000bb0:	43db      	mvns	r3, r3
 8000bb2:	401c      	ands	r4, r3
 8000bb4:	ea44 040c 	orr.w	r4, r4, ip
 8000bb8:	6084      	str	r4, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000bba:	68c5      	ldr	r5, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 8000bbc:	f007 0407 	and.w	r4, r7, #7
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000bc0:	401d      	ands	r5, r3
 8000bc2:	ea45 050e 	orr.w	r5, r5, lr
      altrmask = altr << ((bit & 7) * 4);
 8000bc6:	00a4      	lsls	r4, r4, #2
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8000bc8:	f1ba 0f02 	cmp.w	sl, #2
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000bcc:	60c5      	str	r5, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 8000bce:	fa02 f504 	lsl.w	r5, r2, r4
      m4 = 15 << ((bit & 7) * 4);
 8000bd2:	fa0b f404 	lsl.w	r4, fp, r4
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8000bd6:	d00f      	beq.n	8000bf8 <_pal_lld_setgroupmode+0xa8>
        port->MODER   = (port->MODER & ~m2) | moder;
 8000bd8:	6806      	ldr	r6, [r0, #0]
 8000bda:	4033      	ands	r3, r6
 8000bdc:	ea43 0309 	orr.w	r3, r3, r9
        if (bit < 8)
 8000be0:	2f07      	cmp	r7, #7
        port->MODER   = (port->MODER & ~m2) | moder;
 8000be2:	6003      	str	r3, [r0, #0]
        if (bit < 8)
 8000be4:	d9c5      	bls.n	8000b72 <_pal_lld_setgroupmode+0x22>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000be6:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000be8:	ea23 0404 	bic.w	r4, r3, r4
 8000bec:	4325      	orrs	r5, r4
    if (!mask)
 8000bee:	0849      	lsrs	r1, r1, #1
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000bf0:	6245      	str	r5, [r0, #36]	; 0x24
    if (!mask)
 8000bf2:	d1c5      	bne.n	8000b80 <_pal_lld_setgroupmode+0x30>
 8000bf4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (bit < 8)
 8000bf8:	2f07      	cmp	r7, #7
 8000bfa:	d80a      	bhi.n	8000c12 <_pal_lld_setgroupmode+0xc2>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000bfc:	6a06      	ldr	r6, [r0, #32]
 8000bfe:	ea26 0404 	bic.w	r4, r6, r4
 8000c02:	4325      	orrs	r5, r4
 8000c04:	6205      	str	r5, [r0, #32]
        port->MODER   = (port->MODER & ~m2) | moder;
 8000c06:	6804      	ldr	r4, [r0, #0]
 8000c08:	4023      	ands	r3, r4
 8000c0a:	ea43 0309 	orr.w	r3, r3, r9
 8000c0e:	6003      	str	r3, [r0, #0]
 8000c10:	e7b4      	b.n	8000b7c <_pal_lld_setgroupmode+0x2c>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000c12:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8000c14:	ea26 0404 	bic.w	r4, r6, r4
 8000c18:	4325      	orrs	r5, r4
 8000c1a:	6245      	str	r5, [r0, #36]	; 0x24
 8000c1c:	e7f3      	b.n	8000c06 <_pal_lld_setgroupmode+0xb6>
 8000c1e:	bf00      	nop

08000c20 <Vector158>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8000c20:	4b08      	ldr	r3, [pc, #32]	; (8000c44 <Vector158+0x24>)
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 8000c22:	4809      	ldr	r0, [pc, #36]	; (8000c48 <Vector158+0x28>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8000c24:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[15].dma_func)
 8000c26:	6f82      	ldr	r2, [r0, #120]	; 0x78
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8000c28:	0d89      	lsrs	r1, r1, #22
 8000c2a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8000c2e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 22U;
 8000c30:	058c      	lsls	r4, r1, #22
 8000c32:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 8000c34:	b10a      	cbz	r2, 8000c3a <Vector158+0x1a>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8000c36:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8000c38:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8000c3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000c3e:	f001 b93f 	b.w	8001ec0 <_port_irq_epilogue>
 8000c42:	bf00      	nop
 8000c44:	40026400 	.word	0x40026400
 8000c48:	20000a60 	.word	0x20000a60
 8000c4c:	00000000 	.word	0x00000000

08000c50 <Vector154>:
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8000c50:	4b08      	ldr	r3, [pc, #32]	; (8000c74 <Vector154+0x24>)
  if (dma_isr_redir[14].dma_func)
 8000c52:	4809      	ldr	r0, [pc, #36]	; (8000c78 <Vector154+0x28>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8000c54:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[14].dma_func)
 8000c56:	6f02      	ldr	r2, [r0, #112]	; 0x70
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8000c58:	0c09      	lsrs	r1, r1, #16
 8000c5a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8000c5e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 16U;
 8000c60:	040c      	lsls	r4, r1, #16
 8000c62:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 8000c64:	b10a      	cbz	r2, 8000c6a <Vector154+0x1a>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8000c66:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8000c68:	4790      	blx	r2
}
 8000c6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000c6e:	f001 b927 	b.w	8001ec0 <_port_irq_epilogue>
 8000c72:	bf00      	nop
 8000c74:	40026400 	.word	0x40026400
 8000c78:	20000a60 	.word	0x20000a60
 8000c7c:	00000000 	.word	0x00000000

08000c80 <Vector150>:
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8000c80:	4b08      	ldr	r3, [pc, #32]	; (8000ca4 <Vector150+0x24>)
  if (dma_isr_redir[13].dma_func)
 8000c82:	4809      	ldr	r0, [pc, #36]	; (8000ca8 <Vector150+0x28>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8000c84:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[13].dma_func)
 8000c86:	6e82      	ldr	r2, [r0, #104]	; 0x68
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8000c88:	0989      	lsrs	r1, r1, #6
 8000c8a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8000c8e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 6U;
 8000c90:	018c      	lsls	r4, r1, #6
 8000c92:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 8000c94:	b10a      	cbz	r2, 8000c9a <Vector150+0x1a>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8000c96:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8000c98:	4790      	blx	r2
}
 8000c9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000c9e:	f001 b90f 	b.w	8001ec0 <_port_irq_epilogue>
 8000ca2:	bf00      	nop
 8000ca4:	40026400 	.word	0x40026400
 8000ca8:	20000a60 	.word	0x20000a60
 8000cac:	00000000 	.word	0x00000000

08000cb0 <Vector130>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8000cb0:	b508      	push	{r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8000cb2:	4b07      	ldr	r3, [pc, #28]	; (8000cd0 <Vector130+0x20>)
  if (dma_isr_redir[12].dma_func)
 8000cb4:	4807      	ldr	r0, [pc, #28]	; (8000cd4 <Vector130+0x24>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8000cb6:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[12].dma_func)
 8000cb8:	6e02      	ldr	r2, [r0, #96]	; 0x60
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8000cba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 8000cbe:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 8000cc0:	b10a      	cbz	r2, 8000cc6 <Vector130+0x16>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 8000cc2:	6e40      	ldr	r0, [r0, #100]	; 0x64
 8000cc4:	4790      	blx	r2
}
 8000cc6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8000cca:	f001 b8f9 	b.w	8001ec0 <_port_irq_epilogue>
 8000cce:	bf00      	nop
 8000cd0:	40026400 	.word	0x40026400
 8000cd4:	20000a60 	.word	0x20000a60
	...

08000ce0 <Vector12C>:
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8000ce0:	4b08      	ldr	r3, [pc, #32]	; (8000d04 <Vector12C+0x24>)
  if (dma_isr_redir[11].dma_func)
 8000ce2:	4809      	ldr	r0, [pc, #36]	; (8000d08 <Vector12C+0x28>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8000ce4:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[11].dma_func)
 8000ce6:	6d82      	ldr	r2, [r0, #88]	; 0x58
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8000ce8:	0d89      	lsrs	r1, r1, #22
 8000cea:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8000cee:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 22U;
 8000cf0:	058c      	lsls	r4, r1, #22
 8000cf2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 8000cf4:	b10a      	cbz	r2, 8000cfa <Vector12C+0x1a>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8000cf6:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 8000cf8:	4790      	blx	r2
}
 8000cfa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000cfe:	f001 b8df 	b.w	8001ec0 <_port_irq_epilogue>
 8000d02:	bf00      	nop
 8000d04:	40026400 	.word	0x40026400
 8000d08:	20000a60 	.word	0x20000a60
 8000d0c:	00000000 	.word	0x00000000

08000d10 <Vector128>:
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8000d10:	4b08      	ldr	r3, [pc, #32]	; (8000d34 <Vector128+0x24>)
  if (dma_isr_redir[10].dma_func)
 8000d12:	4809      	ldr	r0, [pc, #36]	; (8000d38 <Vector128+0x28>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8000d14:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[10].dma_func)
 8000d16:	6d02      	ldr	r2, [r0, #80]	; 0x50
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8000d18:	0c09      	lsrs	r1, r1, #16
 8000d1a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8000d1e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 16U;
 8000d20:	040c      	lsls	r4, r1, #16
 8000d22:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 8000d24:	b10a      	cbz	r2, 8000d2a <Vector128+0x1a>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8000d26:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8000d28:	4790      	blx	r2
}
 8000d2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000d2e:	f001 b8c7 	b.w	8001ec0 <_port_irq_epilogue>
 8000d32:	bf00      	nop
 8000d34:	40026400 	.word	0x40026400
 8000d38:	20000a60 	.word	0x20000a60
 8000d3c:	00000000 	.word	0x00000000

08000d40 <Vector124>:
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8000d40:	4b08      	ldr	r3, [pc, #32]	; (8000d64 <Vector124+0x24>)
  if (dma_isr_redir[9].dma_func)
 8000d42:	4809      	ldr	r0, [pc, #36]	; (8000d68 <Vector124+0x28>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8000d44:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[9].dma_func)
 8000d46:	6c82      	ldr	r2, [r0, #72]	; 0x48
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8000d48:	0989      	lsrs	r1, r1, #6
 8000d4a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8000d4e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 6U;
 8000d50:	018c      	lsls	r4, r1, #6
 8000d52:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 8000d54:	b10a      	cbz	r2, 8000d5a <Vector124+0x1a>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8000d56:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8000d58:	4790      	blx	r2
}
 8000d5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000d5e:	f001 b8af 	b.w	8001ec0 <_port_irq_epilogue>
 8000d62:	bf00      	nop
 8000d64:	40026400 	.word	0x40026400
 8000d68:	20000a60 	.word	0x20000a60
 8000d6c:	00000000 	.word	0x00000000

08000d70 <Vector120>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8000d70:	b508      	push	{r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8000d72:	4b07      	ldr	r3, [pc, #28]	; (8000d90 <Vector120+0x20>)
  if (dma_isr_redir[8].dma_func)
 8000d74:	4807      	ldr	r0, [pc, #28]	; (8000d94 <Vector120+0x24>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8000d76:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[8].dma_func)
 8000d78:	6c02      	ldr	r2, [r0, #64]	; 0x40
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8000d7a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 8000d7e:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 8000d80:	b10a      	cbz	r2, 8000d86 <Vector120+0x16>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 8000d82:	6c40      	ldr	r0, [r0, #68]	; 0x44
 8000d84:	4790      	blx	r2
}
 8000d86:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8000d8a:	f001 b899 	b.w	8001ec0 <_port_irq_epilogue>
 8000d8e:	bf00      	nop
 8000d90:	40026400 	.word	0x40026400
 8000d94:	20000a60 	.word	0x20000a60
	...

08000da0 <VectorFC>:
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8000da0:	4b08      	ldr	r3, [pc, #32]	; (8000dc4 <VectorFC+0x24>)
  if (dma_isr_redir[7].dma_func)
 8000da2:	4809      	ldr	r0, [pc, #36]	; (8000dc8 <VectorFC+0x28>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8000da4:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[7].dma_func)
 8000da6:	6b82      	ldr	r2, [r0, #56]	; 0x38
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8000da8:	0d89      	lsrs	r1, r1, #22
 8000daa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8000dae:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 22U;
 8000db0:	058c      	lsls	r4, r1, #22
 8000db2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 8000db4:	b10a      	cbz	r2, 8000dba <VectorFC+0x1a>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 8000db6:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8000db8:	4790      	blx	r2
}
 8000dba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000dbe:	f001 b87f 	b.w	8001ec0 <_port_irq_epilogue>
 8000dc2:	bf00      	nop
 8000dc4:	40026000 	.word	0x40026000
 8000dc8:	20000a60 	.word	0x20000a60
 8000dcc:	00000000 	.word	0x00000000

08000dd0 <Vector84>:
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8000dd0:	4b08      	ldr	r3, [pc, #32]	; (8000df4 <Vector84+0x24>)
  if (dma_isr_redir[6].dma_func)
 8000dd2:	4809      	ldr	r0, [pc, #36]	; (8000df8 <Vector84+0x28>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8000dd4:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[6].dma_func)
 8000dd6:	6b02      	ldr	r2, [r0, #48]	; 0x30
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8000dd8:	0c09      	lsrs	r1, r1, #16
 8000dda:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8000dde:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 16U;
 8000de0:	040c      	lsls	r4, r1, #16
 8000de2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 8000de4:	b10a      	cbz	r2, 8000dea <Vector84+0x1a>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8000de6:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8000de8:	4790      	blx	r2
}
 8000dea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000dee:	f001 b867 	b.w	8001ec0 <_port_irq_epilogue>
 8000df2:	bf00      	nop
 8000df4:	40026000 	.word	0x40026000
 8000df8:	20000a60 	.word	0x20000a60
 8000dfc:	00000000 	.word	0x00000000

08000e00 <Vector80>:
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8000e00:	4b08      	ldr	r3, [pc, #32]	; (8000e24 <Vector80+0x24>)
  if (dma_isr_redir[5].dma_func)
 8000e02:	4809      	ldr	r0, [pc, #36]	; (8000e28 <Vector80+0x28>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8000e04:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[5].dma_func)
 8000e06:	6a82      	ldr	r2, [r0, #40]	; 0x28
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8000e08:	0989      	lsrs	r1, r1, #6
 8000e0a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8000e0e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 6U;
 8000e10:	018c      	lsls	r4, r1, #6
 8000e12:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 8000e14:	b10a      	cbz	r2, 8000e1a <Vector80+0x1a>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8000e16:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8000e18:	4790      	blx	r2
}
 8000e1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000e1e:	f001 b84f 	b.w	8001ec0 <_port_irq_epilogue>
 8000e22:	bf00      	nop
 8000e24:	40026000 	.word	0x40026000
 8000e28:	20000a60 	.word	0x20000a60
 8000e2c:	00000000 	.word	0x00000000

08000e30 <Vector7C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8000e30:	b508      	push	{r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8000e32:	4b07      	ldr	r3, [pc, #28]	; (8000e50 <Vector7C+0x20>)
  if (dma_isr_redir[4].dma_func)
 8000e34:	4807      	ldr	r0, [pc, #28]	; (8000e54 <Vector7C+0x24>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8000e36:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[4].dma_func)
 8000e38:	6a02      	ldr	r2, [r0, #32]
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8000e3a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 8000e3e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 8000e40:	b10a      	cbz	r2, 8000e46 <Vector7C+0x16>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8000e42:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8000e44:	4790      	blx	r2
}
 8000e46:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8000e4a:	f001 b839 	b.w	8001ec0 <_port_irq_epilogue>
 8000e4e:	bf00      	nop
 8000e50:	40026000 	.word	0x40026000
 8000e54:	20000a60 	.word	0x20000a60
	...

08000e60 <Vector78>:
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8000e60:	4b08      	ldr	r3, [pc, #32]	; (8000e84 <Vector78+0x24>)
  if (dma_isr_redir[3].dma_func)
 8000e62:	4809      	ldr	r0, [pc, #36]	; (8000e88 <Vector78+0x28>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8000e64:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[3].dma_func)
 8000e66:	6982      	ldr	r2, [r0, #24]
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8000e68:	0d89      	lsrs	r1, r1, #22
 8000e6a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8000e6e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 22U;
 8000e70:	058c      	lsls	r4, r1, #22
 8000e72:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 8000e74:	b10a      	cbz	r2, 8000e7a <Vector78+0x1a>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8000e76:	69c0      	ldr	r0, [r0, #28]
 8000e78:	4790      	blx	r2
}
 8000e7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000e7e:	f001 b81f 	b.w	8001ec0 <_port_irq_epilogue>
 8000e82:	bf00      	nop
 8000e84:	40026000 	.word	0x40026000
 8000e88:	20000a60 	.word	0x20000a60
 8000e8c:	00000000 	.word	0x00000000

08000e90 <Vector74>:
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8000e90:	4b08      	ldr	r3, [pc, #32]	; (8000eb4 <Vector74+0x24>)
  if (dma_isr_redir[2].dma_func)
 8000e92:	4809      	ldr	r0, [pc, #36]	; (8000eb8 <Vector74+0x28>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8000e94:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[2].dma_func)
 8000e96:	6902      	ldr	r2, [r0, #16]
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8000e98:	0c09      	lsrs	r1, r1, #16
 8000e9a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8000e9e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 16U;
 8000ea0:	040c      	lsls	r4, r1, #16
 8000ea2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 8000ea4:	b10a      	cbz	r2, 8000eaa <Vector74+0x1a>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8000ea6:	6940      	ldr	r0, [r0, #20]
 8000ea8:	4790      	blx	r2
}
 8000eaa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000eae:	f001 b807 	b.w	8001ec0 <_port_irq_epilogue>
 8000eb2:	bf00      	nop
 8000eb4:	40026000 	.word	0x40026000
 8000eb8:	20000a60 	.word	0x20000a60
 8000ebc:	00000000 	.word	0x00000000

08000ec0 <Vector70>:
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8000ec0:	4b08      	ldr	r3, [pc, #32]	; (8000ee4 <Vector70+0x24>)
  if (dma_isr_redir[1].dma_func)
 8000ec2:	4809      	ldr	r0, [pc, #36]	; (8000ee8 <Vector70+0x28>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8000ec4:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[1].dma_func)
 8000ec6:	6882      	ldr	r2, [r0, #8]
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8000ec8:	0989      	lsrs	r1, r1, #6
 8000eca:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8000ece:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 6U;
 8000ed0:	018c      	lsls	r4, r1, #6
 8000ed2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 8000ed4:	b10a      	cbz	r2, 8000eda <Vector70+0x1a>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8000ed6:	68c0      	ldr	r0, [r0, #12]
 8000ed8:	4790      	blx	r2
}
 8000eda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000ede:	f000 bfef 	b.w	8001ec0 <_port_irq_epilogue>
 8000ee2:	bf00      	nop
 8000ee4:	40026000 	.word	0x40026000
 8000ee8:	20000a60 	.word	0x20000a60
 8000eec:	00000000 	.word	0x00000000

08000ef0 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8000ef0:	b508      	push	{r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8000ef2:	4b07      	ldr	r3, [pc, #28]	; (8000f10 <Vector6C+0x20>)
  if (dma_isr_redir[0].dma_func)
 8000ef4:	4a07      	ldr	r2, [pc, #28]	; (8000f14 <Vector6C+0x24>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8000ef6:	6819      	ldr	r1, [r3, #0]
 8000ef8:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 8000efc:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 8000efe:	6813      	ldr	r3, [r2, #0]
 8000f00:	b10b      	cbz	r3, 8000f06 <Vector6C+0x16>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8000f02:	6850      	ldr	r0, [r2, #4]
 8000f04:	4798      	blx	r3
}
 8000f06:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8000f0a:	f000 bfd9 	b.w	8001ec0 <_port_irq_epilogue>
 8000f0e:	bf00      	nop
 8000f10:	40026000 	.word	0x40026000
 8000f14:	20000a60 	.word	0x20000a60
	...

08000f20 <Vector88>:
  sr = ADC1->SR;
 8000f20:	4b1c      	ldr	r3, [pc, #112]	; (8000f94 <Vector88+0x74>)
 8000f22:	681a      	ldr	r2, [r3, #0]
  ADC1->SR = 0;
 8000f24:	2100      	movs	r1, #0
 8000f26:	6019      	str	r1, [r3, #0]
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 8000f28:	0693      	lsls	r3, r2, #26
 8000f2a:	d52c      	bpl.n	8000f86 <Vector88+0x66>
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
 8000f2c:	b510      	push	{r4, lr}
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 8000f2e:	4c1a      	ldr	r4, [pc, #104]	; (8000f98 <Vector88+0x78>)
 8000f30:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000f32:	681b      	ldr	r3, [r3, #0]
 8000f34:	685b      	ldr	r3, [r3, #4]
 8000f36:	b313      	cbz	r3, 8000f7e <Vector88+0x5e>
    if (ADCD1.grpp != NULL)
 8000f38:	6923      	ldr	r3, [r4, #16]
 8000f3a:	b303      	cbz	r3, 8000f7e <Vector88+0x5e>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 8000f3c:	4620      	mov	r0, r4
 8000f3e:	f7ff fa87 	bl	8000450 <adc_lld_stop_conversion>
 8000f42:	6923      	ldr	r3, [r4, #16]
 8000f44:	689b      	ldr	r3, [r3, #8]
 8000f46:	b303      	cbz	r3, 8000f8a <Vector88+0x6a>
 8000f48:	2205      	movs	r2, #5
 8000f4a:	7022      	strb	r2, [r4, #0]
 8000f4c:	2101      	movs	r1, #1
 8000f4e:	4620      	mov	r0, r4
 8000f50:	4798      	blx	r3
 8000f52:	7823      	ldrb	r3, [r4, #0]
 8000f54:	2b05      	cmp	r3, #5
 8000f56:	bf04      	itt	eq
 8000f58:	2302      	moveq	r3, #2
 8000f5a:	7023      	strbeq	r3, [r4, #0]
 8000f5c:	2300      	movs	r3, #0
 8000f5e:	6123      	str	r3, [r4, #16]
 8000f60:	2320      	movs	r3, #32
 8000f62:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
 8000f66:	6960      	ldr	r0, [r4, #20]
 8000f68:	b130      	cbz	r0, 8000f78 <Vector88+0x58>
    tp->u.rdymsg = msg;
 8000f6a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000f6e:	6243      	str	r3, [r0, #36]	; 0x24
    *trp = NULL;
 8000f70:	2300      	movs	r3, #0
 8000f72:	6163      	str	r3, [r4, #20]
    (void) chSchReadyI(tp);
 8000f74:	f001 f8fc 	bl	8002170 <chSchReadyI>
 8000f78:	2300      	movs	r3, #0
 8000f7a:	f383 8811 	msr	BASEPRI, r3
}
 8000f7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000f82:	f000 bf9d 	b.w	8001ec0 <_port_irq_epilogue>
 8000f86:	f000 bf9b 	b.w	8001ec0 <_port_irq_epilogue>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 8000f8a:	2202      	movs	r2, #2
 8000f8c:	6123      	str	r3, [r4, #16]
 8000f8e:	7022      	strb	r2, [r4, #0]
 8000f90:	e7e6      	b.n	8000f60 <Vector88+0x40>
 8000f92:	bf00      	nop
 8000f94:	40012000 	.word	0x40012000
 8000f98:	20001018 	.word	0x20001018
 8000f9c:	00000000 	.word	0x00000000

08000fa0 <VectorE0>:
OSAL_IRQ_HANDLER(VectorE0) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8000fa0:	4b1a      	ldr	r3, [pc, #104]	; (800100c <VectorE0+0x6c>)
OSAL_IRQ_HANDLER(VectorE0) {
 8000fa2:	b510      	push	{r4, lr}
  pr = EXTI->PR;
 8000fa4:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
 8000fa6:	681a      	ldr	r2, [r3, #0]
 8000fa8:	4014      	ands	r4, r2
 8000faa:	f404 427c 	and.w	r2, r4, #64512	; 0xfc00
                     (1U << 14) | (1U << 15));
  EXTI->PR = pr;
 8000fae:	615a      	str	r2, [r3, #20]

  exti_serve_irq(pr, 10);
 8000fb0:	0562      	lsls	r2, r4, #21
 8000fb2:	d504      	bpl.n	8000fbe <VectorE0+0x1e>
 8000fb4:	4a16      	ldr	r2, [pc, #88]	; (8001010 <VectorE0+0x70>)
 8000fb6:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8000fb8:	b10b      	cbz	r3, 8000fbe <VectorE0+0x1e>
 8000fba:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8000fbc:	4798      	blx	r3
  exti_serve_irq(pr, 11);
 8000fbe:	0523      	lsls	r3, r4, #20
 8000fc0:	d504      	bpl.n	8000fcc <VectorE0+0x2c>
 8000fc2:	4a13      	ldr	r2, [pc, #76]	; (8001010 <VectorE0+0x70>)
 8000fc4:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8000fc6:	b10b      	cbz	r3, 8000fcc <VectorE0+0x2c>
 8000fc8:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
 8000fca:	4798      	blx	r3
  exti_serve_irq(pr, 12);
 8000fcc:	04e0      	lsls	r0, r4, #19
 8000fce:	d504      	bpl.n	8000fda <VectorE0+0x3a>
 8000fd0:	4a0f      	ldr	r2, [pc, #60]	; (8001010 <VectorE0+0x70>)
 8000fd2:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8000fd4:	b10b      	cbz	r3, 8000fda <VectorE0+0x3a>
 8000fd6:	6e50      	ldr	r0, [r2, #100]	; 0x64
 8000fd8:	4798      	blx	r3
  exti_serve_irq(pr, 13);
 8000fda:	04a1      	lsls	r1, r4, #18
 8000fdc:	d504      	bpl.n	8000fe8 <VectorE0+0x48>
 8000fde:	4a0c      	ldr	r2, [pc, #48]	; (8001010 <VectorE0+0x70>)
 8000fe0:	6e93      	ldr	r3, [r2, #104]	; 0x68
 8000fe2:	b10b      	cbz	r3, 8000fe8 <VectorE0+0x48>
 8000fe4:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8000fe6:	4798      	blx	r3
  exti_serve_irq(pr, 14);
 8000fe8:	0462      	lsls	r2, r4, #17
 8000fea:	d504      	bpl.n	8000ff6 <VectorE0+0x56>
 8000fec:	4a08      	ldr	r2, [pc, #32]	; (8001010 <VectorE0+0x70>)
 8000fee:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8000ff0:	b10b      	cbz	r3, 8000ff6 <VectorE0+0x56>
 8000ff2:	6f50      	ldr	r0, [r2, #116]	; 0x74
 8000ff4:	4798      	blx	r3
  exti_serve_irq(pr, 15);
 8000ff6:	0423      	lsls	r3, r4, #16
 8000ff8:	d504      	bpl.n	8001004 <VectorE0+0x64>
 8000ffa:	4a05      	ldr	r2, [pc, #20]	; (8001010 <VectorE0+0x70>)
 8000ffc:	6f93      	ldr	r3, [r2, #120]	; 0x78
 8000ffe:	b10b      	cbz	r3, 8001004 <VectorE0+0x64>
 8001000:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
 8001002:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001004:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001008:	f000 bf5a 	b.w	8001ec0 <_port_irq_epilogue>
 800100c:	40013c00 	.word	0x40013c00
 8001010:	2000088c 	.word	0x2000088c
	...

08001020 <Vector9C>:
  pr = EXTI->PR;
 8001020:	4b17      	ldr	r3, [pc, #92]	; (8001080 <Vector9C+0x60>)
OSAL_IRQ_HANDLER(Vector9C) {
 8001022:	b510      	push	{r4, lr}
  pr = EXTI->PR;
 8001024:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
 8001026:	681a      	ldr	r2, [r3, #0]
 8001028:	4014      	ands	r4, r2
 800102a:	f404 7278 	and.w	r2, r4, #992	; 0x3e0
  EXTI->PR = pr;
 800102e:	615a      	str	r2, [r3, #20]
  exti_serve_irq(pr, 5);
 8001030:	06a3      	lsls	r3, r4, #26
 8001032:	d504      	bpl.n	800103e <Vector9C+0x1e>
 8001034:	4a13      	ldr	r2, [pc, #76]	; (8001084 <Vector9C+0x64>)
 8001036:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8001038:	b10b      	cbz	r3, 800103e <Vector9C+0x1e>
 800103a:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 800103c:	4798      	blx	r3
  exti_serve_irq(pr, 6);
 800103e:	0660      	lsls	r0, r4, #25
 8001040:	d504      	bpl.n	800104c <Vector9C+0x2c>
 8001042:	4a10      	ldr	r2, [pc, #64]	; (8001084 <Vector9C+0x64>)
 8001044:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001046:	b10b      	cbz	r3, 800104c <Vector9C+0x2c>
 8001048:	6b50      	ldr	r0, [r2, #52]	; 0x34
 800104a:	4798      	blx	r3
  exti_serve_irq(pr, 7);
 800104c:	0621      	lsls	r1, r4, #24
 800104e:	d504      	bpl.n	800105a <Vector9C+0x3a>
 8001050:	4a0c      	ldr	r2, [pc, #48]	; (8001084 <Vector9C+0x64>)
 8001052:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8001054:	b10b      	cbz	r3, 800105a <Vector9C+0x3a>
 8001056:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 8001058:	4798      	blx	r3
  exti_serve_irq(pr, 8);
 800105a:	05e2      	lsls	r2, r4, #23
 800105c:	d504      	bpl.n	8001068 <Vector9C+0x48>
 800105e:	4a09      	ldr	r2, [pc, #36]	; (8001084 <Vector9C+0x64>)
 8001060:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8001062:	b10b      	cbz	r3, 8001068 <Vector9C+0x48>
 8001064:	6c50      	ldr	r0, [r2, #68]	; 0x44
 8001066:	4798      	blx	r3
  exti_serve_irq(pr, 9);
 8001068:	05a3      	lsls	r3, r4, #22
 800106a:	d504      	bpl.n	8001076 <Vector9C+0x56>
 800106c:	4a05      	ldr	r2, [pc, #20]	; (8001084 <Vector9C+0x64>)
 800106e:	6c93      	ldr	r3, [r2, #72]	; 0x48
 8001070:	b10b      	cbz	r3, 8001076 <Vector9C+0x56>
 8001072:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
 8001074:	4798      	blx	r3
}
 8001076:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800107a:	f000 bf21 	b.w	8001ec0 <_port_irq_epilogue>
 800107e:	bf00      	nop
 8001080:	40013c00 	.word	0x40013c00
 8001084:	2000088c 	.word	0x2000088c
	...

08001090 <Vector68>:
  pr = EXTI->PR;
 8001090:	4a08      	ldr	r2, [pc, #32]	; (80010b4 <Vector68+0x24>)
OSAL_IRQ_HANDLER(Vector68) {
 8001092:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 8001094:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 4);
 8001096:	6811      	ldr	r1, [r2, #0]
 8001098:	400b      	ands	r3, r1
 800109a:	f003 0310 	and.w	r3, r3, #16
  EXTI->PR = pr;
 800109e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 4);
 80010a0:	b123      	cbz	r3, 80010ac <Vector68+0x1c>
 80010a2:	4a05      	ldr	r2, [pc, #20]	; (80010b8 <Vector68+0x28>)
 80010a4:	6a13      	ldr	r3, [r2, #32]
 80010a6:	b10b      	cbz	r3, 80010ac <Vector68+0x1c>
 80010a8:	6a50      	ldr	r0, [r2, #36]	; 0x24
 80010aa:	4798      	blx	r3
}
 80010ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 80010b0:	f000 bf06 	b.w	8001ec0 <_port_irq_epilogue>
 80010b4:	40013c00 	.word	0x40013c00
 80010b8:	2000088c 	.word	0x2000088c
 80010bc:	00000000 	.word	0x00000000

080010c0 <Vector64>:
  pr = EXTI->PR;
 80010c0:	4a08      	ldr	r2, [pc, #32]	; (80010e4 <Vector64+0x24>)
OSAL_IRQ_HANDLER(Vector64) {
 80010c2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 80010c4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 3);
 80010c6:	6811      	ldr	r1, [r2, #0]
 80010c8:	400b      	ands	r3, r1
 80010ca:	f003 0308 	and.w	r3, r3, #8
  EXTI->PR = pr;
 80010ce:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 3);
 80010d0:	b123      	cbz	r3, 80010dc <Vector64+0x1c>
 80010d2:	4a05      	ldr	r2, [pc, #20]	; (80010e8 <Vector64+0x28>)
 80010d4:	6993      	ldr	r3, [r2, #24]
 80010d6:	b10b      	cbz	r3, 80010dc <Vector64+0x1c>
 80010d8:	69d0      	ldr	r0, [r2, #28]
 80010da:	4798      	blx	r3
}
 80010dc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 80010e0:	f000 beee 	b.w	8001ec0 <_port_irq_epilogue>
 80010e4:	40013c00 	.word	0x40013c00
 80010e8:	2000088c 	.word	0x2000088c
 80010ec:	00000000 	.word	0x00000000

080010f0 <Vector60>:
  pr = EXTI->PR;
 80010f0:	4a08      	ldr	r2, [pc, #32]	; (8001114 <Vector60+0x24>)
OSAL_IRQ_HANDLER(Vector60) {
 80010f2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 80010f4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 2);
 80010f6:	6811      	ldr	r1, [r2, #0]
 80010f8:	400b      	ands	r3, r1
 80010fa:	f003 0304 	and.w	r3, r3, #4
  EXTI->PR = pr;
 80010fe:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 2);
 8001100:	b123      	cbz	r3, 800110c <Vector60+0x1c>
 8001102:	4a05      	ldr	r2, [pc, #20]	; (8001118 <Vector60+0x28>)
 8001104:	6913      	ldr	r3, [r2, #16]
 8001106:	b10b      	cbz	r3, 800110c <Vector60+0x1c>
 8001108:	6950      	ldr	r0, [r2, #20]
 800110a:	4798      	blx	r3
}
 800110c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001110:	f000 bed6 	b.w	8001ec0 <_port_irq_epilogue>
 8001114:	40013c00 	.word	0x40013c00
 8001118:	2000088c 	.word	0x2000088c
 800111c:	00000000 	.word	0x00000000

08001120 <Vector5C>:
  pr = EXTI->PR;
 8001120:	4a08      	ldr	r2, [pc, #32]	; (8001144 <Vector5C+0x24>)
OSAL_IRQ_HANDLER(Vector5C) {
 8001122:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 8001124:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 1);
 8001126:	6811      	ldr	r1, [r2, #0]
 8001128:	400b      	ands	r3, r1
 800112a:	f003 0302 	and.w	r3, r3, #2
  EXTI->PR = pr;
 800112e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 1);
 8001130:	b123      	cbz	r3, 800113c <Vector5C+0x1c>
 8001132:	4a05      	ldr	r2, [pc, #20]	; (8001148 <Vector5C+0x28>)
 8001134:	6893      	ldr	r3, [r2, #8]
 8001136:	b10b      	cbz	r3, 800113c <Vector5C+0x1c>
 8001138:	68d0      	ldr	r0, [r2, #12]
 800113a:	4798      	blx	r3
}
 800113c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001140:	f000 bebe 	b.w	8001ec0 <_port_irq_epilogue>
 8001144:	40013c00 	.word	0x40013c00
 8001148:	2000088c 	.word	0x2000088c
 800114c:	00000000 	.word	0x00000000

08001150 <Vector58>:
  pr = EXTI->PR;
 8001150:	4a08      	ldr	r2, [pc, #32]	; (8001174 <Vector58+0x24>)
OSAL_IRQ_HANDLER(Vector58) {
 8001152:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 8001154:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 0);
 8001156:	6811      	ldr	r1, [r2, #0]
 8001158:	400b      	ands	r3, r1
 800115a:	f003 0301 	and.w	r3, r3, #1
  EXTI->PR = pr;
 800115e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 0);
 8001160:	b123      	cbz	r3, 800116c <Vector58+0x1c>
 8001162:	4a05      	ldr	r2, [pc, #20]	; (8001178 <Vector58+0x28>)
 8001164:	6813      	ldr	r3, [r2, #0]
 8001166:	b10b      	cbz	r3, 800116c <Vector58+0x1c>
 8001168:	6850      	ldr	r0, [r2, #4]
 800116a:	4798      	blx	r3
}
 800116c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001170:	f000 bea6 	b.w	8001ec0 <_port_irq_epilogue>
 8001174:	40013c00 	.word	0x40013c00
 8001178:	2000088c 	.word	0x2000088c
 800117c:	00000000 	.word	0x00000000

08001180 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001180:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001182:	4f13      	ldr	r7, [pc, #76]	; (80011d0 <__init_ram_areas+0x50>)
 8001184:	4d13      	ldr	r5, [pc, #76]	; (80011d4 <__init_ram_areas+0x54>)
 8001186:	4c14      	ldr	r4, [pc, #80]	; (80011d8 <__init_ram_areas+0x58>)
 8001188:	4b14      	ldr	r3, [pc, #80]	; (80011dc <__init_ram_areas+0x5c>)
 800118a:	4915      	ldr	r1, [pc, #84]	; (80011e0 <__init_ram_areas+0x60>)
 800118c:	f107 0e70 	add.w	lr, r7, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001190:	2600      	movs	r6, #0
    while (p < rap->clear_area) {
 8001192:	429c      	cmp	r4, r3
 8001194:	d911      	bls.n	80011ba <__init_ram_areas+0x3a>
 8001196:	3904      	subs	r1, #4
 8001198:	461a      	mov	r2, r3
      *p = *tp;
 800119a:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800119e:	f842 0b04 	str.w	r0, [r2], #4
    while (p < rap->clear_area) {
 80011a2:	4294      	cmp	r4, r2
 80011a4:	d8f9      	bhi.n	800119a <__init_ram_areas+0x1a>
 80011a6:	43da      	mvns	r2, r3
 80011a8:	4414      	add	r4, r2
 80011aa:	f024 0403 	bic.w	r4, r4, #3
 80011ae:	3404      	adds	r4, #4
 80011b0:	4423      	add	r3, r4
    while (p < rap->no_init_area) {
 80011b2:	429d      	cmp	r5, r3
 80011b4:	d903      	bls.n	80011be <__init_ram_areas+0x3e>
      *p = 0;
 80011b6:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->no_init_area) {
 80011ba:	429d      	cmp	r5, r3
 80011bc:	d8fb      	bhi.n	80011b6 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80011be:	4577      	cmp	r7, lr
 80011c0:	d004      	beq.n	80011cc <__init_ram_areas+0x4c>
 80011c2:	f107 0110 	add.w	r1, r7, #16
 80011c6:	c93a      	ldmia	r1, {r1, r3, r4, r5}
 80011c8:	3710      	adds	r7, #16
 80011ca:	e7e2      	b.n	8001192 <__init_ram_areas+0x12>
 80011cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80011ce:	bf00      	nop
 80011d0:	08002a74 	.word	0x08002a74
 80011d4:	20001140 	.word	0x20001140
 80011d8:	20001140 	.word	0x20001140
 80011dc:	20001140 	.word	0x20001140
 80011e0:	08002cf8 	.word	0x08002cf8
	...

080011f0 <__default_exit>:
void __default_exit(void) {
 80011f0:	e7fe      	b.n	80011f0 <__default_exit>
 80011f2:	bf00      	nop
	...

08001200 <__late_init>:
 8001200:	4770      	bx	lr
 8001202:	bf00      	nop
	...

08001210 <__core_init>:
void __core_init(void) {
 8001210:	4770      	bx	lr
 8001212:	bf00      	nop
	...

08001220 <Thread1>:
/*=============================================================================*/

/*=============================================================================*/
/*----------------------------  BLINK  -------------------------------------*/
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8001220:	b508      	push	{r3, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8001222:	4b07      	ldr	r3, [pc, #28]	; (8001240 <Thread1+0x20>)
 8001224:	4a07      	ldr	r2, [pc, #28]	; (8001244 <Thread1+0x24>)
 8001226:	699b      	ldr	r3, [r3, #24]
  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    systime_t time = (flag_adc == 1) ? 300 : 1000;
    palToggleLine(LED2);
 8001228:	4c07      	ldr	r4, [pc, #28]	; (8001248 <Thread1+0x28>)
 800122a:	619a      	str	r2, [r3, #24]
 800122c:	6963      	ldr	r3, [r4, #20]
 800122e:	f083 0320 	eor.w	r3, r3, #32
 8001232:	6163      	str	r3, [r4, #20]
    chThdSleepMilliseconds(time);
 8001234:	f640 30b8 	movw	r0, #3000	; 0xbb8
 8001238:	f000 ff8a 	bl	8002150 <chThdSleep>
 800123c:	e7f6      	b.n	800122c <Thread1+0xc>
 800123e:	bf00      	nop
 8001240:	200010c8 	.word	0x200010c8
 8001244:	08002af4 	.word	0x08002af4
 8001248:	40020400 	.word	0x40020400
 800124c:	00000000 	.word	0x00000000

08001250 <Thread4>:
 8001250:	4b6d      	ldr	r3, [pc, #436]	; (8001408 <Thread4+0x1b8>)
 8001252:	4a6e      	ldr	r2, [pc, #440]	; (800140c <Thread4+0x1bc>)
 8001254:	699b      	ldr	r3, [r3, #24]
static THD_WORKING_AREA(waThread4, 128);
static THD_FUNCTION(Thread4, arg) {
  (void)arg;
  chRegSetThreadName("PWM");
  //see alternate function mapping on datasheet stm32f407
  palSetGroupMode(GPIOE, PAL_PORT_BIT(9) | PAL_PORT_BIT(11), 0, PAL_MODE_ALTERNATE(1)); //TIM1_CH1 - TIM1_CH2
 8001256:	486e      	ldr	r0, [pc, #440]	; (8001410 <Thread4+0x1c0>)
static THD_FUNCTION(Thread4, arg) {
 8001258:	b580      	push	{r7, lr}
  palSetGroupMode(GPIOE, PAL_PORT_BIT(9) | PAL_PORT_BIT(11), 0, PAL_MODE_ALTERNATE(1)); //TIM1_CH1 - TIM1_CH2
 800125a:	f44f 6120 	mov.w	r1, #2560	; 0xa00
 800125e:	619a      	str	r2, [r3, #24]
 8001260:	2282      	movs	r2, #130	; 0x82
 8001262:	f7ff fc75 	bl	8000b50 <_pal_lld_setgroupmode>
 8001266:	2320      	movs	r3, #32
 8001268:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck((pwmp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
 800126c:	4c69      	ldr	r4, [pc, #420]	; (8001414 <Thread4+0x1c4>)
 800126e:	496a      	ldr	r1, [pc, #424]	; (8001418 <Thread4+0x1c8>)
  if (pwmp->state == PWM_STOP) {
 8001270:	7823      	ldrb	r3, [r4, #0]
  pwmp->period = config->period;
 8001272:	684f      	ldr	r7, [r1, #4]
 8001274:	60a7      	str	r7, [r4, #8]
 8001276:	2b01      	cmp	r3, #1
  pwmp->config = config;
 8001278:	6061      	str	r1, [r4, #4]
 800127a:	f000 809d 	beq.w	80013b8 <Thread4+0x168>
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 800127e:	69a2      	ldr	r2, [r4, #24]
 8001280:	6963      	ldr	r3, [r4, #20]
 8001282:	2000      	movs	r0, #0
 8001284:	6010      	str	r0, [r2, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8001286:	6350      	str	r0, [r2, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8001288:	6390      	str	r0, [r2, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 800128a:	63d0      	str	r0, [r2, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 800128c:	6410      	str	r0, [r2, #64]	; 0x40
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 800128e:	6250      	str	r0, [r2, #36]	; 0x24
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8001290:	68ce      	ldr	r6, [r1, #12]
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8001292:	6808      	ldr	r0, [r1, #0]
 8001294:	fbb3 f3f0 	udiv	r3, r3, r0
 8001298:	1e58      	subs	r0, r3, #1
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 800129a:	f006 030f 	and.w	r3, r6, #15
  pwmp->tim->ARR  = pwmp->period - 1;
 800129e:	1e7d      	subs	r5, r7, #1
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 80012a0:	2b01      	cmp	r3, #1
  pwmp->tim->CR2  = pwmp->config->cr2;
 80012a2:	6acf      	ldr	r7, [r1, #44]	; 0x2c
  pwmp->tim->PSC  = psc;
 80012a4:	6290      	str	r0, [r2, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 80012a6:	62d5      	str	r5, [r2, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 80012a8:	6057      	str	r7, [r2, #4]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 80012aa:	d003      	beq.n	80012b4 <Thread4+0x64>
  ccer = 0;
 80012ac:	2b02      	cmp	r3, #2
 80012ae:	bf0c      	ite	eq
 80012b0:	2303      	moveq	r3, #3
 80012b2:	2300      	movne	r3, #0
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 80012b4:	694d      	ldr	r5, [r1, #20]
 80012b6:	f005 000f 	and.w	r0, r5, #15
 80012ba:	2801      	cmp	r0, #1
 80012bc:	d003      	beq.n	80012c6 <Thread4+0x76>
 80012be:	2802      	cmp	r0, #2
 80012c0:	d103      	bne.n	80012ca <Thread4+0x7a>
    ccer |= STM32_TIM_CCER_CC2P;
 80012c2:	f043 0320 	orr.w	r3, r3, #32
    ccer |= STM32_TIM_CCER_CC2E;
 80012c6:	f043 0310 	orr.w	r3, r3, #16
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 80012ca:	69c8      	ldr	r0, [r1, #28]
 80012cc:	f000 070f 	and.w	r7, r0, #15
 80012d0:	2f01      	cmp	r7, #1
 80012d2:	d003      	beq.n	80012dc <Thread4+0x8c>
 80012d4:	2f02      	cmp	r7, #2
 80012d6:	d103      	bne.n	80012e0 <Thread4+0x90>
    ccer |= STM32_TIM_CCER_CC3P;
 80012d8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    ccer |= STM32_TIM_CCER_CC3E;
 80012dc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 80012e0:	6a4f      	ldr	r7, [r1, #36]	; 0x24
 80012e2:	f007 070f 	and.w	r7, r7, #15
 80012e6:	2f01      	cmp	r7, #1
 80012e8:	d003      	beq.n	80012f2 <Thread4+0xa2>
 80012ea:	2f02      	cmp	r7, #2
 80012ec:	d103      	bne.n	80012f6 <Thread4+0xa6>
    ccer |= STM32_TIM_CCER_CC4P;
 80012ee:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    ccer |= STM32_TIM_CCER_CC4E;
 80012f2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    switch (pwmp->config->channels[0].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 80012f6:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
 80012fa:	2e10      	cmp	r6, #16
 80012fc:	d003      	beq.n	8001306 <Thread4+0xb6>
 80012fe:	2e20      	cmp	r6, #32
 8001300:	d103      	bne.n	800130a <Thread4+0xba>
      ccer |= STM32_TIM_CCER_CC1NP;
 8001302:	f043 0308 	orr.w	r3, r3, #8
      ccer |= STM32_TIM_CCER_CC1NE;
 8001306:	f043 0304 	orr.w	r3, r3, #4
    switch (pwmp->config->channels[1].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 800130a:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
 800130e:	2d10      	cmp	r5, #16
 8001310:	d003      	beq.n	800131a <Thread4+0xca>
 8001312:	2d20      	cmp	r5, #32
 8001314:	d103      	bne.n	800131e <Thread4+0xce>
      ccer |= STM32_TIM_CCER_CC2NP;
 8001316:	f043 0380 	orr.w	r3, r3, #128	; 0x80
      ccer |= STM32_TIM_CCER_CC2NE;
 800131a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    switch (pwmp->config->channels[2].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 800131e:	f000 00f0 	and.w	r0, r0, #240	; 0xf0
 8001322:	2810      	cmp	r0, #16
 8001324:	d003      	beq.n	800132e <Thread4+0xde>
 8001326:	2820      	cmp	r0, #32
 8001328:	d103      	bne.n	8001332 <Thread4+0xe2>
      ccer |= STM32_TIM_CCER_CC3NP;
 800132a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
      ccer |= STM32_TIM_CCER_CC3NE;
 800132e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8001332:	6b48      	ldr	r0, [r1, #52]	; 0x34
  pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
 8001334:	6b09      	ldr	r1, [r1, #48]	; 0x30
  pwmp->tim->CCER  = ccer;
 8001336:	6213      	str	r3, [r2, #32]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8001338:	2500      	movs	r5, #0
  pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
 800133a:	f441 4300 	orr.w	r3, r1, #32768	; 0x8000
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 800133e:	2701      	movs	r7, #1
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8001340:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8001344:	2685      	movs	r6, #133	; 0x85
  pwm_lld_start(pwmp);
  pwmp->enabled = 0;
  pwmp->state = PWM_READY;
 8001346:	2102      	movs	r1, #2
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8001348:	6157      	str	r7, [r2, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 800134a:	6115      	str	r5, [r2, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 800134c:	60d0      	str	r0, [r2, #12]
  pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
 800134e:	6453      	str	r3, [r2, #68]	; 0x44
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8001350:	6016      	str	r6, [r2, #0]
  pwmp->enabled = 0;
 8001352:	60e5      	str	r5, [r4, #12]
  pwmp->state = PWM_READY;
 8001354:	7021      	strb	r1, [r4, #0]
 8001356:	f385 8811 	msr	BASEPRI, r5
 800135a:	4f30      	ldr	r7, [pc, #192]	; (800141c <Thread4+0x1cc>)
 800135c:	4e30      	ldr	r6, [pc, #192]	; (8001420 <Thread4+0x1d0>)
  // pwmStop(&PWMD1);
  // /* Changes PWM period, implicitly.  */
  // pwmChangePeriod(&PWMD1, 2000);
  while (true) {
    // PWMD1.period = avg_adc1ch1*30;
    pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, avg_adc1ch0*2));
 800135e:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 8001430 <Thread4+0x1e0>
 8001362:	f04f 0820 	mov.w	r8, #32
 8001366:	68a3      	ldr	r3, [r4, #8]
 8001368:	8839      	ldrh	r1, [r7, #0]
 800136a:	005b      	lsls	r3, r3, #1
 800136c:	fb01 f103 	mul.w	r1, r1, r3
 8001370:	fba9 3101 	umull	r3, r1, r9, r1
 8001374:	0b49      	lsrs	r1, r1, #13
 8001376:	f388 8811 	msr	BASEPRI, r8

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");

  pwmEnableChannelI(pwmp, channel, width);
 800137a:	68e3      	ldr	r3, [r4, #12]
  pwmp->tim->CCR[channel] = width;
 800137c:	69a2      	ldr	r2, [r4, #24]
 800137e:	f043 0301 	orr.w	r3, r3, #1
 8001382:	60e3      	str	r3, [r4, #12]
 8001384:	6351      	str	r1, [r2, #52]	; 0x34
 8001386:	f385 8811 	msr	BASEPRI, r5
    pwmEnableChannel(&PWMD1, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, avg_adc1ch1*2));
 800138a:	68a2      	ldr	r2, [r4, #8]
 800138c:	8833      	ldrh	r3, [r6, #0]
 800138e:	0052      	lsls	r2, r2, #1
 8001390:	fb03 f302 	mul.w	r3, r3, r2
 8001394:	fba9 2303 	umull	r2, r3, r9, r3
 8001398:	0b5b      	lsrs	r3, r3, #13
 800139a:	f388 8811 	msr	BASEPRI, r8
 800139e:	68e2      	ldr	r2, [r4, #12]
 80013a0:	69a1      	ldr	r1, [r4, #24]
 80013a2:	f042 0202 	orr.w	r2, r2, #2
 80013a6:	60e2      	str	r2, [r4, #12]
 80013a8:	638b      	str	r3, [r1, #56]	; 0x38
 80013aa:	f385 8811 	msr	BASEPRI, r5
    chThdSleepMilliseconds(100);  
 80013ae:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80013b2:	f000 fecd 	bl	8002150 <chThdSleep>
 80013b6:	e7d6      	b.n	8001366 <Thread4+0x116>
      rccEnableTIM1(true);
 80013b8:	481a      	ldr	r0, [pc, #104]	; (8001424 <Thread4+0x1d4>)
      pwmp->clock = STM32_TIMCLK2;
 80013ba:	4b1b      	ldr	r3, [pc, #108]	; (8001428 <Thread4+0x1d8>)
      rccEnableTIM1(true);
 80013bc:	6c46      	ldr	r6, [r0, #68]	; 0x44
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 80013be:	69a2      	ldr	r2, [r4, #24]
      pwmp->clock = STM32_TIMCLK2;
 80013c0:	6163      	str	r3, [r4, #20]
      rccEnableTIM1(true);
 80013c2:	f046 0601 	orr.w	r6, r6, #1
 80013c6:	6446      	str	r6, [r0, #68]	; 0x44
 80013c8:	6e46      	ldr	r6, [r0, #100]	; 0x64

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80013ca:	4d18      	ldr	r5, [pc, #96]	; (800142c <Thread4+0x1dc>)
 80013cc:	f046 0601 	orr.w	r6, r6, #1
 80013d0:	6646      	str	r6, [r0, #100]	; 0x64
      rccResetTIM1();
 80013d2:	6a46      	ldr	r6, [r0, #36]	; 0x24
 80013d4:	f046 0601 	orr.w	r6, r6, #1
 80013d8:	6246      	str	r6, [r0, #36]	; 0x24
 80013da:	2600      	movs	r6, #0
 80013dc:	6246      	str	r6, [r0, #36]	; 0x24
 80013de:	2070      	movs	r0, #112	; 0x70
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80013e0:	f04f 7600 	mov.w	r6, #33554432	; 0x2000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80013e4:	f885 0319 	strb.w	r0, [r5, #793]	; 0x319
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80013e8:	f8c5 6180 	str.w	r6, [r5, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80013ec:	602e      	str	r6, [r5, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80013ee:	f885 031b 	strb.w	r0, [r5, #795]	; 0x31b
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80013f2:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 80013f6:	f646 0068 	movw	r0, #26728	; 0x6868
 80013fa:	f8c5 6180 	str.w	r6, [r5, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80013fe:	602e      	str	r6, [r5, #0]
 8001400:	6190      	str	r0, [r2, #24]
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 8001402:	61d0      	str	r0, [r2, #28]
 8001404:	e744      	b.n	8001290 <Thread4+0x40>
 8001406:	bf00      	nop
 8001408:	200010c8 	.word	0x200010c8
 800140c:	08002b5c 	.word	0x08002b5c
 8001410:	40021000 	.word	0x40021000
 8001414:	20000838 	.word	0x20000838
 8001418:	20000800 	.word	0x20000800
 800141c:	2000090c 	.word	0x2000090c
 8001420:	2000090e 	.word	0x2000090e
 8001424:	40023800 	.word	0x40023800
 8001428:	0a037a00 	.word	0x0a037a00
 800142c:	e000e100 	.word	0xe000e100
 8001430:	d1b71759 	.word	0xd1b71759
	...

08001440 <Thread3>:
static THD_FUNCTION(Thread3, arg) {
 8001440:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
 8001444:	4b5e      	ldr	r3, [pc, #376]	; (80015c0 <Thread3+0x180>)
 8001446:	4a5f      	ldr	r2, [pc, #380]	; (80015c4 <Thread3+0x184>)
 8001448:	699b      	ldr	r3, [r3, #24]
  palSetGroupMode(GPIOA, PAL_PORT_BIT(0) | PAL_PORT_BIT(1), 0, PAL_MODE_INPUT_ANALOG); //PA0 - PA1
 800144a:	485f      	ldr	r0, [pc, #380]	; (80015c8 <Thread3+0x188>)
 800144c:	619a      	str	r2, [r3, #24]
 800144e:	2203      	movs	r2, #3
 8001450:	4611      	mov	r1, r2
 8001452:	f7ff fb7d 	bl	8000b50 <_pal_lld_setgroupmode>
 8001456:	2320      	movs	r3, #32
 8001458:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
 800145c:	4c5b      	ldr	r4, [pc, #364]	; (80015cc <Thread3+0x18c>)
  if (adcp->state == ADC_STOP) {
 800145e:	7823      	ldrb	r3, [r4, #0]
 8001460:	2200      	movs	r2, #0
 8001462:	2b01      	cmp	r3, #1
 8001464:	6062      	str	r2, [r4, #4]
 8001466:	d040      	beq.n	80014ea <Thread3+0xaa>
  adc_lld_start(adcp);
  adcp->state = ADC_READY;
 8001468:	2302      	movs	r3, #2
 800146a:	7023      	strb	r3, [r4, #0]
 800146c:	2500      	movs	r5, #0
 800146e:	f385 8811 	msr	BASEPRI, r5
 *          temperature sensor and internal reference voltage.
 * @note    This is an STM32-only functionality.
 */
void adcSTM32EnableTSVREFE(void) {

  ADC->CCR |= ADC_CCR_TSVREFE;
 8001472:	4a57      	ldr	r2, [pc, #348]	; (80015d0 <Thread3+0x190>)
 8001474:	6853      	ldr	r3, [r2, #4]
 8001476:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800147a:	6053      	str	r3, [r2, #4]
 800147c:	2320      	movs	r3, #32
 800147e:	f383 8811 	msr	BASEPRI, r3
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
 8001482:	2204      	movs	r2, #4
  adcp->grpp     = grpp;
  adcp->state    = ADC_ACTIVE;
 8001484:	2303      	movs	r3, #3
  adcp->samples  = samples;
 8001486:	4f53      	ldr	r7, [pc, #332]	; (80015d4 <Thread3+0x194>)
  adcp->grpp     = grpp;
 8001488:	4e53      	ldr	r6, [pc, #332]	; (80015d8 <Thread3+0x198>)
  adcp->depth    = depth;
 800148a:	60e2      	str	r2, [r4, #12]
  adcp->state    = ADC_ACTIVE;
 800148c:	7023      	strb	r3, [r4, #0]
  adcp->samples  = samples;
 800148e:	60a7      	str	r7, [r4, #8]
  adcp->grpp     = grpp;
 8001490:	6126      	str	r6, [r4, #16]
  adc_lld_start_conversion(adcp);
 8001492:	f001 f83d 	bl	8002510 <adc_lld_start_conversion.constprop.25>
 8001496:	f385 8811 	msr	BASEPRI, r5
 800149a:	f8df b158 	ldr.w	fp, [pc, #344]	; 80015f4 <Thread3+0x1b4>
 800149e:	f8df a158 	ldr.w	sl, [pc, #344]	; 80015f8 <Thread3+0x1b8>
    chprintf((BaseSequentialStream *)&SD2,"ADC1_CH0 : %d \r\n\r\n", avg_adc1ch0);
 80014a2:	f8df 9158 	ldr.w	r9, [pc, #344]	; 80015fc <Thread3+0x1bc>
 80014a6:	4d4d      	ldr	r5, [pc, #308]	; (80015dc <Thread3+0x19c>)
    chprintf((BaseSequentialStream *)&SD2,"ADC1_CH1 : %d \r\n\r\n", avg_adc1ch1);
 80014a8:	f8df 8154 	ldr.w	r8, [pc, #340]	; 8001600 <Thread3+0x1c0>
 80014ac:	2320      	movs	r3, #32
 80014ae:	f383 8811 	msr	BASEPRI, r3
  adcp->depth    = depth;
 80014b2:	2204      	movs	r2, #4
  adcp->state    = ADC_ACTIVE;
 80014b4:	2303      	movs	r3, #3
 80014b6:	7023      	strb	r3, [r4, #0]
  adcp->samples  = samples;
 80014b8:	60a7      	str	r7, [r4, #8]
  adcp->grpp     = grpp;
 80014ba:	6126      	str	r6, [r4, #16]
  adcp->depth    = depth;
 80014bc:	60e2      	str	r2, [r4, #12]
  adc_lld_start_conversion(adcp);
 80014be:	f001 f827 	bl	8002510 <adc_lld_start_conversion.constprop.25>
 80014c2:	2300      	movs	r3, #0
 80014c4:	f383 8811 	msr	BASEPRI, r3
    chprintf((BaseSequentialStream *)&SD2,"ADC1_CH0 : %d \r\n\r\n", avg_adc1ch0);
 80014c8:	f8bb 2000 	ldrh.w	r2, [fp]
 80014cc:	4649      	mov	r1, r9
 80014ce:	4628      	mov	r0, r5
 80014d0:	f001 f8ee 	bl	80026b0 <chprintf.constprop.0>
    chprintf((BaseSequentialStream *)&SD2,"ADC1_CH1 : %d \r\n\r\n", avg_adc1ch1);
 80014d4:	f8ba 2000 	ldrh.w	r2, [sl]
 80014d8:	4641      	mov	r1, r8
 80014da:	4628      	mov	r0, r5
 80014dc:	f001 f8e8 	bl	80026b0 <chprintf.constprop.0>
    chThdSleepMilliseconds(100);
 80014e0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80014e4:	f000 fe34 	bl	8002150 <chThdSleep>
 80014e8:	e7e0      	b.n	80014ac <Thread3+0x6c>
      b = dmaStreamAllocate(adcp->dmastp,
 80014ea:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
                       void *param) {

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 80014ec:	4d3c      	ldr	r5, [pc, #240]	; (80015e0 <Thread3+0x1a0>)
 80014ee:	7a48      	ldrb	r0, [r1, #9]
 80014f0:	682e      	ldr	r6, [r5, #0]
 80014f2:	4083      	lsls	r3, r0
 80014f4:	4233      	tst	r3, r6
 80014f6:	d148      	bne.n	800158a <Thread3+0x14a>
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 80014f8:	4a3a      	ldr	r2, [pc, #232]	; (80015e4 <Thread3+0x1a4>)
 80014fa:	4f3b      	ldr	r7, [pc, #236]	; (80015e8 <Thread3+0x1a8>)
 80014fc:	f842 7030 	str.w	r7, [r2, r0, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
 8001500:	4333      	orrs	r3, r6
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8001502:	eb02 02c0 	add.w	r2, r2, r0, lsl #3

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 8001506:	f013 0fff 	tst.w	r3, #255	; 0xff
  dma_streams_mask |= (1U << dmastp->selfindex);
 800150a:	602b      	str	r3, [r5, #0]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800150c:	6054      	str	r4, [r2, #4]
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 800150e:	d008      	beq.n	8001522 <Thread3+0xe2>
    rccEnableDMA1(true);
 8001510:	4a36      	ldr	r2, [pc, #216]	; (80015ec <Thread3+0x1ac>)
 8001512:	6b10      	ldr	r0, [r2, #48]	; 0x30
 8001514:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
 8001518:	6310      	str	r0, [r2, #48]	; 0x30
 800151a:	6d10      	ldr	r0, [r2, #80]	; 0x50
 800151c:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
 8001520:	6510      	str	r0, [r2, #80]	; 0x50
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
 8001522:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
 8001526:	d008      	beq.n	800153a <Thread3+0xfa>
    rccEnableDMA2(true);
 8001528:	4b30      	ldr	r3, [pc, #192]	; (80015ec <Thread3+0x1ac>)
 800152a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800152c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8001530:	631a      	str	r2, [r3, #48]	; 0x30
 8001532:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8001534:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8001538:	651a      	str	r2, [r3, #80]	; 0x50
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800153a:	680a      	ldr	r2, [r1, #0]
 800153c:	6813      	ldr	r3, [r2, #0]
 800153e:	f023 031f 	bic.w	r3, r3, #31
 8001542:	6013      	str	r3, [r2, #0]
 8001544:	6813      	ldr	r3, [r2, #0]
 8001546:	f013 0301 	ands.w	r3, r3, #1
 800154a:	d1fb      	bne.n	8001544 <Thread3+0x104>
 800154c:	7a0d      	ldrb	r5, [r1, #8]
 800154e:	684e      	ldr	r6, [r1, #4]
 8001550:	203d      	movs	r0, #61	; 0x3d
 8001552:	40a8      	lsls	r0, r5
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8001554:	2521      	movs	r5, #33	; 0x21
  dmaStreamDisable(dmastp);
 8001556:	6030      	str	r0, [r6, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8001558:	6013      	str	r3, [r2, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800155a:	6155      	str	r5, [r2, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
    nvicEnableVector(dmastp->vector, priority);
 800155c:	7a89      	ldrb	r1, [r1, #10]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800155e:	094b      	lsrs	r3, r1, #5
 8001560:	009b      	lsls	r3, r3, #2
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001562:	f101 4560 	add.w	r5, r1, #3758096384	; 0xe0000000
 8001566:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 800156a:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 800156e:	f505 4561 	add.w	r5, r5, #57600	; 0xe100
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001572:	f001 011f 	and.w	r1, r1, #31
 8001576:	2001      	movs	r0, #1
 8001578:	fa00 f101 	lsl.w	r1, r0, r1
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800157c:	2660      	movs	r6, #96	; 0x60
 800157e:	f885 6300 	strb.w	r6, [r5, #768]	; 0x300
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001582:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001586:	6019      	str	r1, [r3, #0]
 8001588:	e000      	b.n	800158c <Thread3+0x14c>
 800158a:	680a      	ldr	r2, [r1, #0]
      rccEnableADC1(true);
 800158c:	4b17      	ldr	r3, [pc, #92]	; (80015ec <Thread3+0x1ac>)
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 800158e:	4918      	ldr	r1, [pc, #96]	; (80015f0 <Thread3+0x1b0>)
 8001590:	6091      	str	r1, [r2, #8]
      rccEnableADC1(true);
 8001592:	6c59      	ldr	r1, [r3, #68]	; 0x44
    adcp->adc->CR1 = 0;
 8001594:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 8001596:	480e      	ldr	r0, [pc, #56]	; (80015d0 <Thread3+0x190>)
      rccEnableADC1(true);
 8001598:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800159c:	6459      	str	r1, [r3, #68]	; 0x44
 800159e:	6e59      	ldr	r1, [r3, #100]	; 0x64
 80015a0:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80015a4:	6659      	str	r1, [r3, #100]	; 0x64
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 80015a6:	6843      	ldr	r3, [r0, #4]
 80015a8:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
    adcp->adc->CR1 = 0;
 80015ac:	2100      	movs	r1, #0
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 80015ae:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    adcp->adc->CR2 = ADC_CR2_ADON;
 80015b2:	2501      	movs	r5, #1
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 80015b4:	6043      	str	r3, [r0, #4]
    adcp->adc->CR1 = 0;
 80015b6:	6051      	str	r1, [r2, #4]
    adcp->adc->CR2 = 0;
 80015b8:	6091      	str	r1, [r2, #8]
    adcp->adc->CR2 = ADC_CR2_ADON;
 80015ba:	6095      	str	r5, [r2, #8]
 80015bc:	e754      	b.n	8001468 <Thread3+0x28>
 80015be:	bf00      	nop
 80015c0:	200010c8 	.word	0x200010c8
 80015c4:	08002b28 	.word	0x08002b28
 80015c8:	40020000 	.word	0x40020000
 80015cc:	20001018 	.word	0x20001018
 80015d0:	40012300 	.word	0x40012300
 80015d4:	20000ae8 	.word	0x20000ae8
 80015d8:	08002c20 	.word	0x08002c20
 80015dc:	2000104c 	.word	0x2000104c
 80015e0:	20000ae0 	.word	0x20000ae0
 80015e4:	20000a60 	.word	0x20000a60
 80015e8:	080004a1 	.word	0x080004a1
 80015ec:	40023800 	.word	0x40023800
 80015f0:	4001204c 	.word	0x4001204c
 80015f4:	2000090c 	.word	0x2000090c
 80015f8:	2000090e 	.word	0x2000090e
 80015fc:	08002b34 	.word	0x08002b34
 8001600:	08002b48 	.word	0x08002b48
	...

08001610 <Thread2>:
static THD_FUNCTION(Thread2, arg) {
 8001610:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8001614:	4d4a      	ldr	r5, [pc, #296]	; (8001740 <Thread2+0x130>)
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8001616:	494b      	ldr	r1, [pc, #300]	; (8001744 <Thread2+0x134>)
 8001618:	69aa      	ldr	r2, [r5, #24]
 800161a:	4b4b      	ldr	r3, [pc, #300]	; (8001748 <Thread2+0x138>)
 800161c:	484b      	ldr	r0, [pc, #300]	; (800174c <Thread2+0x13c>)
 800161e:	6190      	str	r0, [r2, #24]
 8001620:	b08b      	sub	sp, #44	; 0x2c
 8001622:	6009      	str	r1, [r1, #0]
 8001624:	601b      	str	r3, [r3, #0]
 8001626:	2020      	movs	r0, #32
 8001628:	f380 8811 	msr	BASEPRI, r0
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 800162c:	ac0a      	add	r4, sp, #40	; 0x28
 800162e:	680a      	ldr	r2, [r1, #0]
 8001630:	f844 2d14 	str.w	r2, [r4, #-20]!
  esp->next     = elp;
  elp->listener = currp;
 8001634:	69aa      	ldr	r2, [r5, #24]
 8001636:	9206      	str	r2, [sp, #24]
  elp->events   = events;
 8001638:	2701      	movs	r7, #1
  elp->flags    = (eventflags_t)0;
 800163a:	2200      	movs	r2, #0
  elp->wflags   = wflags;
 800163c:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  elp->events   = events;
 8001640:	9707      	str	r7, [sp, #28]
  esp->next     = elp;
 8001642:	600c      	str	r4, [r1, #0]
  elp->flags    = (eventflags_t)0;
 8001644:	9208      	str	r2, [sp, #32]
  elp->wflags   = wflags;
 8001646:	9609      	str	r6, [sp, #36]	; 0x24
 8001648:	f382 8811 	msr	BASEPRI, r2
 800164c:	f380 8811 	msr	BASEPRI, r0
  elp->next     = esp->next;
 8001650:	a90a      	add	r1, sp, #40	; 0x28
 8001652:	681c      	ldr	r4, [r3, #0]
 8001654:	f841 4d28 	str.w	r4, [r1, #-40]!
  elp->listener = currp;
 8001658:	69af      	ldr	r7, [r5, #24]
  elp->flags    = (eventflags_t)0;
 800165a:	9203      	str	r2, [sp, #12]
  elp->events   = events;
 800165c:	2402      	movs	r4, #2
  elp->wflags   = wflags;
 800165e:	9604      	str	r6, [sp, #16]
  elp->listener = currp;
 8001660:	9701      	str	r7, [sp, #4]
  elp->events   = events;
 8001662:	9402      	str	r4, [sp, #8]
  esp->next     = elp;
 8001664:	6019      	str	r1, [r3, #0]
 8001666:	f382 8811 	msr	BASEPRI, r2
 800166a:	f380 8811 	msr	BASEPRI, r0
  /* Port index is obtained assuming that GPIO ports are placed at regular
     0x400 intervals in memory space. So far this is true for all devices.*/
  portidx = (((uint32_t)port - (uint32_t)GPIOA) >> 10U) & 0xFU;

  /* Port selection in SYSCFG.*/
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
 800166e:	4c38      	ldr	r4, [pc, #224]	; (8001750 <Thread2+0x140>)
  /* Programming interrupt and event registers.*/
  EXTI_D1->IMR1 |= padmask;
  EXTI_D1->EMR1 &= ~padmask;
#else
  if (mode & PAL_EVENT_MODE_RISING_EDGE)
    EXTI->RTSR |= padmask;
 8001670:	4b38      	ldr	r3, [pc, #224]	; (8001754 <Thread2+0x144>)
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
 8001672:	68e1      	ldr	r1, [r4, #12]
 8001674:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
 8001678:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 800167c:	60e1      	str	r1, [r4, #12]
    EXTI->RTSR |= padmask;
 800167e:	6899      	ldr	r1, [r3, #8]
 8001680:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8001684:	6099      	str	r1, [r3, #8]
  else
    EXTI->RTSR &= ~padmask;
  if (mode & PAL_EVENT_MODE_FALLING_EDGE)
    EXTI->FTSR |= padmask;
 8001686:	68d9      	ldr	r1, [r3, #12]
 8001688:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 800168c:	60d9      	str	r1, [r3, #12]
  else
    EXTI->FTSR &= ~padmask;

  /* Programming interrupt and event registers.*/
  EXTI->IMR |= padmask;
 800168e:	6819      	ldr	r1, [r3, #0]
 8001690:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8001694:	6019      	str	r1, [r3, #0]
  EXTI->EMR &= ~padmask;
 8001696:	6859      	ldr	r1, [r3, #4]
 8001698:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 800169c:	6059      	str	r1, [r3, #4]
 800169e:	f382 8811 	msr	BASEPRI, r2
 80016a2:	f380 8811 	msr	BASEPRI, r0
 * @api
 */
void palSetLineCallbackI(ioline_t line, palcallback_t cb, void *arg) {

  palevent_t *pep = pal_lld_get_line_event(line);
  pep->cb = cb;
 80016a6:	4b2c      	ldr	r3, [pc, #176]	; (8001758 <Thread2+0x148>)
 80016a8:	492c      	ldr	r1, [pc, #176]	; (800175c <Thread2+0x14c>)
  pep->arg = arg;
 80016aa:	63da      	str	r2, [r3, #60]	; 0x3c
  pep->cb = cb;
 80016ac:	6399      	str	r1, [r3, #56]	; 0x38
 80016ae:	f382 8811 	msr	BASEPRI, r2
 80016b2:	f8df a0b4 	ldr.w	sl, [pc, #180]	; 8001768 <Thread2+0x158>
 80016b6:	4f2a      	ldr	r7, [pc, #168]	; (8001760 <Thread2+0x150>)
      palWriteLine(LED1, LED_ON);
 80016b8:	4e2a      	ldr	r6, [pc, #168]	; (8001764 <Thread2+0x154>)
        chprintf((BaseSequentialStream *)&SD2,"Button Pressed : %d \r\n", count_button1pressed);
 80016ba:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 800176c <Thread2+0x15c>
 80016be:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 8001770 <Thread2+0x160>
 80016c2:	e001      	b.n	80016c8 <Thread2+0xb8>
    if (events & EVENT_MASK(1)) {
 80016c4:	07a3      	lsls	r3, r4, #30
 80016c6:	d433      	bmi.n	8001730 <Thread2+0x120>
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  thread_t *ctp = currp;
 80016c8:	f8d5 b018 	ldr.w	fp, [r5, #24]
 80016cc:	2320      	movs	r3, #32
 80016ce:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 80016d2:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80016d6:	f013 0403 	ands.w	r4, r3, #3
 80016da:	d109      	bne.n	80016f0 <Thread2+0xe0>
    ctp->u.ewmask = events;
 80016dc:	2303      	movs	r3, #3
 80016de:	f8cb 3024 	str.w	r3, [fp, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 80016e2:	200a      	movs	r0, #10
 80016e4:	f000 fc74 	bl	8001fd0 <chSchGoSleepS>
    m = ctp->epending & events;
 80016e8:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 80016ec:	f003 0403 	and.w	r4, r3, #3
  }
  m ^= m & (m - (eventmask_t)1);
 80016f0:	4262      	negs	r2, r4
 80016f2:	4014      	ands	r4, r2
  ctp->epending &= ~m;
 80016f4:	ea23 0304 	bic.w	r3, r3, r4
 80016f8:	f8cb 3034 	str.w	r3, [fp, #52]	; 0x34
 80016fc:	2300      	movs	r3, #0
 80016fe:	f383 8811 	msr	BASEPRI, r3
    if (events & EVENT_MASK(0)) {
 8001702:	07e2      	lsls	r2, r4, #31
      palWriteLine(LED1, LED_ON);
 8001704:	f04f 0380 	mov.w	r3, #128	; 0x80
    if (events & EVENT_MASK(0)) {
 8001708:	d5dc      	bpl.n	80016c4 <Thread2+0xb4>
      palWriteLine(LED1, LED_ON);
 800170a:	61b3      	str	r3, [r6, #24]
      if(event_button1pressed==0){
 800170c:	f8da 3000 	ldr.w	r3, [sl]
 8001710:	2b00      	cmp	r3, #0
 8001712:	d1d7      	bne.n	80016c4 <Thread2+0xb4>
        count_button1pressed++;
 8001714:	683b      	ldr	r3, [r7, #0]
 8001716:	3301      	adds	r3, #1
        chprintf((BaseSequentialStream *)&SD2,"Button Pressed : %d \r\n", count_button1pressed);
 8001718:	461a      	mov	r2, r3
        event_button1pressed=1;
 800171a:	f04f 0e01 	mov.w	lr, #1
        chprintf((BaseSequentialStream *)&SD2,"Button Pressed : %d \r\n", count_button1pressed);
 800171e:	4649      	mov	r1, r9
 8001720:	4640      	mov	r0, r8
        count_button1pressed++;
 8001722:	603b      	str	r3, [r7, #0]
        event_button1pressed=1;
 8001724:	f8ca e000 	str.w	lr, [sl]
        chprintf((BaseSequentialStream *)&SD2,"Button Pressed : %d \r\n", count_button1pressed);
 8001728:	f000 ffc2 	bl	80026b0 <chprintf.constprop.0>
    if (events & EVENT_MASK(1)) {
 800172c:	07a3      	lsls	r3, r4, #30
 800172e:	d5cb      	bpl.n	80016c8 <Thread2+0xb8>
      palWriteLine(LED1, LED_OFF);
 8001730:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
      event_button1pressed=0;
 8001734:	2300      	movs	r3, #0
      palWriteLine(LED1, LED_OFF);
 8001736:	61b2      	str	r2, [r6, #24]
      event_button1pressed=0;
 8001738:	f8ca 3000 	str.w	r3, [sl]
 800173c:	e7bf      	b.n	80016be <Thread2+0xae>
 800173e:	bf00      	nop
 8001740:	200010c8 	.word	0x200010c8
 8001744:	20000910 	.word	0x20000910
 8001748:	20000914 	.word	0x20000914
 800174c:	08002afc 	.word	0x08002afc
 8001750:	40013800 	.word	0x40013800
 8001754:	40013c00 	.word	0x40013c00
 8001758:	2000088c 	.word	0x2000088c
 800175c:	08002201 	.word	0x08002201
 8001760:	20000a40 	.word	0x20000a40
 8001764:	40020c00 	.word	0x40020c00
 8001768:	20000ae4 	.word	0x20000ae4
 800176c:	08002b10 	.word	0x08002b10
 8001770:	2000104c 	.word	0x2000104c
	...

08001780 <main>:

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001780:	4b1e      	ldr	r3, [pc, #120]	; (80017fc <main+0x7c>)
  PWR->CR |= PWR_CR_DBP;
 8001782:	481f      	ldr	r0, [pc, #124]	; (8001800 <main+0x80>)
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001784:	6919      	ldr	r1, [r3, #16]
 8001786:	ea6f 51c1 	mvn.w	r1, r1, lsl #23
 800178a:	2200      	movs	r2, #0
 800178c:	ea6f 51d1 	mvn.w	r1, r1, lsr #23
/*--------------------------------------------------------------------------*/
/*=============================================================================*/
/*
 * Application entry point.
 */
int main(void) {
 8001790:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 8001794:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001798:	6119      	str	r1, [r3, #16]
 800179a:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 800179c:	6959      	ldr	r1, [r3, #20]
 800179e:	615c      	str	r4, [r3, #20]
 80017a0:	615a      	str	r2, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80017a2:	6a19      	ldr	r1, [r3, #32]
 80017a4:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 80017a8:	6219      	str	r1, [r3, #32]
 80017aa:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 80017ac:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80017ae:	625c      	str	r4, [r3, #36]	; 0x24
 80017b0:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 80017b2:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80017b4:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80017b8:	6419      	str	r1, [r3, #64]	; 0x40
 80017ba:	6e19      	ldr	r1, [r3, #96]	; 0x60
 80017bc:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80017c0:	6619      	str	r1, [r3, #96]	; 0x60
  PWR->CR |= PWR_CR_DBP;
 80017c2:	6801      	ldr	r1, [r0, #0]
 80017c4:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80017c8:	6001      	str	r1, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80017ca:	6f19      	ldr	r1, [r3, #112]	; 0x70
 80017cc:	f401 7140 	and.w	r1, r1, #768	; 0x300
 80017d0:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 80017d4:	b089      	sub	sp, #36	; 0x24
 80017d6:	d003      	beq.n	80017e0 <main+0x60>
    RCC->BDCR = RCC_BDCR_BDRST;
 80017d8:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 80017dc:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 80017de:	671a      	str	r2, [r3, #112]	; 0x70
  PWR->CSR &= ~PWR_CSR_BRE;
 80017e0:	4c07      	ldr	r4, [pc, #28]	; (8001800 <main+0x80>)
  dma_streams_mask = 0U;
 80017e2:	4e08      	ldr	r6, [pc, #32]	; (8001804 <main+0x84>)
 80017e4:	6862      	ldr	r2, [r4, #4]
 80017e6:	4908      	ldr	r1, [pc, #32]	; (8001808 <main+0x88>)
 80017e8:	4d08      	ldr	r5, [pc, #32]	; (800180c <main+0x8c>)
 80017ea:	4f09      	ldr	r7, [pc, #36]	; (8001810 <main+0x90>)
 80017ec:	2000      	movs	r0, #0
 80017ee:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80017f2:	6062      	str	r2, [r4, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80017f4:	4603      	mov	r3, r0
    _stm32_dma_streams[i].stream->CR = 0U;
 80017f6:	4602      	mov	r2, r0
  dma_streams_mask = 0U;
 80017f8:	6030      	str	r0, [r6, #0]
 80017fa:	e00d      	b.n	8001818 <main+0x98>
 80017fc:	40023800 	.word	0x40023800
 8001800:	40007000 	.word	0x40007000
 8001804:	20000ae0 	.word	0x20000ae0
 8001808:	08002b6c 	.word	0x08002b6c
 800180c:	40026010 	.word	0x40026010
 8001810:	20000a60 	.word	0x20000a60
 8001814:	f851 5c0c 	ldr.w	r5, [r1, #-12]
    _stm32_dma_streams[i].stream->CR = 0U;
 8001818:	602a      	str	r2, [r5, #0]
    dma_isr_redir[i].dma_func = NULL;
 800181a:	f847 2033 	str.w	r2, [r7, r3, lsl #3]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 800181e:	3301      	adds	r3, #1
 8001820:	2b10      	cmp	r3, #16
 8001822:	f101 010c 	add.w	r1, r1, #12
 8001826:	d1f5      	bne.n	8001814 <main+0x94>
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001828:	4bc1      	ldr	r3, [pc, #772]	; (8001b30 <main+0x3b0>)
  DMA1->LIFCR = 0xFFFFFFFFU;
 800182a:	48c2      	ldr	r0, [pc, #776]	; (8001b34 <main+0x3b4>)
  DMA2->LIFCR = 0xFFFFFFFFU;
 800182c:	4ec2      	ldr	r6, [pc, #776]	; (8001b38 <main+0x3b8>)
 800182e:	49c3      	ldr	r1, [pc, #780]	; (8001b3c <main+0x3bc>)
 8001830:	2260      	movs	r2, #96	; 0x60
  DMA1->LIFCR = 0xFFFFFFFFU;
 8001832:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001836:	2540      	movs	r5, #64	; 0x40
 8001838:	6084      	str	r4, [r0, #8]
 800183a:	2780      	movs	r7, #128	; 0x80
  DMA1->HIFCR = 0xFFFFFFFFU;
 800183c:	60c4      	str	r4, [r0, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 800183e:	60b4      	str	r4, [r6, #8]
 8001840:	f44f 7080 	mov.w	r0, #256	; 0x100
  DMA2->HIFCR = 0xFFFFFFFFU;
 8001844:	60f4      	str	r4, [r6, #12]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001846:	f883 2306 	strb.w	r2, [r3, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800184a:	f44f 7600 	mov.w	r6, #512	; 0x200
 800184e:	f8c3 5180 	str.w	r5, [r3, #384]	; 0x180
 8001852:	f44f 6480 	mov.w	r4, #1024	; 0x400
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001856:	601d      	str	r5, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001858:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800185c:	f883 2307 	strb.w	r2, [r3, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001860:	f8c3 7180 	str.w	r7, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001864:	601f      	str	r7, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001866:	f883 2308 	strb.w	r2, [r3, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800186a:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800186e:	6018      	str	r0, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001870:	f883 2309 	strb.w	r2, [r3, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001874:	f8c3 6180 	str.w	r6, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001878:	601e      	str	r6, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800187a:	f883 230a 	strb.w	r2, [r3, #778]	; 0x30a
 800187e:	19ce      	adds	r6, r1, r7
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001880:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001884:	601c      	str	r4, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001886:	f883 2317 	strb.w	r2, [r3, #791]	; 0x317
    _pal_init_event(i);
 800188a:	2400      	movs	r4, #0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800188c:	f8c3 5180 	str.w	r5, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001890:	601d      	str	r5, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001892:	f883 2328 	strb.w	r2, [r3, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001896:	f8c3 0184 	str.w	r0, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800189a:	6058      	str	r0, [r3, #4]
 800189c:	600c      	str	r4, [r1, #0]
 800189e:	604c      	str	r4, [r1, #4]
 80018a0:	3108      	adds	r1, #8
  for (i = 0; i < 16; i++) {
 80018a2:	42b1      	cmp	r1, r6
 80018a4:	d1fa      	bne.n	800189c <main+0x11c>
  sdp->vmt = &vmt;
 80018a6:	4ea6      	ldr	r6, [pc, #664]	; (8001b40 <main+0x3c0>)
  adcp->state    = ADC_STOP;
 80018a8:	4ba6      	ldr	r3, [pc, #664]	; (8001b44 <main+0x3c4>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80018aa:	f8df b284 	ldr.w	fp, [pc, #644]	; 8001b30 <main+0x3b0>
  ADCD1.adc = ADC1;
 80018ae:	4fa6      	ldr	r7, [pc, #664]	; (8001b48 <main+0x3c8>)
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 80018b0:	f8df 82d4 	ldr.w	r8, [pc, #724]	; 8001b88 <main+0x408>
  ADCD1.adc = ADC1;
 80018b4:	629f      	str	r7, [r3, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 80018b6:	f8c3 802c 	str.w	r8, [r3, #44]	; 0x2c
 80018ba:	2701      	movs	r7, #1
 80018bc:	4631      	mov	r1, r6
 80018be:	f04f 0860 	mov.w	r8, #96	; 0x60
  adcp->config   = NULL;
 80018c2:	605c      	str	r4, [r3, #4]
  adcp->samples  = NULL;
 80018c4:	609c      	str	r4, [r3, #8]
  adcp->depth    = 0;
 80018c6:	60dc      	str	r4, [r3, #12]
  adcp->grpp     = NULL;
 80018c8:	611c      	str	r4, [r3, #16]
  adcp->thread   = NULL;
 80018ca:	615c      	str	r4, [r3, #20]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 80018cc:	621c      	str	r4, [r3, #32]
  adcp->state    = ADC_STOP;
 80018ce:	701f      	strb	r7, [r3, #0]
 80018d0:	f8df a2b8 	ldr.w	sl, [pc, #696]	; 8001b8c <main+0x40c>
 80018d4:	f88b 8312 	strb.w	r8, [fp, #786]	; 0x312
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80018d8:	f44f 2880 	mov.w	r8, #262144	; 0x40000
 80018dc:	f8cb 8180 	str.w	r8, [fp, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80018e0:	f8cb 8000 	str.w	r8, [fp]
 80018e4:	f841 ab04 	str.w	sl, [r1], #4
  pwmp->state    = PWM_STOP;
 80018e8:	4d98      	ldr	r5, [pc, #608]	; (8001b4c <main+0x3cc>)
 80018ea:	4899      	ldr	r0, [pc, #612]	; (8001b50 <main+0x3d0>)
 80018ec:	4a99      	ldr	r2, [pc, #612]	; (8001b54 <main+0x3d4>)
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 80018ee:	f8df 92a0 	ldr.w	r9, [pc, #672]	; 8001b90 <main+0x410>
 80018f2:	f8c3 9030 	str.w	r9, [r3, #48]	; 0x30
  tqp->next = (thread_t *)tqp;
 80018f6:	f103 0818 	add.w	r8, r3, #24
  PWMD1.channels = STM32_TIM1_CHANNELS;
 80018fa:	f04f 0a04 	mov.w	sl, #4

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80018fe:	f8df 9294 	ldr.w	r9, [pc, #660]	; 8001b94 <main+0x414>
 8001902:	6071      	str	r1, [r6, #4]
 8001904:	f8c3 8018 	str.w	r8, [r3, #24]
  oqp->q_counter = size;
 8001908:	2110      	movs	r1, #16
  tqp->prev = (thread_t *)tqp;
 800190a:	f8c3 801c 	str.w	r8, [r3, #28]
  PWMD1.tim = STM32_TIM1;
 800190e:	f8df c288 	ldr.w	ip, [pc, #648]	; 8001b98 <main+0x418>
  PWMD3.tim = STM32_TIM3;
 8001912:	f8df e288 	ldr.w	lr, [pc, #648]	; 8001b9c <main+0x41c>
  PWMD4.tim = STM32_TIM4;
 8001916:	4b90      	ldr	r3, [pc, #576]	; (8001b58 <main+0x3d8>)
 8001918:	702f      	strb	r7, [r5, #0]
  pwmp->config   = NULL;
 800191a:	606c      	str	r4, [r5, #4]
  pwmp->enabled  = 0;
 800191c:	60ec      	str	r4, [r5, #12]
  PWMD1.tim = STM32_TIM1;
 800191e:	f8c5 c018 	str.w	ip, [r5, #24]
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8001922:	f885 a010 	strb.w	sl, [r5, #16]
  pwmp->state    = PWM_STOP;
 8001926:	7007      	strb	r7, [r0, #0]
  pwmp->config   = NULL;
 8001928:	6044      	str	r4, [r0, #4]
  pwmp->enabled  = 0;
 800192a:	60c4      	str	r4, [r0, #12]
  PWMD3.channels = STM32_TIM3_CHANNELS;
 800192c:	f880 a010 	strb.w	sl, [r0, #16]
  PWMD3.tim = STM32_TIM3;
 8001930:	f8c0 e018 	str.w	lr, [r0, #24]
  pwmp->state    = PWM_STOP;
 8001934:	7017      	strb	r7, [r2, #0]
  pwmp->config   = NULL;
 8001936:	6054      	str	r4, [r2, #4]
  pwmp->enabled  = 0;
 8001938:	60d4      	str	r4, [r2, #12]
  PWMD4.channels = STM32_TIM4_CHANNELS;
 800193a:	f882 a010 	strb.w	sl, [r2, #16]
  PWMD4.tim = STM32_TIM4;
 800193e:	6193      	str	r3, [r2, #24]
  sdp->state = SD_STOP;
 8001940:	7237      	strb	r7, [r6, #8]
  iqp->q_counter = 0;
 8001942:	6174      	str	r4, [r6, #20]
  oqp->q_counter = size;
 8001944:	63b1      	str	r1, [r6, #56]	; 0x38
 8001946:	f8d9 3040 	ldr.w	r3, [r9, #64]	; 0x40
 800194a:	9101      	str	r1, [sp, #4]
 800194c:	433b      	orrs	r3, r7
  iqp->q_notify  = infy;
 800194e:	62b4      	str	r4, [r6, #40]	; 0x28
 8001950:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
 8001954:	f8d9 3060 	ldr.w	r3, [r9, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001958:	4880      	ldr	r0, [pc, #512]	; (8001b5c <main+0x3dc>)
  iqp->q_link    = link;
 800195a:	62f6      	str	r6, [r6, #44]	; 0x2c
  ST_ENABLE_CLOCK();
 800195c:	433b      	orrs	r3, r7
 800195e:	f8c9 3060 	str.w	r3, [r9, #96]	; 0x60
  ST_ENABLE_STOP();
 8001962:	6882      	ldr	r2, [r0, #8]
  oqp->q_notify  = onfy;
 8001964:	f8df e238 	ldr.w	lr, [pc, #568]	; 8001ba0 <main+0x420>
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8001968:	f8df 8238 	ldr.w	r8, [pc, #568]	; 8001ba4 <main+0x424>
  tqp->next = (thread_t *)tqp;
 800196c:	4d7c      	ldr	r5, [pc, #496]	; (8001b60 <main+0x3e0>)
 800196e:	f8c6 e04c 	str.w	lr, [r6, #76]	; 0x4c

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001972:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  oqp->q_top     = bp + size;
 8001976:	f106 0c74 	add.w	ip, r6, #116	; 0x74
  ST_ENABLE_STOP();
 800197a:	433a      	orrs	r2, r7
 800197c:	f8c6 c040 	str.w	ip, [r6, #64]	; 0x40
 8001980:	f8c6 8074 	str.w	r8, [r6, #116]	; 0x74
  oqp->q_link    = link;
 8001984:	6536      	str	r6, [r6, #80]	; 0x50
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001986:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
  ST_ENABLE_STOP();
 800198a:	6082      	str	r2, [r0, #8]
 800198c:	f106 080c 	add.w	r8, r6, #12
  iqp->q_buffer  = bp;
 8001990:	f106 0054 	add.w	r0, r6, #84	; 0x54
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001994:	f242 0ccf 	movw	ip, #8399	; 0x20cf
 8001998:	f8c3 c028 	str.w	ip, [r3, #40]	; 0x28
  iqp->q_top     = bp + size;
 800199c:	f106 0264 	add.w	r2, r6, #100	; 0x64
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80019a0:	f8c3 e02c 	str.w	lr, [r3, #44]	; 0x2c
 80019a4:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 80019a8:	f8c6 800c 	str.w	r8, [r6, #12]
  STM32_ST_TIM->CCMR1  = 0;
 80019ac:	619c      	str	r4, [r3, #24]
  tqp->prev = (thread_t *)tqp;
 80019ae:	f8c6 8010 	str.w	r8, [r6, #16]
  STM32_ST_TIM->CCR[0] = 0;
 80019b2:	635c      	str	r4, [r3, #52]	; 0x34
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80019b4:	f04f 0880 	mov.w	r8, #128	; 0x80
  iqp->q_buffer  = bp;
 80019b8:	61b0      	str	r0, [r6, #24]
  STM32_ST_TIM->DIER   = 0;
 80019ba:	60dc      	str	r4, [r3, #12]
  iqp->q_rdptr   = bp;
 80019bc:	6270      	str	r0, [r6, #36]	; 0x24
  STM32_ST_TIM->CR2    = 0;
 80019be:	605c      	str	r4, [r3, #4]
  iqp->q_wrptr   = bp;
 80019c0:	6230      	str	r0, [r6, #32]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80019c2:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80019c6:	615f      	str	r7, [r3, #20]
  iqp->q_top     = bp + size;
 80019c8:	61f2      	str	r2, [r6, #28]
  oqp->q_buffer  = bp;
 80019ca:	63f2      	str	r2, [r6, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 80019cc:	64b2      	str	r2, [r6, #72]	; 0x48
  oqp->q_wrptr   = bp;
 80019ce:	6472      	str	r2, [r6, #68]	; 0x44
  tqp->next = (thread_t *)tqp;
 80019d0:	f8c6 c030 	str.w	ip, [r6, #48]	; 0x30

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 80019d4:	2200      	movs	r2, #0
  tqp->prev = (thread_t *)tqp;
 80019d6:	f8c6 c034 	str.w	ip, [r6, #52]	; 0x34
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80019da:	601f      	str	r7, [r3, #0]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 80019dc:	f105 0c1c 	add.w	ip, r5, #28
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80019e0:	f88b 831c 	strb.w	r8, [fp, #796]	; 0x31c
 80019e4:	2300      	movs	r3, #0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80019e6:	f8cb 0180 	str.w	r0, [fp, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80019ea:	f8cb 0000 	str.w	r0, [fp]
  chTMStartMeasurementX(&tm);
 80019ee:	a802      	add	r0, sp, #8
  tqp->next = (thread_t *)tqp;
 80019f0:	602d      	str	r5, [r5, #0]
  tqp->prev = (thread_t *)tqp;
 80019f2:	606d      	str	r5, [r5, #4]
  tmp->cumulative = (rttime_t)0;
 80019f4:	e9cd 2306 	strd	r2, r3, [sp, #24]
  tmp->best       = (rtcnt_t)-1;
 80019f8:	f8cd e008 	str.w	lr, [sp, #8]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (sysinterval_t)-1;
 80019fc:	f8c5 e024 	str.w	lr, [r5, #36]	; 0x24
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8001a00:	f8c5 c01c 	str.w	ip, [r5, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8001a04:	f8c5 c020 	str.w	ip, [r5, #32]
  tmp->worst      = (rtcnt_t)0;
 8001a08:	9403      	str	r4, [sp, #12]
  tmp->last       = (rtcnt_t)0;
 8001a0a:	9404      	str	r4, [sp, #16]
  tmp->n          = (ucnt_t)0;
 8001a0c:	9405      	str	r4, [sp, #20]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8001a0e:	60ac      	str	r4, [r5, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8001a10:	612d      	str	r5, [r5, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8001a12:	616d      	str	r5, [r5, #20]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8001a14:	62ac      	str	r4, [r5, #40]	; 0x28
  ch.tm.offset = (rtcnt_t)0;
 8001a16:	676c      	str	r4, [r5, #116]	; 0x74
  chTMStartMeasurementX(&tm);
 8001a18:	f000 fdfa 	bl	8002610 <chTMStartMeasurementX.constprop.6>
  chTMStopMeasurementX(&tm);
 8001a1c:	a802      	add	r0, sp, #8
 8001a1e:	f000 fa8f 	bl	8001f40 <chTMStopMeasurementX>
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8001a22:	4850      	ldr	r0, [pc, #320]	; (8001b64 <main+0x3e4>)
  ch.tm.offset = tm.last;
 8001a24:	9b04      	ldr	r3, [sp, #16]
  tqp->next = (thread_t *)tqp;
 8001a26:	4a50      	ldr	r2, [pc, #320]	; (8001b68 <main+0x3e8>)
 8001a28:	676b      	str	r3, [r5, #116]	; 0x74
 8001a2a:	4b50      	ldr	r3, [pc, #320]	; (8001b6c <main+0x3ec>)
 8001a2c:	6003      	str	r3, [r0, #0]
 8001a2e:	f100 030c 	add.w	r3, r0, #12
  H_NEXT(&default_heap.header) = NULL;
 8001a32:	6044      	str	r4, [r0, #4]
  H_PAGES(&default_heap.header) = 0;
 8001a34:	6084      	str	r4, [r0, #8]
 8001a36:	6144      	str	r4, [r0, #20]
 8001a38:	60c3      	str	r3, [r0, #12]
  tqp->prev = (thread_t *)tqp;
 8001a3a:	6103      	str	r3, [r0, #16]
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 8001a3c:	f102 0010 	add.w	r0, r2, #16
                             unsigned align, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
  mp->object_size = size;
 8001a40:	2314      	movs	r3, #20
  mp->align = align;
 8001a42:	f8c2 a01c 	str.w	sl, [r2, #28]
 8001a46:	f8c2 a034 	str.w	sl, [r2, #52]	; 0x34
 8001a4a:	6110      	str	r0, [r2, #16]
 8001a4c:	f102 0a24 	add.w	sl, r2, #36	; 0x24
 8001a50:	f102 0028 	add.w	r0, r2, #40	; 0x28
  mp->object_size = size;
 8001a54:	6193      	str	r3, [r2, #24]
 8001a56:	231c      	movs	r3, #28
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001a58:	f8df e14c 	ldr.w	lr, [pc, #332]	; 8001ba8 <main+0x428>
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 8001a5c:	f8df c14c 	ldr.w	ip, [pc, #332]	; 8001bac <main+0x42c>
 8001a60:	f8c2 a024 	str.w	sl, [r2, #36]	; 0x24
 8001a64:	6290      	str	r0, [r2, #40]	; 0x28
 8001a66:	f102 0a3c 	add.w	sl, r2, #60	; 0x3c
 8001a6a:	f102 0040 	add.w	r0, r2, #64	; 0x40
 8001a6e:	6313      	str	r3, [r2, #48]	; 0x30
  mp->provider = provider;
 8001a70:	4b3f      	ldr	r3, [pc, #252]	; (8001b70 <main+0x3f0>)
 8001a72:	f8c2 a03c 	str.w	sl, [r2, #60]	; 0x3c
 8001a76:	6410      	str	r0, [r2, #64]	; 0x40
 8001a78:	6213      	str	r3, [r2, #32]
 8001a7a:	6393      	str	r3, [r2, #56]	; 0x38
 8001a7c:	f8df a130 	ldr.w	sl, [pc, #304]	; 8001bb0 <main+0x430>
  ch_memcore.endmem  = __heap_end__;
 8001a80:	483c      	ldr	r0, [pc, #240]	; (8001b74 <main+0x3f4>)
  tp->name      = name;
 8001a82:	4b3d      	ldr	r3, [pc, #244]	; (8001b78 <main+0x3f8>)
 8001a84:	6094      	str	r4, [r2, #8]
  mp->next = NULL;
 8001a86:	6154      	str	r4, [r2, #20]
 8001a88:	62d4      	str	r4, [r2, #44]	; 0x2c
  ch_memcore.nextmem = __heap_base__;
 8001a8a:	f8cc a000 	str.w	sl, [ip]
  ch_memcore.endmem  = __heap_end__;
 8001a8e:	f8cc 0004 	str.w	r0, [ip, #4]
  tp->prio      = prio;
 8001a92:	f8c5 8038 	str.w	r8, [r5, #56]	; 0x38
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001a96:	f885 4051 	strb.w	r4, [r5, #81]	; 0x51
  tp->realprio  = prio;
 8001a9a:	f8c5 806c 	str.w	r8, [r5, #108]	; 0x6c
  tp->mtxlist   = NULL;
 8001a9e:	66ac      	str	r4, [r5, #104]	; 0x68
  tp->epending  = (eventmask_t)0;
 8001aa0:	666c      	str	r4, [r5, #100]	; 0x64
  tp->refs      = (trefs_t)1;
 8001aa2:	f885 7052 	strb.w	r7, [r5, #82]	; 0x52
  tqp->next = (thread_t *)tqp;
 8001aa6:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 8001aa8:	6052      	str	r2, [r2, #4]
  tp->name      = name;
 8001aaa:	64ab      	str	r3, [r5, #72]	; 0x48
 8001aac:	f8de 000c 	ldr.w	r0, [lr, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8001ab0:	4b32      	ldr	r3, [pc, #200]	; (8001b7c <main+0x3fc>)
  REG_INSERT(tp);
 8001ab2:	f8d5 a014 	ldr.w	sl, [r5, #20]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001ab6:	f8df c0fc 	ldr.w	ip, [pc, #252]	; 8001bb4 <main+0x434>
 8001aba:	f8c5 a044 	str.w	sl, [r5, #68]	; 0x44
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001abe:	f64f 02ff 	movw	r2, #63743	; 0xf8ff
 8001ac2:	4010      	ands	r0, r2
  reg_value  =  (reg_value                                   |
 8001ac4:	4303      	orrs	r3, r0
 8001ac6:	f105 0230 	add.w	r2, r5, #48	; 0x30
 8001aca:	642d      	str	r5, [r5, #64]	; 0x40
 8001acc:	f8ca 2010 	str.w	r2, [sl, #16]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8001ad0:	f8ce 300c 	str.w	r3, [lr, #12]
 8001ad4:	f8dc 300c 	ldr.w	r3, [ip, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8001ad8:	4829      	ldr	r0, [pc, #164]	; (8001b80 <main+0x400>)
 8001ada:	616a      	str	r2, [r5, #20]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001adc:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001ae0:	f8cc 300c 	str.w	r3, [ip, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8001ae4:	6803      	ldr	r3, [r0, #0]
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001ae6:	9901      	ldr	r1, [sp, #4]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8001ae8:	61aa      	str	r2, [r5, #24]
 8001aea:	433b      	orrs	r3, r7
  tqp->next = (thread_t *)tqp;
 8001aec:	f105 025c 	add.w	r2, r5, #92	; 0x5c
  tlp->next = (thread_t *)tlp;
 8001af0:	f105 0c58 	add.w	ip, r5, #88	; 0x58
 8001af4:	f04f 0a20 	mov.w	sl, #32
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 8001af8:	64ec      	str	r4, [r5, #76]	; 0x4c
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8001afa:	f885 7050 	strb.w	r7, [r5, #80]	; 0x50
 8001afe:	6003      	str	r3, [r0, #0]
 8001b00:	f8c5 c058 	str.w	ip, [r5, #88]	; 0x58
 8001b04:	f88e 101f 	strb.w	r1, [lr, #31]
  tqp->next = (thread_t *)tqp;
 8001b08:	65ea      	str	r2, [r5, #92]	; 0x5c
 8001b0a:	f88e a022 	strb.w	sl, [lr, #34]	; 0x22
  tqp->prev = (thread_t *)tqp;
 8001b0e:	662a      	str	r2, [r5, #96]	; 0x60
 8001b10:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 8001b14:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001b16:	f38a 8811 	msr	BASEPRI, sl
  tp->wabase = tdp->wbase;
 8001b1a:	4b1a      	ldr	r3, [pc, #104]	; (8001b84 <main+0x404>)
  REG_INSERT(tp);
 8001b1c:	6969      	ldr	r1, [r5, #20]
  tp->prio      = prio;
 8001b1e:	f8c3 7098 	str.w	r7, [r3, #152]	; 0x98
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001b22:	f103 026c 	add.w	r2, r3, #108	; 0x6c
  tp->realprio  = prio;
 8001b26:	f8c3 70cc 	str.w	r7, [r3, #204]	; 0xcc
  tp->refs      = (trefs_t)1;
 8001b2a:	f883 70b2 	strb.w	r7, [r3, #178]	; 0xb2
 8001b2e:	e043      	b.n	8001bb8 <main+0x438>
 8001b30:	e000e100 	.word	0xe000e100
 8001b34:	40026000 	.word	0x40026000
 8001b38:	40026400 	.word	0x40026400
 8001b3c:	2000088c 	.word	0x2000088c
 8001b40:	2000104c 	.word	0x2000104c
 8001b44:	20001018 	.word	0x20001018
 8001b48:	40012000 	.word	0x40012000
 8001b4c:	20000838 	.word	0x20000838
 8001b50:	20000854 	.word	0x20000854
 8001b54:	20000870 	.word	0x20000870
 8001b58:	40000800 	.word	0x40000800
 8001b5c:	e0042000 	.word	0xe0042000
 8001b60:	200010c8 	.word	0x200010c8
 8001b64:	20000a44 	.word	0x20000a44
 8001b68:	20000918 	.word	0x20000918
 8001b6c:	08001df1 	.word	0x08001df1
 8001b70:	08001db1 	.word	0x08001db1
 8001b74:	20020000 	.word	0x20020000
 8001b78:	08002c48 	.word	0x08002c48
 8001b7c:	05fa0300 	.word	0x05fa0300
 8001b80:	e0001000 	.word	0xe0001000
 8001b84:	20000960 	.word	0x20000960
 8001b88:	08002bf0 	.word	0x08002bf0
 8001b8c:	08002c88 	.word	0x08002c88
 8001b90:	00022c16 	.word	0x00022c16
 8001b94:	40023800 	.word	0x40023800
 8001b98:	40010000 	.word	0x40010000
 8001b9c:	40000400 	.word	0x40000400
 8001ba0:	080003e1 	.word	0x080003e1
 8001ba4:	40004400 	.word	0x40004400
 8001ba8:	e000ed00 	.word	0xe000ed00
 8001bac:	20000a38 	.word	0x20000a38
 8001bb0:	20001140 	.word	0x20001140
 8001bb4:	e000edf0 	.word	0xe000edf0
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001bb8:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 8001bbc:	f8df c17c 	ldr.w	ip, [pc, #380]	; 8001d3c <main+0x5bc>
 8001bc0:	f8df e17c 	ldr.w	lr, [pc, #380]	; 8001d40 <main+0x5c0>
  tp->name      = name;
 8001bc4:	484f      	ldr	r0, [pc, #316]	; (8001d04 <main+0x584>)
  REG_INSERT(tp);
 8001bc6:	f8c3 10a4 	str.w	r1, [r3, #164]	; 0xa4
 8001bca:	f103 0290 	add.w	r2, r3, #144	; 0x90
  tp->state     = CH_STATE_WTSTART;
 8001bce:	2702      	movs	r7, #2
 8001bd0:	f883 70b0 	strb.w	r7, [r3, #176]	; 0xb0
  tp->name      = name;
 8001bd4:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001bd8:	671c      	str	r4, [r3, #112]	; 0x70
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001bda:	f883 40b1 	strb.w	r4, [r3, #177]	; 0xb1
  tp->mtxlist   = NULL;
 8001bde:	f8c3 40c8 	str.w	r4, [r3, #200]	; 0xc8
  tp->epending  = (eventmask_t)0;
 8001be2:	f8c3 40c4 	str.w	r4, [r3, #196]	; 0xc4
  REG_INSERT(tp);
 8001be6:	f8c3 50a0 	str.w	r5, [r3, #160]	; 0xa0
  tp->wabase = tdp->wbase;
 8001bea:	f8c3 30ac 	str.w	r3, [r3, #172]	; 0xac
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001bee:	f8c3 c06c 	str.w	ip, [r3, #108]	; 0x6c
 8001bf2:	f8c3 e08c 	str.w	lr, [r3, #140]	; 0x8c
  tlp->next = (thread_t *)tlp;
 8001bf6:	f103 07b8 	add.w	r7, r3, #184	; 0xb8
  REG_INSERT(tp);
 8001bfa:	610a      	str	r2, [r1, #16]
  tqp->next = (thread_t *)tqp;
 8001bfc:	f103 01bc 	add.w	r1, r3, #188	; 0xbc
  chSchWakeupS(tp, MSG_OK);
 8001c00:	4610      	mov	r0, r2
  tlp->next = (thread_t *)tlp;
 8001c02:	f8c3 70b8 	str.w	r7, [r3, #184]	; 0xb8
  tqp->next = (thread_t *)tqp;
 8001c06:	f8c3 10bc 	str.w	r1, [r3, #188]	; 0xbc
  tqp->prev = (thread_t *)tqp;
 8001c0a:	f8c3 10c0 	str.w	r1, [r3, #192]	; 0xc0
  REG_INSERT(tp);
 8001c0e:	616a      	str	r2, [r5, #20]
  chSchWakeupS(tp, MSG_OK);
 8001c10:	f000 fcce 	bl	80025b0 <chSchWakeupS.constprop.11>
 8001c14:	f384 8811 	msr	BASEPRI, r4
   */
  halInit();
  chSysInit();
  /*===========================================================================*/
  /*----------------------------GPIO Init-------------------------------------*/
  palSetPadMode(GPIOD, 7, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 8001c18:	4d3b      	ldr	r5, [pc, #236]	; (8001d08 <main+0x588>)
  palSetPadMode(GPIOB, 5, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 8001c1a:	4c3c      	ldr	r4, [pc, #240]	; (8001d0c <main+0x58c>)
  palSetPadMode(GPIOD, 7, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 8001c1c:	4641      	mov	r1, r8
 8001c1e:	4628      	mov	r0, r5
 8001c20:	2219      	movs	r2, #25
 8001c22:	f7fe ff95 	bl	8000b50 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 5, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 8001c26:	4651      	mov	r1, sl
 8001c28:	4620      	mov	r0, r4
 8001c2a:	2219      	movs	r2, #25
 8001c2c:	f7fe ff90 	bl	8000b50 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 7, PAL_MODE_INPUT_PULLDOWN);
 8001c30:	4641      	mov	r1, r8
 8001c32:	4620      	mov	r0, r4
 8001c34:	2240      	movs	r2, #64	; 0x40
 8001c36:	f7fe ff8b 	bl	8000b50 <_pal_lld_setgroupmode>
  palClearLine(LED1);
 8001c3a:	f8a5 801a 	strh.w	r8, [r5, #26]
  palClearLine(LED2);
 8001c3e:	f8a4 a01a 	strh.w	sl, [r4, #26]
 8001c42:	f38a 8811 	msr	BASEPRI, sl
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8001c46:	7a33      	ldrb	r3, [r6, #8]
 8001c48:	2b01      	cmp	r3, #1
 8001c4a:	d045      	beq.n	8001cd8 <main+0x558>
  USART_TypeDef *u = sdp->usart;
 8001c4c:	6f73      	ldr	r3, [r6, #116]	; 0x74
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8001c4e:	4a30      	ldr	r2, [pc, #192]	; (8001d10 <main+0x590>)
 8001c50:	4293      	cmp	r3, r2
 8001c52:	d03d      	beq.n	8001cd0 <main+0x550>
 8001c54:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001c58:	4293      	cmp	r3, r2
 8001c5a:	d039      	beq.n	8001cd0 <main+0x550>
    u->BRR = STM32_PCLK1 / config->speed;
 8001c5c:	f240 4245 	movw	r2, #1093	; 0x445
 8001c60:	609a      	str	r2, [r3, #8]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001c62:	2440      	movs	r4, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001c64:	2101      	movs	r1, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8001c66:	f242 152c 	movw	r5, #8492	; 0x212c
  u->SR = 0;
 8001c6a:	2200      	movs	r2, #0
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001c6c:	611c      	str	r4, [r3, #16]
    sdp->rxmask = 0xFF;
 8001c6e:	20ff      	movs	r0, #255	; 0xff
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001c70:	6159      	str	r1, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8001c72:	60dd      	str	r5, [r3, #12]
  sdp->state = SD_READY;
 8001c74:	2102      	movs	r1, #2
  u->SR = 0;
 8001c76:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8001c78:	681d      	ldr	r5, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8001c7a:	685b      	ldr	r3, [r3, #4]
    sdp->rxmask = 0xFF;
 8001c7c:	f886 0078 	strb.w	r0, [r6, #120]	; 0x78
 8001c80:	7231      	strb	r1, [r6, #8]
 8001c82:	f382 8811 	msr	BASEPRI, r2
  // Default is 38400-8-N-1
  // bits :8, stopbits : 1, parity :none, flow control : none
  /* Activates the serial driver 2.
   * PD5(TX) and PD6(RX) are routed to USART2.*/
  sdStart(&SD2, &serialcfg);
  palSetPadMode(GPIOD, 5, PAL_MODE_ALTERNATE(7));
 8001c86:	f240 3282 	movw	r2, #898	; 0x382
 8001c8a:	2120      	movs	r1, #32
 8001c8c:	481e      	ldr	r0, [pc, #120]	; (8001d08 <main+0x588>)
 8001c8e:	f7fe ff5f 	bl	8000b50 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOD, 6, PAL_MODE_ALTERNATE(7));
 8001c92:	f240 3282 	movw	r2, #898	; 0x382
 8001c96:	4621      	mov	r1, r4
 8001c98:	481b      	ldr	r0, [pc, #108]	; (8001d08 <main+0x588>)
 8001c9a:	f7fe ff59 	bl	8000b50 <_pal_lld_setgroupmode>
  chprintf((BaseSequentialStream *)&SD2,"Debug Via Serial Using UART2 \r\n");
 8001c9e:	491d      	ldr	r1, [pc, #116]	; (8001d14 <main+0x594>)
 8001ca0:	481d      	ldr	r0, [pc, #116]	; (8001d18 <main+0x598>)
 8001ca2:	f000 fd05 	bl	80026b0 <chprintf.constprop.0>
   * Creates thread.
   * Thread * 	chThdCreateStatic (void *wsp, size_t size, tprio_t prio, tfunc_t pf, void *arg)
 	  Creates a new thread into a static memory area. 
    Ordering thread by decreasing priority they are main, Thread1, ...., and idle.
  */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO+1, Thread1, NULL);
 8001ca6:	4a1d      	ldr	r2, [pc, #116]	; (8001d1c <main+0x59c>)
 8001ca8:	481d      	ldr	r0, [pc, #116]	; (8001d20 <main+0x5a0>)
 8001caa:	2181      	movs	r1, #129	; 0x81
 8001cac:	f000 fcb8 	bl	8002620 <chThdCreateStatic.constprop.5>
  chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO+2, Thread2, NULL);
 8001cb0:	4a1c      	ldr	r2, [pc, #112]	; (8001d24 <main+0x5a4>)
 8001cb2:	481d      	ldr	r0, [pc, #116]	; (8001d28 <main+0x5a8>)
 8001cb4:	2182      	movs	r1, #130	; 0x82
 8001cb6:	f000 fcb3 	bl	8002620 <chThdCreateStatic.constprop.5>
  chThdCreateStatic(waThread3, sizeof(waThread3), NORMALPRIO+4, Thread3, NULL);
 8001cba:	4a1c      	ldr	r2, [pc, #112]	; (8001d2c <main+0x5ac>)
 8001cbc:	481c      	ldr	r0, [pc, #112]	; (8001d30 <main+0x5b0>)
 8001cbe:	2184      	movs	r1, #132	; 0x84
 8001cc0:	f000 fcae 	bl	8002620 <chThdCreateStatic.constprop.5>
  chThdCreateStatic(waThread4, sizeof(waThread4), NORMALPRIO+3, Thread4, NULL);
 8001cc4:	4a1b      	ldr	r2, [pc, #108]	; (8001d34 <main+0x5b4>)
 8001cc6:	481c      	ldr	r0, [pc, #112]	; (8001d38 <main+0x5b8>)
 8001cc8:	2183      	movs	r1, #131	; 0x83
 8001cca:	f000 fca9 	bl	8002620 <chThdCreateStatic.constprop.5>
 8001cce:	e7fe      	b.n	8001cce <main+0x54e>
    u->BRR = STM32_PCLK2 / config->speed;
 8001cd0:	f640 028b 	movw	r2, #2187	; 0x88b
 8001cd4:	609a      	str	r2, [r3, #8]
 8001cd6:	e7c4      	b.n	8001c62 <main+0x4e2>
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccEnableUSART2(true);
 8001cd8:	f8d9 3040 	ldr.w	r3, [r9, #64]	; 0x40
 8001cdc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001ce0:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
 8001ce4:	f8d9 3060 	ldr.w	r3, [r9, #96]	; 0x60
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001ce8:	2240      	movs	r2, #64	; 0x40
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001cea:	21c0      	movs	r1, #192	; 0xc0
 8001cec:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001cf0:	f8c9 3060 	str.w	r3, [r9, #96]	; 0x60
 8001cf4:	f88b 1326 	strb.w	r1, [fp, #806]	; 0x326
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001cf8:	f8cb 2184 	str.w	r2, [fp, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001cfc:	f8cb 2004 	str.w	r2, [fp, #4]
 8001d00:	e7a4      	b.n	8001c4c <main+0x4cc>
 8001d02:	bf00      	nop
 8001d04:	08002c60 	.word	0x08002c60
 8001d08:	40020c00 	.word	0x40020c00
 8001d0c:	40020400 	.word	0x40020400
 8001d10:	40011000 	.word	0x40011000
 8001d14:	08002c68 	.word	0x08002c68
 8001d18:	2000104c 	.word	0x2000104c
 8001d1c:	08001221 	.word	0x08001221
 8001d20:	20000af8 	.word	0x20000af8
 8001d24:	08001611 	.word	0x08001611
 8001d28:	20000c40 	.word	0x20000c40
 8001d2c:	08001441 	.word	0x08001441
 8001d30:	20000d88 	.word	0x20000d88
 8001d34:	08001251 	.word	0x08001251
 8001d38:	20000ed0 	.word	0x20000ed0
 8001d3c:	08001eb1 	.word	0x08001eb1
 8001d40:	080002d1 	.word	0x080002d1
	...

08001d50 <adc_callback>:
  if (adcp->state == ADC_COMPLETE) {  
 8001d50:	7803      	ldrb	r3, [r0, #0]
 8001d52:	2b04      	cmp	r3, #4
 8001d54:	d116      	bne.n	8001d84 <adc_callback+0x34>
    avg_adc1ch0 = (samples1[0] + samples1[2] + samples1[4] + samples1[6]) / 4;
 8001d56:	490c      	ldr	r1, [pc, #48]	; (8001d88 <adc_callback+0x38>)
 8001d58:	480c      	ldr	r0, [pc, #48]	; (8001d8c <adc_callback+0x3c>)
 8001d5a:	880a      	ldrh	r2, [r1, #0]
    avg_adc1ch1 = (samples1[1] + samples1[3] + samples1[5] + samples1[7]) / 4;
 8001d5c:	884b      	ldrh	r3, [r1, #2]
void adc_callback(ADCDriver *adcp, adcsample_t *buffer, size_t n) {
 8001d5e:	b4f0      	push	{r4, r5, r6, r7}
    avg_adc1ch0 = (samples1[0] + samples1[2] + samples1[4] + samples1[6]) / 4;
 8001d60:	888d      	ldrh	r5, [r1, #4]
    avg_adc1ch1 = (samples1[1] + samples1[3] + samples1[5] + samples1[7]) / 4;
 8001d62:	88cc      	ldrh	r4, [r1, #6]
    avg_adc1ch0 = (samples1[0] + samples1[2] + samples1[4] + samples1[6]) / 4;
 8001d64:	890f      	ldrh	r7, [r1, #8]
    avg_adc1ch1 = (samples1[1] + samples1[3] + samples1[5] + samples1[7]) / 4;
 8001d66:	894e      	ldrh	r6, [r1, #10]
    avg_adc1ch0 = (samples1[0] + samples1[2] + samples1[4] + samples1[6]) / 4;
 8001d68:	442a      	add	r2, r5
    avg_adc1ch1 = (samples1[1] + samples1[3] + samples1[5] + samples1[7]) / 4;
 8001d6a:	4423      	add	r3, r4
    avg_adc1ch0 = (samples1[0] + samples1[2] + samples1[4] + samples1[6]) / 4;
 8001d6c:	898d      	ldrh	r5, [r1, #12]
    avg_adc1ch1 = (samples1[1] + samples1[3] + samples1[5] + samples1[7]) / 4;
 8001d6e:	89cc      	ldrh	r4, [r1, #14]
 8001d70:	4907      	ldr	r1, [pc, #28]	; (8001d90 <adc_callback+0x40>)
    avg_adc1ch0 = (samples1[0] + samples1[2] + samples1[4] + samples1[6]) / 4;
 8001d72:	443a      	add	r2, r7
    avg_adc1ch1 = (samples1[1] + samples1[3] + samples1[5] + samples1[7]) / 4;
 8001d74:	4433      	add	r3, r6
    avg_adc1ch0 = (samples1[0] + samples1[2] + samples1[4] + samples1[6]) / 4;
 8001d76:	442a      	add	r2, r5
    avg_adc1ch1 = (samples1[1] + samples1[3] + samples1[5] + samples1[7]) / 4;
 8001d78:	4423      	add	r3, r4
}
 8001d7a:	bcf0      	pop	{r4, r5, r6, r7}
    avg_adc1ch0 = (samples1[0] + samples1[2] + samples1[4] + samples1[6]) / 4;
 8001d7c:	1092      	asrs	r2, r2, #2
    avg_adc1ch1 = (samples1[1] + samples1[3] + samples1[5] + samples1[7]) / 4;
 8001d7e:	109b      	asrs	r3, r3, #2
    avg_adc1ch0 = (samples1[0] + samples1[2] + samples1[4] + samples1[6]) / 4;
 8001d80:	8002      	strh	r2, [r0, #0]
    avg_adc1ch1 = (samples1[1] + samples1[3] + samples1[5] + samples1[7]) / 4;
 8001d82:	800b      	strh	r3, [r1, #0]
}
 8001d84:	4770      	bx	lr
 8001d86:	bf00      	nop
 8001d88:	20000ae8 	.word	0x20000ae8
 8001d8c:	2000090c 	.word	0x2000090c
 8001d90:	2000090e 	.word	0x2000090e
	...

08001da0 <adcerrorcallback.lto_priv.53>:
static void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 8001da0:	4770      	bx	lr
 8001da2:	bf00      	nop
	...

08001db0 <chCoreAllocAlignedI.lto_priv.39>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8001db0:	b4f0      	push	{r4, r5, r6, r7}

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001db2:	4e0b      	ldr	r6, [pc, #44]	; (8001de0 <chCoreAllocAlignedI.lto_priv.39+0x30>)
 8001db4:	6837      	ldr	r7, [r6, #0]
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8001db6:	6872      	ldr	r2, [r6, #4]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001db8:	1e7c      	subs	r4, r7, #1
  size = MEM_ALIGN_NEXT(size, align);
 8001dba:	1e4b      	subs	r3, r1, #1
 8001dbc:	424d      	negs	r5, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001dbe:	440c      	add	r4, r1
  size = MEM_ALIGN_NEXT(size, align);
 8001dc0:	1819      	adds	r1, r3, r0
 8001dc2:	4029      	ands	r1, r5
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001dc4:	ea04 0005 	and.w	r0, r4, r5
  next = p + size;
 8001dc8:	4401      	add	r1, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8001dca:	4291      	cmp	r1, r2
 8001dcc:	d804      	bhi.n	8001dd8 <chCoreAllocAlignedI.lto_priv.39+0x28>
 8001dce:	428f      	cmp	r7, r1
 8001dd0:	d802      	bhi.n	8001dd8 <chCoreAllocAlignedI.lto_priv.39+0x28>
    return NULL;
  }

  ch_memcore.nextmem = next;
 8001dd2:	6031      	str	r1, [r6, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 8001dd4:	bcf0      	pop	{r4, r5, r6, r7}
 8001dd6:	4770      	bx	lr
    return NULL;
 8001dd8:	2000      	movs	r0, #0
 8001dda:	bcf0      	pop	{r4, r5, r6, r7}
 8001ddc:	4770      	bx	lr
 8001dde:	bf00      	nop
 8001de0:	20000a38 	.word	0x20000a38
	...

08001df0 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8001df0:	b4f0      	push	{r4, r5, r6, r7}
 8001df2:	2320      	movs	r3, #32
 8001df4:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001df8:	4d0d      	ldr	r5, [pc, #52]	; (8001e30 <chCoreAllocAlignedWithOffset+0x40>)
 8001dfa:	682f      	ldr	r7, [r5, #0]
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8001dfc:	686c      	ldr	r4, [r5, #4]
 8001dfe:	1e4e      	subs	r6, r1, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001e00:	443a      	add	r2, r7
  size = MEM_ALIGN_NEXT(size, align);
 8001e02:	1983      	adds	r3, r0, r6
 8001e04:	4249      	negs	r1, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001e06:	1990      	adds	r0, r2, r6
  size = MEM_ALIGN_NEXT(size, align);
 8001e08:	400b      	ands	r3, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8001e0a:	4008      	ands	r0, r1
  next = p + size;
 8001e0c:	4403      	add	r3, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8001e0e:	42a3      	cmp	r3, r4
 8001e10:	d807      	bhi.n	8001e22 <chCoreAllocAlignedWithOffset+0x32>
 8001e12:	429f      	cmp	r7, r3
 8001e14:	d805      	bhi.n	8001e22 <chCoreAllocAlignedWithOffset+0x32>
  ch_memcore.nextmem = next;
 8001e16:	602b      	str	r3, [r5, #0]
 8001e18:	2300      	movs	r3, #0
 8001e1a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
 8001e1e:	bcf0      	pop	{r4, r5, r6, r7}
 8001e20:	4770      	bx	lr
    return NULL;
 8001e22:	2000      	movs	r0, #0
 8001e24:	2300      	movs	r3, #0
 8001e26:	f383 8811 	msr	BASEPRI, r3
}
 8001e2a:	bcf0      	pop	{r4, r5, r6, r7}
 8001e2c:	4770      	bx	lr
 8001e2e:	bf00      	nop
 8001e30:	20000a38 	.word	0x20000a38
	...

08001e40 <wakeup>:
 8001e40:	2320      	movs	r3, #32
 8001e42:	f383 8811 	msr	BASEPRI, r3
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8001e46:	f890 3020 	ldrb.w	r3, [r0, #32]
 8001e4a:	2b07      	cmp	r3, #7
 8001e4c:	d80e      	bhi.n	8001e6c <wakeup+0x2c>
 8001e4e:	e8df f003 	tbb	[pc, r3]
 8001e52:	0d28      	.short	0x0d28
 8001e54:	0408240d 	.word	0x0408240d
 8001e58:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8001e5a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8001e5c:	6893      	ldr	r3, [r2, #8]
 8001e5e:	3301      	adds	r3, #1
 8001e60:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001e62:	e890 000c 	ldmia.w	r0, {r2, r3}
 8001e66:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001e68:	6802      	ldr	r2, [r0, #0]
 8001e6a:	6053      	str	r3, [r2, #4]
static void wakeup(void *p) {
 8001e6c:	b410      	push	{r4}
  tp->state = CH_STATE_READY;
 8001e6e:	2200      	movs	r2, #0
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8001e70:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8001e74:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8001e76:	4b0d      	ldr	r3, [pc, #52]	; (8001eac <wakeup+0x6c>)
  tp->u.rdymsg = MSG_TIMEOUT;
 8001e78:	6244      	str	r4, [r0, #36]	; 0x24
  tp->state = CH_STATE_READY;
 8001e7a:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 8001e7e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001e80:	689a      	ldr	r2, [r3, #8]
 8001e82:	428a      	cmp	r2, r1
 8001e84:	d2fb      	bcs.n	8001e7e <wakeup+0x3e>
  tp->queue.prev             = cp->queue.prev;
 8001e86:	685a      	ldr	r2, [r3, #4]
 8001e88:	6042      	str	r2, [r0, #4]
  tp->queue.next             = cp;
 8001e8a:	6003      	str	r3, [r0, #0]
 8001e8c:	2100      	movs	r1, #0
  tp->queue.prev->queue.next = tp;
 8001e8e:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8001e90:	6058      	str	r0, [r3, #4]
 8001e92:	f381 8811 	msr	BASEPRI, r1
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001e96:	bc10      	pop	{r4}
 8001e98:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 8001e9a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001e9c:	2200      	movs	r2, #0
 8001e9e:	601a      	str	r2, [r3, #0]
 8001ea0:	e7e4      	b.n	8001e6c <wakeup+0x2c>
 8001ea2:	2300      	movs	r3, #0
 8001ea4:	f383 8811 	msr	BASEPRI, r3
 8001ea8:	4770      	bx	lr
 8001eaa:	bf00      	nop
 8001eac:	200010c8 	.word	0x200010c8

08001eb0 <_idle_thread.lto_priv.43>:
static void _idle_thread(void *p) {
 8001eb0:	e7fe      	b.n	8001eb0 <_idle_thread.lto_priv.43>
 8001eb2:	bf00      	nop
	...

08001ec0 <_port_irq_epilogue>:
 8001ec0:	2320      	movs	r3, #32
 8001ec2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8001ec6:	4b0f      	ldr	r3, [pc, #60]	; (8001f04 <_port_irq_epilogue+0x44>)
 8001ec8:	685b      	ldr	r3, [r3, #4]
 8001eca:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8001ece:	d102      	bne.n	8001ed6 <_port_irq_epilogue+0x16>
 8001ed0:	f383 8811 	msr	BASEPRI, r3
 8001ed4:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8001ed6:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8001eda:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8001ede:	f843 2c04 	str.w	r2, [r3, #-4]
    ctxp--;
 8001ee2:	f1a3 0220 	sub.w	r2, r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8001ee6:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8001eea:	4a07      	ldr	r2, [pc, #28]	; (8001f08 <_port_irq_epilogue+0x48>)
 8001eec:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 8001eee:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001ef0:	6889      	ldr	r1, [r1, #8]
 8001ef2:	6892      	ldr	r2, [r2, #8]
 8001ef4:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8001ef6:	bf8c      	ite	hi
 8001ef8:	4a04      	ldrhi	r2, [pc, #16]	; (8001f0c <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001efa:	4a05      	ldrls	r2, [pc, #20]	; (8001f10 <_port_irq_epilogue+0x50>)
 8001efc:	f843 2c08 	str.w	r2, [r3, #-8]
 8001f00:	4770      	bx	lr
 8001f02:	bf00      	nop
 8001f04:	e000ed00 	.word	0xe000ed00
 8001f08:	200010c8 	.word	0x200010c8
 8001f0c:	080002e1 	.word	0x080002e1
 8001f10:	080002e4 	.word	0x080002e4
	...

08001f20 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8001f20:	f3ef 8309 	mrs	r3, PSP
  ctxp++;
 8001f24:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8001f26:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001f2a:	2300      	movs	r3, #0
 8001f2c:	f383 8811 	msr	BASEPRI, r3
 8001f30:	4770      	bx	lr
 8001f32:	bf00      	nop
	...

08001f40 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8001f40:	4b0e      	ldr	r3, [pc, #56]	; (8001f7c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001f42:	4a0f      	ldr	r2, [pc, #60]	; (8001f80 <chTMStopMeasurementX+0x40>)
 8001f44:	685b      	ldr	r3, [r3, #4]
  tmp->n++;
 8001f46:	68c1      	ldr	r1, [r0, #12]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8001f48:	b4f0      	push	{r4, r5, r6, r7}
  tmp->last = (now - tmp->last) - offset;
 8001f4a:	6887      	ldr	r7, [r0, #8]
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001f4c:	6f56      	ldr	r6, [r2, #116]	; 0x74
  if (tmp->last > tmp->worst) {
 8001f4e:	6842      	ldr	r2, [r0, #4]
  tmp->cumulative += (rttime_t)tmp->last;
 8001f50:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 8001f54:	1bdb      	subs	r3, r3, r7
 8001f56:	1b9b      	subs	r3, r3, r6
  tmp->cumulative += (rttime_t)tmp->last;
 8001f58:	18e4      	adds	r4, r4, r3
 8001f5a:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8001f5e:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 8001f60:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
 8001f62:	bf88      	it	hi
 8001f64:	6043      	strhi	r3, [r0, #4]
  tmp->n++;
 8001f66:	3101      	adds	r1, #1
  if (tmp->last < tmp->best) {
 8001f68:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 8001f6a:	e9c0 4504 	strd	r4, r5, [r0, #16]
  tmp->n++;
 8001f6e:	60c1      	str	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8001f70:	6083      	str	r3, [r0, #8]
    tmp->best = tmp->last;
 8001f72:	bf38      	it	cc
 8001f74:	6003      	strcc	r3, [r0, #0]
}
 8001f76:	bcf0      	pop	{r4, r5, r6, r7}
 8001f78:	4770      	bx	lr
 8001f7a:	bf00      	nop
 8001f7c:	e0001000 	.word	0xe0001000
 8001f80:	200010c8 	.word	0x200010c8
	...

08001f90 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 8001f90:	4a0e      	ldr	r2, [pc, #56]	; (8001fcc <chSchDoReschedule+0x3c>)
  thread_t *tp = tqp->next;
 8001f92:	6810      	ldr	r0, [r2, #0]
  tqp->next             = tp->queue.next;
 8001f94:	6803      	ldr	r3, [r0, #0]
void chSchDoReschedule(void) {
 8001f96:	b430      	push	{r4, r5}

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8001f98:	2101      	movs	r1, #1
  thread_t *otp = currp;
 8001f9a:	6994      	ldr	r4, [r2, #24]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001f9c:	605a      	str	r2, [r3, #4]
  tp->state = CH_STATE_READY;
 8001f9e:	2500      	movs	r5, #0
  currp->state = CH_STATE_CURRENT;
 8001fa0:	f880 1020 	strb.w	r1, [r0, #32]

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
 8001fa4:	68a1      	ldr	r1, [r4, #8]
  tqp->next             = tp->queue.next;
 8001fa6:	6013      	str	r3, [r2, #0]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001fa8:	6190      	str	r0, [r2, #24]
  tp->state = CH_STATE_READY;
 8001faa:	f884 5020 	strb.w	r5, [r4, #32]
 8001fae:	e000      	b.n	8001fb2 <chSchDoReschedule+0x22>
 8001fb0:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8001fb2:	689a      	ldr	r2, [r3, #8]
 8001fb4:	4291      	cmp	r1, r2
 8001fb6:	d3fb      	bcc.n	8001fb0 <chSchDoReschedule+0x20>
  tp->queue.prev             = cp->queue.prev;
 8001fb8:	685a      	ldr	r2, [r3, #4]
 8001fba:	6062      	str	r2, [r4, #4]
  tp->queue.next             = cp;
 8001fbc:	6023      	str	r3, [r4, #0]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001fbe:	4621      	mov	r1, r4
  tp->queue.prev->queue.next = tp;
 8001fc0:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8001fc2:	605c      	str	r4, [r3, #4]
}
 8001fc4:	bc30      	pop	{r4, r5}
  chSysSwitch(currp, otp);
 8001fc6:	f7fe b97b 	b.w	80002c0 <_port_switch>
 8001fca:	bf00      	nop
 8001fcc:	200010c8 	.word	0x200010c8

08001fd0 <chSchGoSleepS>:
  thread_t *otp = currp;
 8001fd0:	4b08      	ldr	r3, [pc, #32]	; (8001ff4 <chSchGoSleepS+0x24>)
 8001fd2:	6999      	ldr	r1, [r3, #24]
  thread_t *tp = tqp->next;
 8001fd4:	681a      	ldr	r2, [r3, #0]
void chSchGoSleepS(tstate_t newstate) {
 8001fd6:	b410      	push	{r4}
  otp->state = newstate;
 8001fd8:	f881 0020 	strb.w	r0, [r1, #32]
  tqp->next             = tp->queue.next;
 8001fdc:	6810      	ldr	r0, [r2, #0]
 8001fde:	6018      	str	r0, [r3, #0]
  currp->state = CH_STATE_CURRENT;
 8001fe0:	2401      	movs	r4, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8001fe2:	6043      	str	r3, [r0, #4]
 8001fe4:	f882 4020 	strb.w	r4, [r2, #32]
  chSysSwitch(currp, otp);
 8001fe8:	4610      	mov	r0, r2
}
 8001fea:	bc10      	pop	{r4}
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001fec:	619a      	str	r2, [r3, #24]
  chSysSwitch(currp, otp);
 8001fee:	f7fe b967 	b.w	80002c0 <_port_switch>
 8001ff2:	bf00      	nop
 8001ff4:	200010c8 	.word	0x200010c8
	...

08002000 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8002000:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (TIME_INFINITE != timeout) {
 8002002:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8002004:	b087      	sub	sp, #28
  if (TIME_INFINITE != timeout) {
 8002006:	d04c      	beq.n	80020a2 <chSchGoSleepTimeoutS+0xa2>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 8002008:	4c41      	ldr	r4, [pc, #260]	; (8002110 <chSchGoSleepTimeoutS+0x110>)
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800200a:	4625      	mov	r5, r4
  vtp->par = par;
 800200c:	69a3      	ldr	r3, [r4, #24]
 800200e:	9305      	str	r3, [sp, #20]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002010:	f855 3f1c 	ldr.w	r3, [r5, #28]!
 8002014:	2902      	cmp	r1, #2
  return (systime_t)STM32_ST_TIM->CNT;
 8002016:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
 800201a:	4607      	mov	r7, r0
 800201c:	bf38      	it	cc
 800201e:	2102      	movcc	r1, #2
  vtp->func = vtfunc;
 8002020:	483c      	ldr	r0, [pc, #240]	; (8002114 <chSchGoSleepTimeoutS+0x114>)
 8002022:	f8de 2024 	ldr.w	r2, [lr, #36]	; 0x24
 8002026:	9004      	str	r0, [sp, #16]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002028:	42ab      	cmp	r3, r5
 800202a:	d05c      	beq.n	80020e6 <chSchGoSleepTimeoutS+0xe6>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 800202c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  return (sysinterval_t)((systime_t)(end - start));
 800202e:	1a12      	subs	r2, r2, r0

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8002030:	1889      	adds	r1, r1, r2
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8002032:	689a      	ldr	r2, [r3, #8]
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8002034:	d231      	bcs.n	800209a <chSchGoSleepTimeoutS+0x9a>
      p = p->next;
    }
    else if (delta < p->delta) {
 8002036:	4291      	cmp	r1, r2
  return systime + (systime_t)interval;
 8002038:	bf3c      	itt	cc
 800203a:	1840      	addcc	r0, r0, r1
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800203c:	f8ce 0034 	strcc.w	r0, [lr, #52]	; 0x34
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8002040:	4291      	cmp	r1, r2
 8002042:	d904      	bls.n	800204e <chSchGoSleepTimeoutS+0x4e>
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
    p = p->next;
 8002044:	681b      	ldr	r3, [r3, #0]
    delta -= p->delta;
 8002046:	1a89      	subs	r1, r1, r2
  while (p->delta < delta) {
 8002048:	689a      	ldr	r2, [r3, #8]
 800204a:	428a      	cmp	r2, r1
 800204c:	d3fa      	bcc.n	8002044 <chSchGoSleepTimeoutS+0x44>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 800204e:	685a      	ldr	r2, [r3, #4]
 8002050:	9202      	str	r2, [sp, #8]
  vtp->prev->next = vtp;
 8002052:	ae01      	add	r6, sp, #4
  vtp->next = p;
 8002054:	9301      	str	r3, [sp, #4]
  vtp->prev->next = vtp;
 8002056:	6016      	str	r6, [r2, #0]
  p->prev = vtp;
 8002058:	605e      	str	r6, [r3, #4]
  vtp->delta = delta;
 800205a:	9103      	str	r1, [sp, #12]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 800205c:	689a      	ldr	r2, [r3, #8]
 800205e:	1a51      	subs	r1, r2, r1

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 8002060:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  p->delta -= delta;
 8002064:	6099      	str	r1, [r3, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 8002066:	6262      	str	r2, [r4, #36]	; 0x24
    chSchGoSleepS(newstate);
 8002068:	4638      	mov	r0, r7
 800206a:	f7ff ffb1 	bl	8001fd0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800206e:	9b04      	ldr	r3, [sp, #16]
 8002070:	b17b      	cbz	r3, 8002092 <chSchGoSleepTimeoutS+0x92>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8002072:	69e3      	ldr	r3, [r4, #28]
 8002074:	42b3      	cmp	r3, r6
 8002076:	d01b      	beq.n	80020b0 <chSchGoSleepTimeoutS+0xb0>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8002078:	9a02      	ldr	r2, [sp, #8]
 800207a:	9b01      	ldr	r3, [sp, #4]
 800207c:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 800207e:	9b01      	ldr	r3, [sp, #4]
    vtp->func = NULL;
 8002080:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002082:	42ab      	cmp	r3, r5
    vtp->next->prev = vtp->prev;
 8002084:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8002086:	9104      	str	r1, [sp, #16]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002088:	d003      	beq.n	8002092 <chSchGoSleepTimeoutS+0x92>
      vtp->next->delta += vtp->delta;
 800208a:	689a      	ldr	r2, [r3, #8]
 800208c:	9903      	ldr	r1, [sp, #12]
 800208e:	440a      	add	r2, r1
 8002090:	609a      	str	r2, [r3, #8]
  return currp->u.rdymsg;
 8002092:	69a3      	ldr	r3, [r4, #24]
}
 8002094:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002096:	b007      	add	sp, #28
 8002098:	bdf0      	pop	{r4, r5, r6, r7, pc}
      p = p->next;
 800209a:	681b      	ldr	r3, [r3, #0]
      delta -= p->delta;
 800209c:	1a89      	subs	r1, r1, r2
 800209e:	689a      	ldr	r2, [r3, #8]
 80020a0:	e7ce      	b.n	8002040 <chSchGoSleepTimeoutS+0x40>
 80020a2:	4c1b      	ldr	r4, [pc, #108]	; (8002110 <chSchGoSleepTimeoutS+0x110>)
    chSchGoSleepS(newstate);
 80020a4:	f7ff ff94 	bl	8001fd0 <chSchGoSleepS>
  return currp->u.rdymsg;
 80020a8:	69a3      	ldr	r3, [r4, #24]
}
 80020aa:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80020ac:	b007      	add	sp, #28
 80020ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 80020b0:	9b01      	ldr	r3, [sp, #4]
 80020b2:	61e3      	str	r3, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 80020b4:	2200      	movs	r2, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80020b6:	42ab      	cmp	r3, r5
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 80020b8:	605d      	str	r5, [r3, #4]
  vtp->func = NULL;
 80020ba:	9204      	str	r2, [sp, #16]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80020bc:	d024      	beq.n	8002108 <chSchGoSleepTimeoutS+0x108>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80020be:	689a      	ldr	r2, [r3, #8]
 80020c0:	9803      	ldr	r0, [sp, #12]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 80020c2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 80020c4:	4402      	add	r2, r0
  return (systime_t)STM32_ST_TIM->CNT;
 80020c6:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80020ca:	609a      	str	r2, [r3, #8]
 80020cc:	6a43      	ldr	r3, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80020ce:	1a5b      	subs	r3, r3, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 80020d0:	429a      	cmp	r2, r3
 80020d2:	d9de      	bls.n	8002092 <chSchGoSleepTimeoutS+0x92>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 80020d4:	1ad0      	subs	r0, r2, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 80020d6:	2801      	cmp	r0, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80020d8:	bf98      	it	ls
 80020da:	1c9a      	addls	r2, r3, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80020dc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 80020e0:	440a      	add	r2, r1
 80020e2:	635a      	str	r2, [r3, #52]	; 0x34
 80020e4:	e7d5      	b.n	8002092 <chSchGoSleepTimeoutS+0x92>
      ch.vtlist.lasttime = now;
 80020e6:	62a2      	str	r2, [r4, #40]	; 0x28
 80020e8:	1888      	adds	r0, r1, r2
      ch.vtlist.next = vtp;
 80020ea:	ae01      	add	r6, sp, #4
  STM32_ST_TIM->SR     = 0;
 80020ec:	2200      	movs	r2, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80020ee:	2302      	movs	r3, #2
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 80020f0:	9501      	str	r5, [sp, #4]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 80020f2:	9502      	str	r5, [sp, #8]
      vtp->delta = delay;
 80020f4:	9103      	str	r1, [sp, #12]
      ch.vtlist.next = vtp;
 80020f6:	61e6      	str	r6, [r4, #28]
      ch.vtlist.prev = vtp;
 80020f8:	6226      	str	r6, [r4, #32]
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80020fa:	f8ce 0034 	str.w	r0, [lr, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80020fe:	f8ce 2010 	str.w	r2, [lr, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8002102:	f8ce 300c 	str.w	r3, [lr, #12]
 8002106:	e7af      	b.n	8002068 <chSchGoSleepTimeoutS+0x68>
  STM32_ST_TIM->DIER = 0;
 8002108:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800210c:	60da      	str	r2, [r3, #12]
 800210e:	e7c0      	b.n	8002092 <chSchGoSleepTimeoutS+0x92>
 8002110:	200010c8 	.word	0x200010c8
 8002114:	08001e41 	.word	0x08001e41
	...

08002120 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
 8002120:	b161      	cbz	r1, 800213c <chThdEnqueueTimeoutS+0x1c>
  queue_insert(currp, tqp);
 8002122:	4b08      	ldr	r3, [pc, #32]	; (8002144 <chThdEnqueueTimeoutS+0x24>)
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8002124:	b410      	push	{r4}
 8002126:	4602      	mov	r2, r0
  tp->queue.prev             = tqp->prev;
 8002128:	6844      	ldr	r4, [r0, #4]
  queue_insert(currp, tqp);
 800212a:	699b      	ldr	r3, [r3, #24]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800212c:	2004      	movs	r0, #4
 800212e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->queue.prev->queue.next = tp;
 8002132:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 8002134:	6053      	str	r3, [r2, #4]
}
 8002136:	bc10      	pop	{r4}
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8002138:	f7ff bf62 	b.w	8002000 <chSchGoSleepTimeoutS>
}
 800213c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8002140:	4770      	bx	lr
 8002142:	bf00      	nop
 8002144:	200010c8 	.word	0x200010c8
	...

08002150 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
 8002150:	b508      	push	{r3, lr}
 8002152:	4601      	mov	r1, r0
 8002154:	2320      	movs	r3, #32
 8002156:	f383 8811 	msr	BASEPRI, r3
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 800215a:	2008      	movs	r0, #8
 800215c:	f7ff ff50 	bl	8002000 <chSchGoSleepTimeoutS>
 8002160:	2300      	movs	r3, #0
 8002162:	f383 8811 	msr	BASEPRI, r3
 8002166:	bd08      	pop	{r3, pc}
	...

08002170 <chSchReadyI>:
  tp->state = CH_STATE_READY;
 8002170:	2200      	movs	r2, #0
 8002172:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8002174:	4b08      	ldr	r3, [pc, #32]	; (8002198 <chSchReadyI+0x28>)
thread_t *chSchReadyI(thread_t *tp) {
 8002176:	b410      	push	{r4}
 8002178:	4604      	mov	r4, r0
  tp->state = CH_STATE_READY;
 800217a:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 800217e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8002180:	689a      	ldr	r2, [r3, #8]
 8002182:	428a      	cmp	r2, r1
 8002184:	d2fb      	bcs.n	800217e <chSchReadyI+0xe>
  tp->queue.prev             = cp->queue.prev;
 8002186:	685a      	ldr	r2, [r3, #4]
 8002188:	6062      	str	r2, [r4, #4]
  tp->queue.next             = cp;
 800218a:	6023      	str	r3, [r4, #0]
}
 800218c:	4620      	mov	r0, r4
  tp->queue.prev->queue.next = tp;
 800218e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8002190:	605c      	str	r4, [r3, #4]
}
 8002192:	bc10      	pop	{r4}
 8002194:	4770      	bx	lr
 8002196:	bf00      	nop
 8002198:	200010c8 	.word	0x200010c8
 800219c:	00000000 	.word	0x00000000

080021a0 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80021a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  elp = esp->next;
 80021a2:	6804      	ldr	r4, [r0, #0]
  while (elp != (event_listener_t *)esp) {
 80021a4:	42a0      	cmp	r0, r4
 80021a6:	d022      	beq.n	80021ee <chEvtBroadcastFlagsI+0x4e>
 80021a8:	460d      	mov	r5, r1
 80021aa:	4607      	mov	r7, r0
    tp->u.rdymsg = MSG_OK;
 80021ac:	2600      	movs	r6, #0
 80021ae:	e002      	b.n	80021b6 <chEvtBroadcastFlagsI+0x16>
    elp = elp->next;
 80021b0:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80021b2:	42a7      	cmp	r7, r4
 80021b4:	d01b      	beq.n	80021ee <chEvtBroadcastFlagsI+0x4e>
    elp->flags |= flags;
 80021b6:	68e3      	ldr	r3, [r4, #12]
 80021b8:	432b      	orrs	r3, r5
 80021ba:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 80021bc:	b115      	cbz	r5, 80021c4 <chEvtBroadcastFlagsI+0x24>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 80021be:	6922      	ldr	r2, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 80021c0:	4213      	tst	r3, r2
 80021c2:	d0f5      	beq.n	80021b0 <chEvtBroadcastFlagsI+0x10>
      chEvtSignalI(elp->listener, elp->events);
 80021c4:	6860      	ldr	r0, [r4, #4]
  tp->epending |= events;
 80021c6:	68a3      	ldr	r3, [r4, #8]
 80021c8:	6b41      	ldr	r1, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 80021ca:	f890 2020 	ldrb.w	r2, [r0, #32]
  tp->epending |= events;
 80021ce:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
 80021d0:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 80021d2:	6343      	str	r3, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 80021d4:	d00c      	beq.n	80021f0 <chEvtBroadcastFlagsI+0x50>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80021d6:	2a0b      	cmp	r2, #11
 80021d8:	d1ea      	bne.n	80021b0 <chEvtBroadcastFlagsI+0x10>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 80021da:	6a42      	ldr	r2, [r0, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 80021dc:	ea32 0303 	bics.w	r3, r2, r3
 80021e0:	d1e6      	bne.n	80021b0 <chEvtBroadcastFlagsI+0x10>
    tp->u.rdymsg = MSG_OK;
 80021e2:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 80021e4:	f7ff ffc4 	bl	8002170 <chSchReadyI>
    elp = elp->next;
 80021e8:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80021ea:	42a7      	cmp	r7, r4
 80021ec:	d1e3      	bne.n	80021b6 <chEvtBroadcastFlagsI+0x16>
 80021ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80021f0:	6a42      	ldr	r2, [r0, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 80021f2:	4213      	tst	r3, r2
 80021f4:	d0dc      	beq.n	80021b0 <chEvtBroadcastFlagsI+0x10>
    tp->u.rdymsg = MSG_OK;
 80021f6:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 80021f8:	f7ff ffba 	bl	8002170 <chSchReadyI>
 80021fc:	e7f4      	b.n	80021e8 <chEvtBroadcastFlagsI+0x48>
 80021fe:	bf00      	nop

08002200 <button1_cb.lto_priv.42>:
static void button1_cb(void *arg) {
 8002200:	b508      	push	{r3, lr}
 8002202:	2320      	movs	r3, #32
 8002204:	f383 8811 	msr	BASEPRI, r3
  if (palReadLine(BUTTON1) == BUTTON_PRESSED) {
 8002208:	4b09      	ldr	r3, [pc, #36]	; (8002230 <button1_cb.lto_priv.42+0x30>)
 800220a:	6919      	ldr	r1, [r3, #16]
 800220c:	f3c1 11c0 	ubfx	r1, r1, #7, #1
 8002210:	b931      	cbnz	r1, 8002220 <button1_cb.lto_priv.42+0x20>
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8002212:	4808      	ldr	r0, [pc, #32]	; (8002234 <button1_cb.lto_priv.42+0x34>)
 8002214:	f7ff ffc4 	bl	80021a0 <chEvtBroadcastFlagsI>
 8002218:	2300      	movs	r3, #0
 800221a:	f383 8811 	msr	BASEPRI, r3
 800221e:	bd08      	pop	{r3, pc}
 8002220:	2100      	movs	r1, #0
 8002222:	4805      	ldr	r0, [pc, #20]	; (8002238 <button1_cb.lto_priv.42+0x38>)
 8002224:	f7ff ffbc 	bl	80021a0 <chEvtBroadcastFlagsI>
 8002228:	2300      	movs	r3, #0
 800222a:	f383 8811 	msr	BASEPRI, r3
 800222e:	bd08      	pop	{r3, pc}
 8002230:	40020400 	.word	0x40020400
 8002234:	20000914 	.word	0x20000914
 8002238:	20000910 	.word	0x20000910
 800223c:	00000000 	.word	0x00000000

08002240 <chThdExit>:
void chThdExit(msg_t msg) {
 8002240:	b538      	push	{r3, r4, r5, lr}
 8002242:	2220      	movs	r2, #32
 8002244:	4603      	mov	r3, r0
 8002246:	f382 8811 	msr	BASEPRI, r2
  thread_t *tp = currp;
 800224a:	4a10      	ldr	r2, [pc, #64]	; (800228c <chThdExit+0x4c>)
 800224c:	6994      	ldr	r4, [r2, #24]
  return (bool)(tlp->next != (thread_t *)tlp);
 800224e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  tp->u.exitcode = msg;
 8002250:	6263      	str	r3, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
 8002252:	f104 0528 	add.w	r5, r4, #40	; 0x28
 8002256:	4285      	cmp	r5, r0
 8002258:	d006      	beq.n	8002268 <chThdExit+0x28>
  tlp->next = tp->queue.next;
 800225a:	6803      	ldr	r3, [r0, #0]
 800225c:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 800225e:	f7ff ff87 	bl	8002170 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 8002262:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8002264:	42a8      	cmp	r0, r5
 8002266:	d1f8      	bne.n	800225a <chThdExit+0x1a>
  if ((tp->refs == (trefs_t)0) &&
 8002268:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 800226c:	b943      	cbnz	r3, 8002280 <chThdExit+0x40>
 800226e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8002272:	079b      	lsls	r3, r3, #30
 8002274:	d104      	bne.n	8002280 <chThdExit+0x40>
    REG_REMOVE(tp);
 8002276:	6963      	ldr	r3, [r4, #20]
 8002278:	6922      	ldr	r2, [r4, #16]
 800227a:	611a      	str	r2, [r3, #16]
 800227c:	6922      	ldr	r2, [r4, #16]
 800227e:	6153      	str	r3, [r2, #20]
  chSchGoSleepS(CH_STATE_FINAL);
 8002280:	200f      	movs	r0, #15
}
 8002282:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 8002286:	f7ff bea3 	b.w	8001fd0 <chSchGoSleepS>
 800228a:	bf00      	nop
 800228c:	200010c8 	.word	0x200010c8

08002290 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8002290:	4a86      	ldr	r2, [pc, #536]	; (80024ac <__early_init+0x21c>)
  gpiop->OTYPER  = config->otyper;
 8002292:	f8df c24c 	ldr.w	ip, [pc, #588]	; 80024e0 <__early_init+0x250>
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8002296:	6911      	ldr	r1, [r2, #16]
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8002298:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  rccResetAHB1(STM32_GPIO_EN_MASK);
 800229c:	f240 19ff 	movw	r9, #511	; 0x1ff
 80022a0:	2300      	movs	r3, #0
 80022a2:	ea41 0109 	orr.w	r1, r1, r9
 80022a6:	6111      	str	r1, [r2, #16]
 80022a8:	6113      	str	r3, [r2, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 80022aa:	6b11      	ldr	r1, [r2, #48]	; 0x30
  gpiop->OTYPER  = config->otyper;
 80022ac:	4f80      	ldr	r7, [pc, #512]	; (80024b0 <__early_init+0x220>)
 80022ae:	4e81      	ldr	r6, [pc, #516]	; (80024b4 <__early_init+0x224>)
 80022b0:	4d81      	ldr	r5, [pc, #516]	; (80024b8 <__early_init+0x228>)
 80022b2:	f8df e230 	ldr.w	lr, [pc, #560]	; 80024e4 <__early_init+0x254>
 80022b6:	4c81      	ldr	r4, [pc, #516]	; (80024bc <__early_init+0x22c>)
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 80022b8:	ea41 0109 	orr.w	r1, r1, r9
 80022bc:	6311      	str	r1, [r2, #48]	; 0x30
 80022be:	6d11      	ldr	r1, [r2, #80]	; 0x50
 80022c0:	ea41 0909 	orr.w	r9, r1, r9
 80022c4:	f8c2 9050 	str.w	r9, [r2, #80]	; 0x50
  gpiop->OSPEEDR = config->ospeedr;
 80022c8:	f46f 49a8 	mvn.w	r9, #21504	; 0x5400
  gpiop->OTYPER  = config->otyper;
 80022cc:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80022d0:	f8cc 9008 	str.w	r9, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 80022d4:	f8df 9210 	ldr.w	r9, [pc, #528]	; 80024e8 <__early_init+0x258>
 80022d8:	f8cc 900c 	str.w	r9, [ip, #12]
  gpiop->ODR     = config->odr;
 80022dc:	f64f 71ff 	movw	r1, #65535	; 0xffff
  gpiop->AFRL    = config->afrl;
 80022e0:	f8df 9208 	ldr.w	r9, [pc, #520]	; 80024ec <__early_init+0x25c>
  gpiop->ODR     = config->odr;
 80022e4:	f8cc 1014 	str.w	r1, [ip, #20]
  gpiop->AFRL    = config->afrl;
 80022e8:	f8cc 9020 	str.w	r9, [ip, #32]
  gpiop->AFRH    = config->afrh;
 80022ec:	f8df 9200 	ldr.w	r9, [pc, #512]	; 80024f0 <__early_init+0x260>
 80022f0:	f8cc 9024 	str.w	r9, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80022f4:	f109 592a 	add.w	r9, r9, #713031680	; 0x2a800000
 80022f8:	f509 19b0 	add.w	r9, r9, #1441792	; 0x160000
 80022fc:	f8cc 9000 	str.w	r9, [ip]
  gpiop->OTYPER  = config->otyper;
 8002300:	f44f 7c10 	mov.w	ip, #576	; 0x240
 8002304:	f8c7 c004 	str.w	ip, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002308:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  gpiop->PUPDR   = config->pupdr;
 800230c:	f8df c1e4 	ldr.w	ip, [pc, #484]	; 80024f4 <__early_init+0x264>
  gpiop->OSPEEDR = config->ospeedr;
 8002310:	60b8      	str	r0, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8002312:	f8c7 c00c 	str.w	ip, [r7, #12]
  gpiop->AFRL    = config->afrl;
 8002316:	f04f 6c80 	mov.w	ip, #67108864	; 0x4000000
  gpiop->ODR     = config->odr;
 800231a:	6179      	str	r1, [r7, #20]
  gpiop->AFRL    = config->afrl;
 800231c:	f8c7 c020 	str.w	ip, [r7, #32]
  gpiop->MODER   = config->moder;
 8002320:	f8df c1d4 	ldr.w	ip, [pc, #468]	; 80024f8 <__early_init+0x268>
  gpiop->AFRH    = config->afrh;
 8002324:	f04f 0840 	mov.w	r8, #64	; 0x40
 8002328:	f8c7 8024 	str.w	r8, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800232c:	f8c7 c000 	str.w	ip, [r7]
  gpiop->PUPDR   = config->pupdr;
 8002330:	f10c 4caa 	add.w	ip, ip, #1426063360	; 0x55000000
 8002334:	f5ac 0c43 	sub.w	ip, ip, #12779520	; 0xc30000
 8002338:	f6ac 3c2c 	subw	ip, ip, #2860	; 0xb2c
  gpiop->OTYPER  = config->otyper;
 800233c:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800233e:	60b0      	str	r0, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8002340:	f8c6 c00c 	str.w	ip, [r6, #12]
  gpiop->AFRL    = config->afrl;
 8002344:	f04f 4cc0 	mov.w	ip, #1610612736	; 0x60000000
  gpiop->ODR     = config->odr;
 8002348:	6171      	str	r1, [r6, #20]
  gpiop->AFRL    = config->afrl;
 800234a:	f8c6 c020 	str.w	ip, [r6, #32]
  gpiop->AFRH    = config->afrh;
 800234e:	f8df c1ac 	ldr.w	ip, [pc, #428]	; 80024fc <__early_init+0x26c>
 8002352:	f8c6 c024 	str.w	ip, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002356:	f8df c1a8 	ldr.w	ip, [pc, #424]	; 8002500 <__early_init+0x270>
 800235a:	f8c6 c000 	str.w	ip, [r6]
  gpiop->PUPDR   = config->pupdr;
 800235e:	f8df c1a4 	ldr.w	ip, [pc, #420]	; 8002504 <__early_init+0x274>
  gpiop->OTYPER  = config->otyper;
 8002362:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002364:	60a8      	str	r0, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 8002366:	f8c5 c00c 	str.w	ip, [r5, #12]
  gpiop->ODR     = config->odr;
 800236a:	f640 7cff 	movw	ip, #4095	; 0xfff
 800236e:	f8c5 c014 	str.w	ip, [r5, #20]
  gpiop->OTYPER  = config->otyper;
 8002372:	f507 5780 	add.w	r7, r7, #4096	; 0x1000
  gpiop->MODER   = config->moder;
 8002376:	f8df c190 	ldr.w	ip, [pc, #400]	; 8002508 <__early_init+0x278>
  gpiop->AFRL    = config->afrl;
 800237a:	622b      	str	r3, [r5, #32]
  gpiop->OTYPER  = config->otyper;
 800237c:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
  gpiop->AFRH    = config->afrh;
 8002380:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002382:	f8c5 c000 	str.w	ip, [r5]
  gpiop->OTYPER  = config->otyper;
 8002386:	f505 5580 	add.w	r5, r5, #4096	; 0x1000
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800238a:	f8df c138 	ldr.w	ip, [pc, #312]	; 80024c4 <__early_init+0x234>
 800238e:	f8ce 3004 	str.w	r3, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002392:	f8ce 0008 	str.w	r0, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 8002396:	f8ce 300c 	str.w	r3, [lr, #12]
  gpiop->ODR     = config->odr;
 800239a:	f8ce 1014 	str.w	r1, [lr, #20]
  gpiop->AFRL    = config->afrl;
 800239e:	f8ce 3020 	str.w	r3, [lr, #32]
  gpiop->AFRH    = config->afrh;
 80023a2:	f8ce 3024 	str.w	r3, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80023a6:	f8ce 8000 	str.w	r8, [lr]
  gpiop->OTYPER  = config->otyper;
 80023aa:	607b      	str	r3, [r7, #4]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 80023ac:	f04f 5e80 	mov.w	lr, #268435456	; 0x10000000
  gpiop->OSPEEDR = config->ospeedr;
 80023b0:	60b8      	str	r0, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 80023b2:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 80023b4:	6179      	str	r1, [r7, #20]
  gpiop->AFRL    = config->afrl;
 80023b6:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 80023b8:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80023ba:	603b      	str	r3, [r7, #0]
  PWR->CR = STM32_VOS;
 80023bc:	f44f 4740 	mov.w	r7, #49152	; 0xc000
  gpiop->OTYPER  = config->otyper;
 80023c0:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80023c2:	60b0      	str	r0, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 80023c4:	60f3      	str	r3, [r6, #12]
  gpiop->ODR     = config->odr;
 80023c6:	6171      	str	r1, [r6, #20]
  gpiop->AFRL    = config->afrl;
 80023c8:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
 80023ca:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80023cc:	6033      	str	r3, [r6, #0]
  gpiop->OTYPER  = config->otyper;
 80023ce:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80023d0:	60a8      	str	r0, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 80023d2:	60eb      	str	r3, [r5, #12]
  gpiop->ODR     = config->odr;
 80023d4:	6169      	str	r1, [r5, #20]
  gpiop->AFRL    = config->afrl;
 80023d6:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
 80023d8:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80023da:	602b      	str	r3, [r5, #0]
  gpiop->OTYPER  = config->otyper;
 80023dc:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80023de:	60a0      	str	r0, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 80023e0:	60e3      	str	r3, [r4, #12]
  gpiop->ODR     = config->odr;
 80023e2:	6161      	str	r1, [r4, #20]
  gpiop->AFRL    = config->afrl;
 80023e4:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 80023e6:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80023e8:	6023      	str	r3, [r4, #0]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 80023ea:	f8c2 e040 	str.w	lr, [r2, #64]	; 0x40
  PWR->CR = STM32_VOS;
 80023ee:	f8cc 7000 	str.w	r7, [ip]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80023f2:	6813      	ldr	r3, [r2, #0]
 80023f4:	f043 0301 	orr.w	r3, r3, #1
 80023f8:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80023fa:	4613      	mov	r3, r2
 80023fc:	681a      	ldr	r2, [r3, #0]
 80023fe:	0794      	lsls	r4, r2, #30
 8002400:	d5fc      	bpl.n	80023fc <__early_init+0x16c>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8002402:	6899      	ldr	r1, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8002404:	4a29      	ldr	r2, [pc, #164]	; (80024ac <__early_init+0x21c>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8002406:	f021 0103 	bic.w	r1, r1, #3
 800240a:	6099      	str	r1, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800240c:	6893      	ldr	r3, [r2, #8]
 800240e:	f013 030c 	ands.w	r3, r3, #12
 8002412:	d1fb      	bne.n	800240c <__early_init+0x17c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8002414:	6810      	ldr	r0, [r2, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8002416:	4925      	ldr	r1, [pc, #148]	; (80024ac <__early_init+0x21c>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8002418:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
 800241c:	6010      	str	r0, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800241e:	6093      	str	r3, [r2, #8]
  RCC->CR |= RCC_CR_HSEON;
 8002420:	6813      	ldr	r3, [r2, #0]
 8002422:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002426:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8002428:	680b      	ldr	r3, [r1, #0]
 800242a:	0398      	lsls	r0, r3, #14
 800242c:	d5fc      	bpl.n	8002428 <__early_init+0x198>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800242e:	6f4b      	ldr	r3, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8002430:	4a1e      	ldr	r2, [pc, #120]	; (80024ac <__early_init+0x21c>)
  RCC->CSR |= RCC_CSR_LSION;
 8002432:	f043 0301 	orr.w	r3, r3, #1
 8002436:	674b      	str	r3, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8002438:	6f53      	ldr	r3, [r2, #116]	; 0x74
 800243a:	0799      	lsls	r1, r3, #30
 800243c:	d5fc      	bpl.n	8002438 <__early_init+0x1a8>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 800243e:	4b20      	ldr	r3, [pc, #128]	; (80024c0 <__early_init+0x230>)
 8002440:	6053      	str	r3, [r2, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8002442:	6813      	ldr	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8002444:	491f      	ldr	r1, [pc, #124]	; (80024c4 <__early_init+0x234>)
  RCC->CR |= RCC_CR_PLLON;
 8002446:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800244a:	6013      	str	r3, [r2, #0]
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800244c:	684b      	ldr	r3, [r1, #4]
 800244e:	045a      	lsls	r2, r3, #17
 8002450:	d5fc      	bpl.n	800244c <__early_init+0x1bc>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8002452:	4a16      	ldr	r2, [pc, #88]	; (80024ac <__early_init+0x21c>)
 8002454:	6813      	ldr	r3, [r2, #0]
 8002456:	019b      	lsls	r3, r3, #6
 8002458:	d5fc      	bpl.n	8002454 <__early_init+0x1c4>

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 800245a:	4b1b      	ldr	r3, [pc, #108]	; (80024c8 <__early_init+0x238>)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 800245c:	491b      	ldr	r1, [pc, #108]	; (80024cc <__early_init+0x23c>)
 800245e:	6091      	str	r1, [r2, #8]
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8002460:	681a      	ldr	r2, [r3, #0]
 8002462:	4b1b      	ldr	r3, [pc, #108]	; (80024d0 <__early_init+0x240>)
 8002464:	429a      	cmp	r2, r3
 8002466:	d017      	beq.n	8002498 <__early_init+0x208>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8002468:	4b1a      	ldr	r3, [pc, #104]	; (80024d4 <__early_init+0x244>)
 800246a:	f240 7205 	movw	r2, #1797	; 0x705
 800246e:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8002470:	4a0e      	ldr	r2, [pc, #56]	; (80024ac <__early_init+0x21c>)
 8002472:	6893      	ldr	r3, [r2, #8]
 8002474:	f043 0302 	orr.w	r3, r3, #2
 8002478:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800247a:	6893      	ldr	r3, [r2, #8]
 800247c:	f003 030c 	and.w	r3, r3, #12
 8002480:	2b08      	cmp	r3, #8
 8002482:	d1fa      	bne.n	800247a <__early_init+0x1ea>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8002484:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8002486:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800248a:	6453      	str	r3, [r2, #68]	; 0x44
 800248c:	6e53      	ldr	r3, [r2, #100]	; 0x64
 800248e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002492:	6653      	str	r3, [r2, #100]	; 0x64
 8002494:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8002498:	4a0f      	ldr	r2, [pc, #60]	; (80024d8 <__early_init+0x248>)
 800249a:	4b10      	ldr	r3, [pc, #64]	; (80024dc <__early_init+0x24c>)
 800249c:	6812      	ldr	r2, [r2, #0]
 800249e:	429a      	cmp	r2, r3
 80024a0:	d1e2      	bne.n	8002468 <__early_init+0x1d8>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 80024a2:	4b0c      	ldr	r3, [pc, #48]	; (80024d4 <__early_init+0x244>)
 80024a4:	f240 1205 	movw	r2, #261	; 0x105
 80024a8:	601a      	str	r2, [r3, #0]
 80024aa:	e7e1      	b.n	8002470 <__early_init+0x1e0>
 80024ac:	40023800 	.word	0x40023800
 80024b0:	40020400 	.word	0x40020400
 80024b4:	40020800 	.word	0x40020800
 80024b8:	40020c00 	.word	0x40020c00
 80024bc:	40022000 	.word	0x40022000
 80024c0:	07405408 	.word	0x07405408
 80024c4:	40007000 	.word	0x40007000
 80024c8:	e0042000 	.word	0xe0042000
 80024cc:	38889400 	.word	0x38889400
 80024d0:	20006411 	.word	0x20006411
 80024d4:	40023c00 	.word	0x40023c00
 80024d8:	e000ed00 	.word	0xe000ed00
 80024dc:	410fc241 	.word	0x410fc241
 80024e0:	40020000 	.word	0x40020000
 80024e4:	40021000 	.word	0x40021000
 80024e8:	40010054 	.word	0x40010054
 80024ec:	55560000 	.word	0x55560000
 80024f0:	000aaa00 	.word	0x000aaa00
 80024f4:	55514515 	.word	0x55514515
 80024f8:	00082080 	.word	0x00082080
 80024fc:	00060600 	.word	0x00060600
 8002500:	02208001 	.word	0x02208001
 8002504:	00555055 	.word	0x00555055
 8002508:	55000100 	.word	0x55000100
 800250c:	00000000 	.word	0x00000000

08002510 <adc_lld_start_conversion.constprop.25>:
  const ADCConversionGroup *grpp = adcp->grpp;
 8002510:	4a24      	ldr	r2, [pc, #144]	; (80025a4 <adc_lld_start_conversion.constprop.25+0x94>)
 8002512:	6913      	ldr	r3, [r2, #16]
  if (grpp->circular) {
 8002514:	7819      	ldrb	r1, [r3, #0]
void adc_lld_start_conversion(ADCDriver *adcp) {
 8002516:	b5f0      	push	{r4, r5, r6, r7, lr}
  mode = adcp->dmamode;
 8002518:	6b14      	ldr	r4, [r2, #48]	; 0x30
  if (grpp->circular) {
 800251a:	2900      	cmp	r1, #0
 800251c:	d12e      	bne.n	800257c <adc_lld_start_conversion.constprop.25+0x6c>
 800251e:	68d1      	ldr	r1, [r2, #12]
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8002520:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 8002522:	885d      	ldrh	r5, [r3, #2]
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8002524:	6800      	ldr	r0, [r0, #0]
 8002526:	6896      	ldr	r6, [r2, #8]
 8002528:	60c6      	str	r6, [r0, #12]
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 800252a:	fb01 f105 	mul.w	r1, r1, r5
 800252e:	6041      	str	r1, [r0, #4]
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 8002530:	68d9      	ldr	r1, [r3, #12]
  dmaStreamSetMode(adcp->dmastp, mode);
 8002532:	6004      	str	r4, [r0, #0]
  dmaStreamEnable(adcp->dmastp);
 8002534:	6807      	ldr	r7, [r0, #0]
  adcp->adc->SQR1  = grpp->sqr1 | ADC_SQR1_NUM_CH(grpp->num_channels);
 8002536:	69de      	ldr	r6, [r3, #28]
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;
 8002538:	691c      	ldr	r4, [r3, #16]
  adcp->adc->SR    = 0;
 800253a:	6a92      	ldr	r2, [r2, #40]	; 0x28
  dmaStreamEnable(adcp->dmastp);
 800253c:	f047 0701 	orr.w	r7, r7, #1
  adcp->adc->SQR1  = grpp->sqr1 | ADC_SQR1_NUM_CH(grpp->num_channels);
 8002540:	3d01      	subs	r5, #1
  dmaStreamEnable(adcp->dmastp);
 8002542:	6007      	str	r7, [r0, #0]
  adcp->adc->SQR1  = grpp->sqr1 | ADC_SQR1_NUM_CH(grpp->num_channels);
 8002544:	ea46 5505 	orr.w	r5, r6, r5, lsl #20
  adcp->adc->SMPR1 = grpp->smpr1;
 8002548:	695f      	ldr	r7, [r3, #20]
  adcp->adc->SMPR2 = grpp->smpr2;
 800254a:	699e      	ldr	r6, [r3, #24]
  adcp->adc->SQR2  = grpp->sqr2;
 800254c:	6a18      	ldr	r0, [r3, #32]
  adcp->adc->SQR3  = grpp->sqr3;
 800254e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 8002550:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
  adcp->adc->SR    = 0;
 8002554:	f04f 0e00 	mov.w	lr, #0
 8002558:	f8c2 e000 	str.w	lr, [r2]
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 800255c:	f441 7180 	orr.w	r1, r1, #256	; 0x100
  adcp->adc->SMPR1 = grpp->smpr1;
 8002560:	60d7      	str	r7, [r2, #12]
  adcp->adc->SMPR2 = grpp->smpr2;
 8002562:	6116      	str	r6, [r2, #16]
  adcp->adc->SQR1  = grpp->sqr1 | ADC_SQR1_NUM_CH(grpp->num_channels);
 8002564:	62d5      	str	r5, [r2, #44]	; 0x2c
  adcp->adc->SQR2  = grpp->sqr2;
 8002566:	6310      	str	r0, [r2, #48]	; 0x30
  adcp->adc->SQR3  = grpp->sqr3;
 8002568:	6353      	str	r3, [r2, #52]	; 0x34
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
 800256a:	0063      	lsls	r3, r4, #1
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 800256c:	6051      	str	r1, [r2, #4]
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
 800256e:	d40d      	bmi.n	800258c <adc_lld_start_conversion.constprop.25+0x7c>
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;
 8002570:	f444 7440 	orr.w	r4, r4, #768	; 0x300
 8002574:	f044 0401 	orr.w	r4, r4, #1
    adcp->adc->CR2 = cr2;
 8002578:	6094      	str	r4, [r2, #8]
 800257a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (adcp->depth > 1) {
 800257c:	68d1      	ldr	r1, [r2, #12]
 800257e:	2901      	cmp	r1, #1
    mode |= STM32_DMA_CR_CIRC;
 8002580:	bf94      	ite	ls
 8002582:	f444 7480 	orrls.w	r4, r4, #256	; 0x100
      mode |= STM32_DMA_CR_HTIE;
 8002586:	f444 7484 	orrhi.w	r4, r4, #264	; 0x108
 800258a:	e7c9      	b.n	8002520 <adc_lld_start_conversion.constprop.25+0x10>
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800258c:	f024 4380 	bic.w	r3, r4, #1073741824	; 0x40000000
 8002590:	f240 3103 	movw	r1, #771	; 0x303
 8002594:	f023 0302 	bic.w	r3, r3, #2
 8002598:	430b      	orrs	r3, r1
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 800259a:	430c      	orrs	r4, r1
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800259c:	6093      	str	r3, [r2, #8]
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 800259e:	6094      	str	r4, [r2, #8]
 80025a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80025a2:	bf00      	nop
 80025a4:	20001018 	.word	0x20001018
	...

080025b0 <chSchWakeupS.constprop.11>:
  thread_t *otp = currp;
 80025b0:	4b15      	ldr	r3, [pc, #84]	; (8002608 <chSchWakeupS.constprop.11+0x58>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80025b2:	b470      	push	{r4, r5, r6}
  ntp->u.rdymsg = msg;
 80025b4:	2200      	movs	r2, #0
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80025b6:	4604      	mov	r4, r0
  thread_t *otp = currp;
 80025b8:	699d      	ldr	r5, [r3, #24]
  ntp->u.rdymsg = msg;
 80025ba:	6242      	str	r2, [r0, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 80025bc:	68a8      	ldr	r0, [r5, #8]
 80025be:	68a1      	ldr	r1, [r4, #8]
 80025c0:	4281      	cmp	r1, r0
 80025c2:	d80c      	bhi.n	80025de <chSchWakeupS.constprop.11+0x2e>
  tp->state = CH_STATE_READY;
 80025c4:	f884 2020 	strb.w	r2, [r4, #32]
    cp = cp->queue.next;
 80025c8:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80025ca:	689a      	ldr	r2, [r3, #8]
 80025cc:	4291      	cmp	r1, r2
 80025ce:	d9fb      	bls.n	80025c8 <chSchWakeupS.constprop.11+0x18>
  tp->queue.prev             = cp->queue.prev;
 80025d0:	685a      	ldr	r2, [r3, #4]
 80025d2:	6062      	str	r2, [r4, #4]
  tp->queue.next             = cp;
 80025d4:	6023      	str	r3, [r4, #0]
  tp->queue.prev->queue.next = tp;
 80025d6:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80025d8:	605c      	str	r4, [r3, #4]
}
 80025da:	bc70      	pop	{r4, r5, r6}
 80025dc:	4770      	bx	lr
  tp->state = CH_STATE_READY;
 80025de:	f885 2020 	strb.w	r2, [r5, #32]
  cp = (thread_t *)&ch.rlist.queue;
 80025e2:	461a      	mov	r2, r3
    cp = cp->queue.next;
 80025e4:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 80025e6:	6891      	ldr	r1, [r2, #8]
 80025e8:	4288      	cmp	r0, r1
 80025ea:	d9fb      	bls.n	80025e4 <chSchWakeupS.constprop.11+0x34>
  tp->queue.prev             = cp->queue.prev;
 80025ec:	6850      	ldr	r0, [r2, #4]
 80025ee:	6068      	str	r0, [r5, #4]
    ntp->state = CH_STATE_CURRENT;
 80025f0:	2601      	movs	r6, #1
  tp->queue.next             = cp;
 80025f2:	602a      	str	r2, [r5, #0]
  tp->queue.prev->queue.next = tp;
 80025f4:	6005      	str	r5, [r0, #0]
  cp->queue.prev             = tp;
 80025f6:	6055      	str	r5, [r2, #4]
    ntp->state = CH_STATE_CURRENT;
 80025f8:	f884 6020 	strb.w	r6, [r4, #32]
    chSysSwitch(ntp, otp);
 80025fc:	4629      	mov	r1, r5
 80025fe:	4620      	mov	r0, r4
    currp = ntp;
 8002600:	619c      	str	r4, [r3, #24]
}
 8002602:	bc70      	pop	{r4, r5, r6}
    chSysSwitch(ntp, otp);
 8002604:	f7fd be5c 	b.w	80002c0 <_port_switch>
 8002608:	200010c8 	.word	0x200010c8
 800260c:	00000000 	.word	0x00000000

08002610 <chTMStartMeasurementX.constprop.6>:
 8002610:	4b01      	ldr	r3, [pc, #4]	; (8002618 <chTMStartMeasurementX.constprop.6+0x8>)
 8002612:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 8002614:	6083      	str	r3, [r0, #8]
 8002616:	4770      	bx	lr
 8002618:	e0001000 	.word	0xe0001000
 800261c:	00000000 	.word	0x00000000

08002620 <chThdCreateStatic.constprop.5>:
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8002620:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002622:	4603      	mov	r3, r0
 8002624:	2020      	movs	r0, #32
 8002626:	f380 8811 	msr	BASEPRI, r0
  REG_INSERT(tp);
 800262a:	4e1e      	ldr	r6, [pc, #120]	; (80026a4 <chThdCreateStatic.constprop.5+0x84>)
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800262c:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
  REG_INSERT(tp);
 8002630:	6970      	ldr	r0, [r6, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002632:	4c1d      	ldr	r4, [pc, #116]	; (80026a8 <chThdCreateStatic.constprop.5+0x88>)
  tp->prio      = prio;
 8002634:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002638:	f103 05dc 	add.w	r5, r3, #220	; 0xdc
  tp->refs      = (trefs_t)1;
 800263c:	2201      	movs	r2, #1
  tp->realprio  = prio;
 800263e:	f8c3 113c 	str.w	r1, [r3, #316]	; 0x13c
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002642:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
 8002646:	f8c3 40fc 	str.w	r4, [r3, #252]	; 0xfc
  tp = (thread_t *)((uint8_t *)wsp + size -
 800264a:	f503 7580 	add.w	r5, r3, #256	; 0x100
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800264e:	2400      	movs	r4, #0
  tp->refs      = (trefs_t)1;
 8002650:	f883 2122 	strb.w	r2, [r3, #290]	; 0x122
  tp->state     = CH_STATE_WTSTART;
 8002654:	f04f 0e02 	mov.w	lr, #2
  queue_init(&tp->msgqueue);
 8002658:	f503 7296 	add.w	r2, r3, #300	; 0x12c
  list_init(&tp->waiting);
 800265c:	f503 7194 	add.w	r1, r3, #296	; 0x128
  tp->name      = name;
 8002660:	4f12      	ldr	r7, [pc, #72]	; (80026ac <chThdCreateStatic.constprop.5+0x8c>)
  REG_INSERT(tp);
 8002662:	f8c3 0114 	str.w	r0, [r3, #276]	; 0x114
  tp->wabase = (stkalign_t *)wsp;
 8002666:	f8c3 311c 	str.w	r3, [r3, #284]	; 0x11c
  tp->state     = CH_STATE_WTSTART;
 800266a:	f883 e120 	strb.w	lr, [r3, #288]	; 0x120
  tp->name      = name;
 800266e:	f8c3 7118 	str.w	r7, [r3, #280]	; 0x118
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002672:	f8c3 40e0 	str.w	r4, [r3, #224]	; 0xe0
  tp->flags     = CH_FLAG_MODE_STATIC;
 8002676:	f883 4121 	strb.w	r4, [r3, #289]	; 0x121
  tp->mtxlist   = NULL;
 800267a:	f8c3 4138 	str.w	r4, [r3, #312]	; 0x138
  tp->epending  = (eventmask_t)0;
 800267e:	f8c3 4134 	str.w	r4, [r3, #308]	; 0x134
  REG_INSERT(tp);
 8002682:	f8c3 6110 	str.w	r6, [r3, #272]	; 0x110
 8002686:	6105      	str	r5, [r0, #16]
  chSchWakeupS(tp, MSG_OK);
 8002688:	4628      	mov	r0, r5
  tlp->next = (thread_t *)tlp;
 800268a:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
  tqp->next = (thread_t *)tqp;
 800268e:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
  tqp->prev = (thread_t *)tqp;
 8002692:	f8c3 2130 	str.w	r2, [r3, #304]	; 0x130
  REG_INSERT(tp);
 8002696:	6175      	str	r5, [r6, #20]
  chSchWakeupS(tp, MSG_OK);
 8002698:	f7ff ff8a 	bl	80025b0 <chSchWakeupS.constprop.11>
 800269c:	f384 8811 	msr	BASEPRI, r4
}
 80026a0:	4628      	mov	r0, r5
 80026a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80026a4:	200010c8 	.word	0x200010c8
 80026a8:	080002d1 	.word	0x080002d1
 80026ac:	08002cb0 	.word	0x08002cb0

080026b0 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80026b0:	b40e      	push	{r1, r2, r3}
 80026b2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80026b6:	b086      	sub	sp, #24
 80026b8:	af0f      	add	r7, sp, #60	; 0x3c
 80026ba:	4d9f      	ldr	r5, [pc, #636]	; (8002938 <chprintf.constprop.0+0x288>)
 80026bc:	f857 6b04 	ldr.w	r6, [r7], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80026c0:	9702      	str	r7, [sp, #8]
  int n = 0;
 80026c2:	f04f 0b00 	mov.w	fp, #0
    c = *fmt++;
 80026c6:	7831      	ldrb	r1, [r6, #0]
 80026c8:	1c73      	adds	r3, r6, #1
    if (c == 0)
 80026ca:	b161      	cbz	r1, 80026e6 <chprintf.constprop.0+0x36>
    if (c != '%') {
 80026cc:	2925      	cmp	r1, #37	; 0x25
 80026ce:	d010      	beq.n	80026f2 <chprintf.constprop.0+0x42>
      streamPut(chp, (uint8_t)c);
 80026d0:	682a      	ldr	r2, [r5, #0]
 80026d2:	4899      	ldr	r0, [pc, #612]	; (8002938 <chprintf.constprop.0+0x288>)
 80026d4:	68d2      	ldr	r2, [r2, #12]
    c = *fmt++;
 80026d6:	461e      	mov	r6, r3
      streamPut(chp, (uint8_t)c);
 80026d8:	4790      	blx	r2
    c = *fmt++;
 80026da:	7831      	ldrb	r1, [r6, #0]
      n++;
 80026dc:	f10b 0b01 	add.w	fp, fp, #1
    c = *fmt++;
 80026e0:	1c73      	adds	r3, r6, #1
    if (c == 0)
 80026e2:	2900      	cmp	r1, #0
 80026e4:	d1f2      	bne.n	80026cc <chprintf.constprop.0+0x1c>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 80026e6:	4658      	mov	r0, fp
 80026e8:	b006      	add	sp, #24
 80026ea:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80026ee:	b003      	add	sp, #12
 80026f0:	4770      	bx	lr
    if (*fmt == '-') {
 80026f2:	7872      	ldrb	r2, [r6, #1]
 80026f4:	2a2d      	cmp	r2, #45	; 0x2d
 80026f6:	bf03      	ittte	eq
 80026f8:	78b2      	ldrbeq	r2, [r6, #2]
      fmt++;
 80026fa:	1cb3      	addeq	r3, r6, #2
      left_align = TRUE;
 80026fc:	f04f 0c01 	moveq.w	ip, #1
    left_align = FALSE;
 8002700:	f04f 0c00 	movne.w	ip, #0
    if (*fmt == '0') {
 8002704:	2a30      	cmp	r2, #48	; 0x30
 8002706:	bf03      	ittte	eq
 8002708:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 800270a:	3301      	addeq	r3, #1
      filler = '0';
 800270c:	f04f 0930 	moveq.w	r9, #48	; 0x30
    filler = ' ';
 8002710:	f04f 0920 	movne.w	r9, #32
 8002714:	1c59      	adds	r1, r3, #1
    width = 0;
 8002716:	2400      	movs	r4, #0
 8002718:	e005      	b.n	8002726 <chprintf.constprop.0+0x76>
        c = va_arg(ap, int);
 800271a:	783b      	ldrb	r3, [r7, #0]
 800271c:	3704      	adds	r7, #4
 800271e:	f811 2b01 	ldrb.w	r2, [r1], #1
      width = width * 10 + c;
 8002722:	eb03 0440 	add.w	r4, r3, r0, lsl #1
      if (c >= '0' && c <= '9')
 8002726:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 800272a:	b2db      	uxtb	r3, r3
 800272c:	2b09      	cmp	r3, #9
      c = *fmt++;
 800272e:	460e      	mov	r6, r1
      width = width * 10 + c;
 8002730:	eb04 0084 	add.w	r0, r4, r4, lsl #2
      if (c >= '0' && c <= '9')
 8002734:	d9f3      	bls.n	800271e <chprintf.constprop.0+0x6e>
      else if (c == '*')
 8002736:	2a2a      	cmp	r2, #42	; 0x2a
 8002738:	d0ef      	beq.n	800271a <chprintf.constprop.0+0x6a>
    if (c == '.') {
 800273a:	2a2e      	cmp	r2, #46	; 0x2e
 800273c:	f04f 0100 	mov.w	r1, #0
 8002740:	d043      	beq.n	80027ca <chprintf.constprop.0+0x11a>
    if (c == 'l' || c == 'L') {
 8002742:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8002746:	2b4c      	cmp	r3, #76	; 0x4c
 8002748:	d04e      	beq.n	80027e8 <chprintf.constprop.0+0x138>
    switch (c) {
 800274a:	f1a2 0044 	sub.w	r0, r2, #68	; 0x44
 800274e:	2834      	cmp	r0, #52	; 0x34
 8002750:	f200 8151 	bhi.w	80029f6 <chprintf.constprop.0+0x346>
 8002754:	e8df f010 	tbh	[pc, r0, lsl #1]
 8002758:	014f00fe 	.word	0x014f00fe
 800275c:	014f014f 	.word	0x014f014f
 8002760:	00fe014f 	.word	0x00fe014f
 8002764:	014f014f 	.word	0x014f014f
 8002768:	014f014f 	.word	0x014f014f
 800276c:	00f8014f 	.word	0x00f8014f
 8002770:	014f014f 	.word	0x014f014f
 8002774:	014f014f 	.word	0x014f014f
 8002778:	0088014f 	.word	0x0088014f
 800277c:	014f014f 	.word	0x014f014f
 8002780:	014f00fb 	.word	0x014f00fb
 8002784:	014f014f 	.word	0x014f014f
 8002788:	014f014f 	.word	0x014f014f
 800278c:	014f014f 	.word	0x014f014f
 8002790:	014f014f 	.word	0x014f014f
 8002794:	0143014f 	.word	0x0143014f
 8002798:	014f00fe 	.word	0x014f00fe
 800279c:	014f014f 	.word	0x014f014f
 80027a0:	00fe014f 	.word	0x00fe014f
 80027a4:	014f014f 	.word	0x014f014f
 80027a8:	014f014f 	.word	0x014f014f
 80027ac:	00f8014f 	.word	0x00f8014f
 80027b0:	014f014f 	.word	0x014f014f
 80027b4:	0129014f 	.word	0x0129014f
 80027b8:	0088014f 	.word	0x0088014f
 80027bc:	014f014f 	.word	0x014f014f
 80027c0:	00fb      	.short	0x00fb
          c = va_arg(ap, int);
 80027c2:	783b      	ldrb	r3, [r7, #0]
 80027c4:	3704      	adds	r7, #4
        precision += c;
 80027c6:	eb03 0140 	add.w	r1, r3, r0, lsl #1
        c = *fmt++;
 80027ca:	f816 2b01 	ldrb.w	r2, [r6], #1
        if (c >= '0' && c <= '9')
 80027ce:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 80027d2:	b2db      	uxtb	r3, r3
 80027d4:	2b09      	cmp	r3, #9
        precision *= 10;
 80027d6:	eb01 0081 	add.w	r0, r1, r1, lsl #2
        if (c >= '0' && c <= '9')
 80027da:	d9f4      	bls.n	80027c6 <chprintf.constprop.0+0x116>
        else if (c == '*')
 80027dc:	2a2a      	cmp	r2, #42	; 0x2a
 80027de:	d0f0      	beq.n	80027c2 <chprintf.constprop.0+0x112>
    if (c == 'l' || c == 'L') {
 80027e0:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 80027e4:	2b4c      	cmp	r3, #76	; 0x4c
 80027e6:	d1b0      	bne.n	800274a <chprintf.constprop.0+0x9a>
      if (*fmt)
 80027e8:	7833      	ldrb	r3, [r6, #0]
 80027ea:	b10b      	cbz	r3, 80027f0 <chprintf.constprop.0+0x140>
        c = *fmt++;
 80027ec:	3601      	adds	r6, #1
 80027ee:	461a      	mov	r2, r3
    switch (c) {
 80027f0:	f1a2 0344 	sub.w	r3, r2, #68	; 0x44
 80027f4:	2b34      	cmp	r3, #52	; 0x34
 80027f6:	f200 80fe 	bhi.w	80029f6 <chprintf.constprop.0+0x346>
 80027fa:	e8df f013 	tbh	[pc, r3, lsl #1]
 80027fe:	00ab      	.short	0x00ab
 8002800:	00fc00fc 	.word	0x00fc00fc
 8002804:	00fc00fc 	.word	0x00fc00fc
 8002808:	00fc00ab 	.word	0x00fc00ab
 800280c:	00fc00fc 	.word	0x00fc00fc
 8002810:	00fc00fc 	.word	0x00fc00fc
 8002814:	00fc00a5 	.word	0x00fc00a5
 8002818:	00fc00fc 	.word	0x00fc00fc
 800281c:	00fc00fc 	.word	0x00fc00fc
 8002820:	00fc0035 	.word	0x00fc0035
 8002824:	00a800fc 	.word	0x00a800fc
 8002828:	00fc00fc 	.word	0x00fc00fc
 800282c:	00fc00fc 	.word	0x00fc00fc
 8002830:	00fc00fc 	.word	0x00fc00fc
 8002834:	00fc00fc 	.word	0x00fc00fc
 8002838:	00fc00fc 	.word	0x00fc00fc
 800283c:	00ab00f0 	.word	0x00ab00f0
 8002840:	00fc00fc 	.word	0x00fc00fc
 8002844:	00fc00fc 	.word	0x00fc00fc
 8002848:	00fc00ab 	.word	0x00fc00ab
 800284c:	00fc00fc 	.word	0x00fc00fc
 8002850:	00fc00fc 	.word	0x00fc00fc
 8002854:	00fc00a5 	.word	0x00fc00a5
 8002858:	00fc00fc 	.word	0x00fc00fc
 800285c:	00fc00d6 	.word	0x00fc00d6
 8002860:	00fc0035 	.word	0x00fc0035
 8002864:	00a800fc 	.word	0x00a800fc
 8002868:	f04f 080a 	mov.w	r8, #10
        l = va_arg(ap, unsigned int);
 800286c:	683a      	ldr	r2, [r7, #0]
  q = p + MAX_FILLER;
 800286e:	f10d 0117 	add.w	r1, sp, #23
        l = va_arg(ap, unsigned int);
 8002872:	3704      	adds	r7, #4
 8002874:	e000      	b.n	8002878 <chprintf.constprop.0+0x1c8>
  } while ((ll /= radix) != 0);
 8002876:	4601      	mov	r1, r0
    i = (int)(l % radix);
 8002878:	fbb2 fef8 	udiv	lr, r2, r8
 800287c:	fb08 221e 	mls	r2, r8, lr, r2
    i += '0';
 8002880:	f102 0330 	add.w	r3, r2, #48	; 0x30
    if (i > '9')
 8002884:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8002886:	bfc8      	it	gt
 8002888:	f102 0337 	addgt.w	r3, r2, #55	; 0x37
    *--q = i;
 800288c:	b2db      	uxtb	r3, r3
    l /= radix;
 800288e:	4672      	mov	r2, lr
    *--q = i;
 8002890:	f801 3c01 	strb.w	r3, [r1, #-1]
 8002894:	1e48      	subs	r0, r1, #1
  } while ((ll /= radix) != 0);
 8002896:	2a00      	cmp	r2, #0
 8002898:	d1ed      	bne.n	8002876 <chprintf.constprop.0+0x1c6>
  i = (int)(p + MAX_FILLER - q);
 800289a:	f10d 0217 	add.w	r2, sp, #23
 800289e:	f10d 080c 	add.w	r8, sp, #12
 80028a2:	1a12      	subs	r2, r2, r0
 80028a4:	46c6      	mov	lr, r8
 80028a6:	4410      	add	r0, r2
 80028a8:	e001      	b.n	80028ae <chprintf.constprop.0+0x1fe>
 80028aa:	f811 3b01 	ldrb.w	r3, [r1], #1
    *p++ = *q++;
 80028ae:	f80e 3b01 	strb.w	r3, [lr], #1
  while (--i);
 80028b2:	4288      	cmp	r0, r1
 80028b4:	d1f9      	bne.n	80028aa <chprintf.constprop.0+0x1fa>
 80028b6:	1e53      	subs	r3, r2, #1
 80028b8:	9301      	str	r3, [sp, #4]
    if ((width -= i) < 0)
 80028ba:	1aa4      	subs	r4, r4, r2
 80028bc:	d43e      	bmi.n	800293c <chprintf.constprop.0+0x28c>
    if (left_align == FALSE)
 80028be:	f1bc 0f00 	cmp.w	ip, #0
 80028c2:	f040 80a1 	bne.w	8002a08 <chprintf.constprop.0+0x358>
 80028c6:	f1c4 0a00 	rsb	sl, r4, #0
    if (width < 0) {
 80028ca:	2c00      	cmp	r4, #0
 80028cc:	f000 809b 	beq.w	8002a06 <chprintf.constprop.0+0x356>
      if (*s == '-' && filler == '0') {
 80028d0:	f898 1000 	ldrb.w	r1, [r8]
 80028d4:	292d      	cmp	r1, #45	; 0x2d
 80028d6:	f000 80a6 	beq.w	8002a26 <chprintf.constprop.0+0x376>
        streamPut(chp, (uint8_t)filler);
 80028da:	682b      	ldr	r3, [r5, #0]
 80028dc:	4649      	mov	r1, r9
 80028de:	68db      	ldr	r3, [r3, #12]
 80028e0:	4628      	mov	r0, r5
 80028e2:	4798      	blx	r3
      } while (++width != 0);
 80028e4:	f11a 0a01 	adds.w	sl, sl, #1
 80028e8:	d1f7      	bne.n	80028da <chprintf.constprop.0+0x22a>
    while (--i >= 0) {
 80028ea:	9b01      	ldr	r3, [sp, #4]
 80028ec:	2b00      	cmp	r3, #0
 80028ee:	44a3      	add	fp, r4
 80028f0:	bfa8      	it	ge
 80028f2:	4654      	movge	r4, sl
 80028f4:	f6ff aee7 	blt.w	80026c6 <chprintf.constprop.0+0x16>
 80028f8:	f8dd a004 	ldr.w	sl, [sp, #4]
      streamPut(chp, (uint8_t)*s++);
 80028fc:	682b      	ldr	r3, [r5, #0]
 80028fe:	f818 1b01 	ldrb.w	r1, [r8], #1
 8002902:	68db      	ldr	r3, [r3, #12]
    while (--i >= 0) {
 8002904:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
      streamPut(chp, (uint8_t)*s++);
 8002908:	4628      	mov	r0, r5
 800290a:	4798      	blx	r3
    while (--i >= 0) {
 800290c:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
 8002910:	d1f4      	bne.n	80028fc <chprintf.constprop.0+0x24c>
 8002912:	9b01      	ldr	r3, [sp, #4]
 8002914:	f10b 0b01 	add.w	fp, fp, #1
 8002918:	449b      	add	fp, r3
    while (width) {
 800291a:	2c00      	cmp	r4, #0
 800291c:	f43f aed3 	beq.w	80026c6 <chprintf.constprop.0+0x16>
 8002920:	46a0      	mov	r8, r4
      streamPut(chp, (uint8_t)filler);
 8002922:	682b      	ldr	r3, [r5, #0]
 8002924:	4649      	mov	r1, r9
 8002926:	68db      	ldr	r3, [r3, #12]
 8002928:	4628      	mov	r0, r5
 800292a:	4798      	blx	r3
    while (width) {
 800292c:	f1b8 0801 	subs.w	r8, r8, #1
 8002930:	d1f7      	bne.n	8002922 <chprintf.constprop.0+0x272>
 8002932:	44a3      	add	fp, r4
 8002934:	e6c7      	b.n	80026c6 <chprintf.constprop.0+0x16>
 8002936:	bf00      	nop
 8002938:	2000104c 	.word	0x2000104c
    while (--i >= 0) {
 800293c:	9b01      	ldr	r3, [sp, #4]
 800293e:	2b00      	cmp	r3, #0
      width = 0;
 8002940:	bfa8      	it	ge
 8002942:	2400      	movge	r4, #0
    while (--i >= 0) {
 8002944:	dad8      	bge.n	80028f8 <chprintf.constprop.0+0x248>
 8002946:	e6be      	b.n	80026c6 <chprintf.constprop.0+0x16>
    switch (c) {
 8002948:	f04f 0808 	mov.w	r8, #8
 800294c:	e78e      	b.n	800286c <chprintf.constprop.0+0x1bc>
 800294e:	f04f 0810 	mov.w	r8, #16
 8002952:	e78b      	b.n	800286c <chprintf.constprop.0+0x1bc>
        l = va_arg(ap, int);
 8002954:	6839      	ldr	r1, [r7, #0]
      if (l < 0) {
 8002956:	2900      	cmp	r1, #0
        l = va_arg(ap, int);
 8002958:	f107 0704 	add.w	r7, r7, #4
      if (l < 0) {
 800295c:	db73      	blt.n	8002a46 <chprintf.constprop.0+0x396>
    p = tmpbuf;
 800295e:	f10d 080c 	add.w	r8, sp, #12
 8002962:	4642      	mov	r2, r8
  q = p + MAX_FILLER;
 8002964:	f102 030b 	add.w	r3, r2, #11
 8002968:	9301      	str	r3, [sp, #4]
 800296a:	4618      	mov	r0, r3
    i = (int)(l % radix);
 800296c:	4b3e      	ldr	r3, [pc, #248]	; (8002a68 <chprintf.constprop.0+0x3b8>)
 800296e:	fba3 e301 	umull	lr, r3, r3, r1
 8002972:	08db      	lsrs	r3, r3, #3
 8002974:	eb03 0a83 	add.w	sl, r3, r3, lsl #2
 8002978:	469e      	mov	lr, r3
 800297a:	eba1 034a 	sub.w	r3, r1, sl, lsl #1
    i += '0';
 800297e:	3330      	adds	r3, #48	; 0x30
    *--q = i;
 8002980:	b2db      	uxtb	r3, r3
  } while ((ll /= radix) != 0);
 8002982:	4671      	mov	r1, lr
    *--q = i;
 8002984:	f800 3d01 	strb.w	r3, [r0, #-1]!
  } while ((ll /= radix) != 0);
 8002988:	2900      	cmp	r1, #0
 800298a:	d1ef      	bne.n	800296c <chprintf.constprop.0+0x2bc>
  i = (int)(p + MAX_FILLER - q);
 800298c:	9901      	ldr	r1, [sp, #4]
 800298e:	1a09      	subs	r1, r1, r0
 8002990:	4411      	add	r1, r2
 8002992:	e001      	b.n	8002998 <chprintf.constprop.0+0x2e8>
 8002994:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    *p++ = *q++;
 8002998:	f802 3b01 	strb.w	r3, [r2], #1
  while (--i);
 800299c:	428a      	cmp	r2, r1
 800299e:	d1f9      	bne.n	8002994 <chprintf.constprop.0+0x2e4>
 80029a0:	eba2 0208 	sub.w	r2, r2, r8
 80029a4:	1e53      	subs	r3, r2, #1
 80029a6:	9301      	str	r3, [sp, #4]
 80029a8:	e787      	b.n	80028ba <chprintf.constprop.0+0x20a>
      if ((s = va_arg(ap, char *)) == 0)
 80029aa:	f8d7 8000 	ldr.w	r8, [r7]
 80029ae:	3704      	adds	r7, #4
 80029b0:	f1b8 0f00 	cmp.w	r8, #0
 80029b4:	d050      	beq.n	8002a58 <chprintf.constprop.0+0x3a8>
      for (p = s; *p && (--precision >= 0); p++)
 80029b6:	f898 3000 	ldrb.w	r3, [r8]
      if (precision == 0)
 80029ba:	b351      	cbz	r1, 8002a12 <chprintf.constprop.0+0x362>
      for (p = s; *p && (--precision >= 0); p++)
 80029bc:	b36b      	cbz	r3, 8002a1a <chprintf.constprop.0+0x36a>
 80029be:	3901      	subs	r1, #1
 80029c0:	4642      	mov	r2, r8
 80029c2:	e001      	b.n	80029c8 <chprintf.constprop.0+0x318>
 80029c4:	3901      	subs	r1, #1
 80029c6:	d403      	bmi.n	80029d0 <chprintf.constprop.0+0x320>
 80029c8:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80029cc:	2b00      	cmp	r3, #0
 80029ce:	d1f9      	bne.n	80029c4 <chprintf.constprop.0+0x314>
 80029d0:	eba2 0208 	sub.w	r2, r2, r8
 80029d4:	1e53      	subs	r3, r2, #1
 80029d6:	9301      	str	r3, [sp, #4]
      filler = ' ';
 80029d8:	f04f 0920 	mov.w	r9, #32
 80029dc:	e76d      	b.n	80028ba <chprintf.constprop.0+0x20a>
      *p++ = va_arg(ap, int);
 80029de:	f10d 0818 	add.w	r8, sp, #24
 80029e2:	683b      	ldr	r3, [r7, #0]
 80029e4:	f808 3d0c 	strb.w	r3, [r8, #-12]!
 80029e8:	2300      	movs	r3, #0
 80029ea:	3704      	adds	r7, #4
 80029ec:	9301      	str	r3, [sp, #4]
 80029ee:	2201      	movs	r2, #1
      filler = ' ';
 80029f0:	f04f 0920 	mov.w	r9, #32
 80029f4:	e761      	b.n	80028ba <chprintf.constprop.0+0x20a>
      *p++ = c;
 80029f6:	f10d 0818 	add.w	r8, sp, #24
 80029fa:	2300      	movs	r3, #0
 80029fc:	f808 2d0c 	strb.w	r2, [r8, #-12]!
 8002a00:	9301      	str	r3, [sp, #4]
 8002a02:	2201      	movs	r2, #1
 8002a04:	e759      	b.n	80028ba <chprintf.constprop.0+0x20a>
    if (width < 0) {
 8002a06:	4654      	mov	r4, sl
    while (--i >= 0) {
 8002a08:	9b01      	ldr	r3, [sp, #4]
 8002a0a:	2b00      	cmp	r3, #0
 8002a0c:	f6bf af74 	bge.w	80028f8 <chprintf.constprop.0+0x248>
 8002a10:	e783      	b.n	800291a <chprintf.constprop.0+0x26a>
      for (p = s; *p && (--precision >= 0); p++)
 8002a12:	f647 71fe 	movw	r1, #32766	; 0x7ffe
 8002a16:	2b00      	cmp	r3, #0
 8002a18:	d1d2      	bne.n	80029c0 <chprintf.constprop.0+0x310>
 8002a1a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002a1e:	9301      	str	r3, [sp, #4]
 8002a20:	f04f 0920 	mov.w	r9, #32
 8002a24:	e74b      	b.n	80028be <chprintf.constprop.0+0x20e>
      if (*s == '-' && filler == '0') {
 8002a26:	f1b9 0f30 	cmp.w	r9, #48	; 0x30
 8002a2a:	f47f af56 	bne.w	80028da <chprintf.constprop.0+0x22a>
        streamPut(chp, (uint8_t)*s++);
 8002a2e:	682a      	ldr	r2, [r5, #0]
 8002a30:	480e      	ldr	r0, [pc, #56]	; (8002a6c <chprintf.constprop.0+0x3bc>)
 8002a32:	68d2      	ldr	r2, [r2, #12]
 8002a34:	4790      	blx	r2
 8002a36:	9b01      	ldr	r3, [sp, #4]
 8002a38:	3b01      	subs	r3, #1
 8002a3a:	f108 0801 	add.w	r8, r8, #1
        n++;
 8002a3e:	f10b 0b01 	add.w	fp, fp, #1
 8002a42:	9301      	str	r3, [sp, #4]
 8002a44:	e749      	b.n	80028da <chprintf.constprop.0+0x22a>
        *p++ = '-';
 8002a46:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8002a48:	4249      	negs	r1, r1
        *p++ = '-';
 8002a4a:	f88d 300c 	strb.w	r3, [sp, #12]
 8002a4e:	f10d 020d 	add.w	r2, sp, #13
 8002a52:	f10d 080c 	add.w	r8, sp, #12
 8002a56:	e785      	b.n	8002964 <chprintf.constprop.0+0x2b4>
        s = "(null)";
 8002a58:	f8df 8014 	ldr.w	r8, [pc, #20]	; 8002a70 <chprintf.constprop.0+0x3c0>
      if (precision == 0)
 8002a5c:	2900      	cmp	r1, #0
 8002a5e:	d1ae      	bne.n	80029be <chprintf.constprop.0+0x30e>
        precision = 32767;
 8002a60:	f647 71ff 	movw	r1, #32767	; 0x7fff
 8002a64:	e7ab      	b.n	80029be <chprintf.constprop.0+0x30e>
 8002a66:	bf00      	nop
 8002a68:	cccccccd 	.word	0xcccccccd
 8002a6c:	2000104c 	.word	0x2000104c
 8002a70:	08002cb8 	.word	0x08002cb8
