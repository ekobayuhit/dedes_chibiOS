
build/dedes.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002b9 	.word	0x080002b9
 8000008:	080002bb 	.word	0x080002bb
 800000c:	080002ba 	.word	0x080002ba
 8000010:	080002ba 	.word	0x080002ba
 8000014:	080002ba 	.word	0x080002ba
 8000018:	080002ba 	.word	0x080002ba
 800001c:	080002ba 	.word	0x080002ba
 8000020:	080002ba 	.word	0x080002ba
 8000024:	080002ba 	.word	0x080002ba
 8000028:	080002ba 	.word	0x080002ba
 800002c:	08002601 	.word	0x08002601
 8000030:	080002ba 	.word	0x080002ba
 8000034:	080002ba 	.word	0x080002ba
 8000038:	080002ba 	.word	0x080002ba
 800003c:	080002ba 	.word	0x080002ba
 8000040:	080002ba 	.word	0x080002ba
 8000044:	080002ba 	.word	0x080002ba
 8000048:	080002ba 	.word	0x080002ba
 800004c:	080002ba 	.word	0x080002ba
 8000050:	080002ba 	.word	0x080002ba
 8000054:	080002ba 	.word	0x080002ba
 8000058:	08001b61 	.word	0x08001b61
 800005c:	08001b31 	.word	0x08001b31
 8000060:	08001b01 	.word	0x08001b01
 8000064:	08001ad1 	.word	0x08001ad1
 8000068:	08001aa1 	.word	0x08001aa1
 800006c:	080018e1 	.word	0x080018e1
 8000070:	080018b1 	.word	0x080018b1
 8000074:	08001881 	.word	0x08001881
 8000078:	08001851 	.word	0x08001851
 800007c:	08001821 	.word	0x08001821
 8000080:	080017f1 	.word	0x080017f1
 8000084:	080017c1 	.word	0x080017c1
 8000088:	08001911 	.word	0x08001911
 800008c:	080002ba 	.word	0x080002ba
 8000090:	080002ba 	.word	0x080002ba
 8000094:	080002ba 	.word	0x080002ba
 8000098:	080002ba 	.word	0x080002ba
 800009c:	08001a31 	.word	0x08001a31
 80000a0:	080002ba 	.word	0x080002ba
 80000a4:	08001471 	.word	0x08001471
 80000a8:	080002ba 	.word	0x080002ba
 80000ac:	08001491 	.word	0x08001491
 80000b0:	080014a1 	.word	0x080014a1
 80000b4:	08001451 	.word	0x08001451
 80000b8:	08001431 	.word	0x08001431
 80000bc:	080002ba 	.word	0x080002ba
 80000c0:	080002ba 	.word	0x080002ba
 80000c4:	080002ba 	.word	0x080002ba
 80000c8:	080002ba 	.word	0x080002ba
 80000cc:	080002ba 	.word	0x080002ba
 80000d0:	080002ba 	.word	0x080002ba
 80000d4:	080002ba 	.word	0x080002ba
 80000d8:	08001271 	.word	0x08001271
 80000dc:	080002ba 	.word	0x080002ba
 80000e0:	080019b1 	.word	0x080019b1
 80000e4:	080002ba 	.word	0x080002ba
 80000e8:	080002ba 	.word	0x080002ba
 80000ec:	080002ba 	.word	0x080002ba
 80000f0:	080002ba 	.word	0x080002ba
 80000f4:	080002ba 	.word	0x080002ba
 80000f8:	080002ba 	.word	0x080002ba
 80000fc:	08001791 	.word	0x08001791
 8000100:	080002ba 	.word	0x080002ba
 8000104:	080002ba 	.word	0x080002ba
 8000108:	080002ba 	.word	0x080002ba
 800010c:	080002ba 	.word	0x080002ba
 8000110:	080002ba 	.word	0x080002ba
 8000114:	080002ba 	.word	0x080002ba
 8000118:	080002ba 	.word	0x080002ba
 800011c:	080002ba 	.word	0x080002ba
 8000120:	08001761 	.word	0x08001761
 8000124:	08001731 	.word	0x08001731
 8000128:	08001701 	.word	0x08001701
 800012c:	080016d1 	.word	0x080016d1
 8000130:	080016a1 	.word	0x080016a1
 8000134:	080002ba 	.word	0x080002ba
 8000138:	080002ba 	.word	0x080002ba
 800013c:	080002ba 	.word	0x080002ba
 8000140:	080002ba 	.word	0x080002ba
 8000144:	080002ba 	.word	0x080002ba
 8000148:	080002ba 	.word	0x080002ba
 800014c:	080002ba 	.word	0x080002ba
 8000150:	08001671 	.word	0x08001671
 8000154:	08001641 	.word	0x08001641
 8000158:	08001611 	.word	0x08001611
 800015c:	080002ba 	.word	0x080002ba
 8000160:	080002ba 	.word	0x080002ba
 8000164:	080002ba 	.word	0x080002ba
 8000168:	080002ba 	.word	0x080002ba
 800016c:	080002ba 	.word	0x080002ba
 8000170:	080002ba 	.word	0x080002ba
 8000174:	080002ba 	.word	0x080002ba
 8000178:	080002ba 	.word	0x080002ba
 800017c:	080002ba 	.word	0x080002ba
 8000180:	080002ba 	.word	0x080002ba
 8000184:	080002ba 	.word	0x080002ba
 8000188:	080002ba 	.word	0x080002ba
 800018c:	080002ba 	.word	0x080002ba
 8000190:	080002ba 	.word	0x080002ba
 8000194:	080002ba 	.word	0x080002ba
 8000198:	080002ba 	.word	0x080002ba
 800019c:	080002ba 	.word	0x080002ba
 80001a0:	080002ba 	.word	0x080002ba
 80001a4:	080002ba 	.word	0x080002ba
 80001a8:	080002ba 	.word	0x080002ba
 80001ac:	080002ba 	.word	0x080002ba
 80001b0:	080002ba 	.word	0x080002ba
 80001b4:	080002ba 	.word	0x080002ba
 80001b8:	080002ba 	.word	0x080002ba
 80001bc:	080002ba 	.word	0x080002ba
 80001c0:	080002ba 	.word	0x080002ba
 80001c4:	080002ba 	.word	0x080002ba
 80001c8:	080002ba 	.word	0x080002ba
 80001cc:	080002ba 	.word	0x080002ba
 80001d0:	080002ba 	.word	0x080002ba
 80001d4:	080002ba 	.word	0x080002ba
 80001d8:	080002ba 	.word	0x080002ba
 80001dc:	080002ba 	.word	0x080002ba

Disassembly of section .text:

080001e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001e2:	4827      	ldr	r0, [pc, #156]	; (8000280 <endfiniloop+0x4>)
                msr     MSP, r0
 80001e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e8:	4826      	ldr	r0, [pc, #152]	; (8000284 <endfiniloop+0x8>)
                msr     PSP, r0
 80001ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001ee:	4826      	ldr	r0, [pc, #152]	; (8000288 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80001f0:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80001f4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001f8:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001fa:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001fc:	f380 8814 	msr	CONTROL, r0
                isb
 8000200:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000204:	f001 fd0c 	bl	8001c20 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000208:	f000 fef2 	bl	8000ff0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800020c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000210:	491e      	ldr	r1, [pc, #120]	; (800028c <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 8000212:	4a1b      	ldr	r2, [pc, #108]	; (8000280 <endfiniloop+0x4>)

08000214 <msloop>:
msloop:
                cmp     r1, r2
 8000214:	4291      	cmp	r1, r2
                itt     lo
 8000216:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000218:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 800021c:	e7fa      	bcc.n	8000214 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800021e:	491c      	ldr	r1, [pc, #112]	; (8000290 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 8000220:	4a18      	ldr	r2, [pc, #96]	; (8000284 <endfiniloop+0x8>)

08000222 <psloop>:
psloop:
                cmp     r1, r2
 8000222:	4291      	cmp	r1, r2
                itt     lo
 8000224:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000226:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800022a:	e7fa      	bcc.n	8000222 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 800022c:	4919      	ldr	r1, [pc, #100]	; (8000294 <endfiniloop+0x18>)
                ldr     r2, =_data_start
 800022e:	4a1a      	ldr	r2, [pc, #104]	; (8000298 <endfiniloop+0x1c>)
                ldr     r3, =_data_end
 8000230:	4b1a      	ldr	r3, [pc, #104]	; (800029c <endfiniloop+0x20>)

08000232 <dloop>:
dloop:
                cmp     r2, r3
 8000232:	429a      	cmp	r2, r3
                ittt    lo
 8000234:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000236:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800023a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800023e:	e7f8      	bcc.n	8000232 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000240:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000242:	4917      	ldr	r1, [pc, #92]	; (80002a0 <endfiniloop+0x24>)
                ldr     r2, =_bss_end
 8000244:	4a17      	ldr	r2, [pc, #92]	; (80002a4 <endfiniloop+0x28>)

08000246 <bloop>:
bloop:
                cmp     r1, r2
 8000246:	4291      	cmp	r1, r2
                itt     lo
 8000248:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800024a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800024e:	e7fa      	bcc.n	8000246 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000250:	f001 fc9e 	bl	8001b90 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000254:	f001 fcdc 	bl	8001c10 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8000258:	4c13      	ldr	r4, [pc, #76]	; (80002a8 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end
 800025a:	4d14      	ldr	r5, [pc, #80]	; (80002ac <endfiniloop+0x30>)

0800025c <initloop>:
initloop:
                cmp     r4, r5
 800025c:	42ac      	cmp	r4, r5
                bge     endinitloop
 800025e:	da03      	bge.n	8000268 <endinitloop>
                ldr     r1, [r4], #4
 8000260:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000264:	4788      	blx	r1
                b       initloop
 8000266:	e7f9      	b.n	800025c <initloop>

08000268 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000268:	f001 fd4a 	bl	8001d00 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 800026c:	4c10      	ldr	r4, [pc, #64]	; (80002b0 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end
 800026e:	4d11      	ldr	r5, [pc, #68]	; (80002b4 <endfiniloop+0x38>)

08000270 <finiloop>:
finiloop:
                cmp     r4, r5
 8000270:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000272:	da03      	bge.n	800027c <endfiniloop>
                ldr     r1, [r4], #4
 8000274:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000278:	4788      	blx	r1
                b       finiloop
 800027a:	e7f9      	b.n	8000270 <finiloop>

0800027c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800027c:	f001 bcc0 	b.w	8001c00 <__default_exit>
                ldr     r0, =__main_stack_end__
 8000280:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000284:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000288:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 800028c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000290:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
 8000294:	080031f4 	.word	0x080031f4
                ldr     r2, =_data_start
 8000298:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 800029c:	20000800 	.word	0x20000800
                ldr     r1, =_bss_start
 80002a0:	20000800 	.word	0x20000800
                ldr     r2, =_bss_end
 80002a4:	20000dc0 	.word	0x20000dc0
                ldr     r4, =__init_array_start
 80002a8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end
 80002ac:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_start
 80002b0:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end
 80002b4:	080001e0 	.word	0x080001e0

080002b8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002b8:	e792      	b.n	80001e0 <_crt0_entry>

080002ba <NMI_Handler>:
Vector3F0:
Vector3F4:
Vector3F8:
Vector3FC:
#endif
        bl          _unhandled_exception
 80002ba:	f000 f800 	bl	80002be <_unhandled_exception>

080002be <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002be:	e7fe      	b.n	80002be <_unhandled_exception>

080002c0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002c4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002c8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ca:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002d0 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002d0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002d2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002d6:	4628      	mov	r0, r5
                blx     r4
 80002d8:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80002da:	2000      	movs	r0, #0
                bl      chThdExit
 80002dc:	f002 fb90 	bl	8002a00 <chThdExit>

080002e0 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 80002e0:	f002 f9de 	bl	80026a0 <chSchDoReschedule>

080002e4 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002e4:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002e6:	e7fe      	b.n	80002e6 <_port_exit_from_isr+0x2>

080002e8 <__aeabi_drsub>:
 80002e8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002ec:	e002      	b.n	80002f4 <__adddf3>
 80002ee:	bf00      	nop

080002f0 <__aeabi_dsub>:
 80002f0:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002f4 <__adddf3>:
 80002f4:	b530      	push	{r4, r5, lr}
 80002f6:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002fa:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002fe:	ea94 0f05 	teq	r4, r5
 8000302:	bf08      	it	eq
 8000304:	ea90 0f02 	teqeq	r0, r2
 8000308:	bf1f      	itttt	ne
 800030a:	ea54 0c00 	orrsne.w	ip, r4, r0
 800030e:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000312:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000316:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800031a:	f000 80e2 	beq.w	80004e2 <__adddf3+0x1ee>
 800031e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000322:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000326:	bfb8      	it	lt
 8000328:	426d      	neglt	r5, r5
 800032a:	dd0c      	ble.n	8000346 <__adddf3+0x52>
 800032c:	442c      	add	r4, r5
 800032e:	ea80 0202 	eor.w	r2, r0, r2
 8000332:	ea81 0303 	eor.w	r3, r1, r3
 8000336:	ea82 0000 	eor.w	r0, r2, r0
 800033a:	ea83 0101 	eor.w	r1, r3, r1
 800033e:	ea80 0202 	eor.w	r2, r0, r2
 8000342:	ea81 0303 	eor.w	r3, r1, r3
 8000346:	2d36      	cmp	r5, #54	; 0x36
 8000348:	bf88      	it	hi
 800034a:	bd30      	pophi	{r4, r5, pc}
 800034c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000350:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000354:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000358:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800035c:	d002      	beq.n	8000364 <__adddf3+0x70>
 800035e:	4240      	negs	r0, r0
 8000360:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000364:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000368:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800036c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000370:	d002      	beq.n	8000378 <__adddf3+0x84>
 8000372:	4252      	negs	r2, r2
 8000374:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000378:	ea94 0f05 	teq	r4, r5
 800037c:	f000 80a7 	beq.w	80004ce <__adddf3+0x1da>
 8000380:	f1a4 0401 	sub.w	r4, r4, #1
 8000384:	f1d5 0e20 	rsbs	lr, r5, #32
 8000388:	db0d      	blt.n	80003a6 <__adddf3+0xb2>
 800038a:	fa02 fc0e 	lsl.w	ip, r2, lr
 800038e:	fa22 f205 	lsr.w	r2, r2, r5
 8000392:	1880      	adds	r0, r0, r2
 8000394:	f141 0100 	adc.w	r1, r1, #0
 8000398:	fa03 f20e 	lsl.w	r2, r3, lr
 800039c:	1880      	adds	r0, r0, r2
 800039e:	fa43 f305 	asr.w	r3, r3, r5
 80003a2:	4159      	adcs	r1, r3
 80003a4:	e00e      	b.n	80003c4 <__adddf3+0xd0>
 80003a6:	f1a5 0520 	sub.w	r5, r5, #32
 80003aa:	f10e 0e20 	add.w	lr, lr, #32
 80003ae:	2a01      	cmp	r2, #1
 80003b0:	fa03 fc0e 	lsl.w	ip, r3, lr
 80003b4:	bf28      	it	cs
 80003b6:	f04c 0c02 	orrcs.w	ip, ip, #2
 80003ba:	fa43 f305 	asr.w	r3, r3, r5
 80003be:	18c0      	adds	r0, r0, r3
 80003c0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003c4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003c8:	d507      	bpl.n	80003da <__adddf3+0xe6>
 80003ca:	f04f 0e00 	mov.w	lr, #0
 80003ce:	f1dc 0c00 	rsbs	ip, ip, #0
 80003d2:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003d6:	eb6e 0101 	sbc.w	r1, lr, r1
 80003da:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003de:	d31b      	bcc.n	8000418 <__adddf3+0x124>
 80003e0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003e4:	d30c      	bcc.n	8000400 <__adddf3+0x10c>
 80003e6:	0849      	lsrs	r1, r1, #1
 80003e8:	ea5f 0030 	movs.w	r0, r0, rrx
 80003ec:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003f0:	f104 0401 	add.w	r4, r4, #1
 80003f4:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003f8:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003fc:	f080 809a 	bcs.w	8000534 <__adddf3+0x240>
 8000400:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000404:	bf08      	it	eq
 8000406:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800040a:	f150 0000 	adcs.w	r0, r0, #0
 800040e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000412:	ea41 0105 	orr.w	r1, r1, r5
 8000416:	bd30      	pop	{r4, r5, pc}
 8000418:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800041c:	4140      	adcs	r0, r0
 800041e:	eb41 0101 	adc.w	r1, r1, r1
 8000422:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000426:	f1a4 0401 	sub.w	r4, r4, #1
 800042a:	d1e9      	bne.n	8000400 <__adddf3+0x10c>
 800042c:	f091 0f00 	teq	r1, #0
 8000430:	bf04      	itt	eq
 8000432:	4601      	moveq	r1, r0
 8000434:	2000      	moveq	r0, #0
 8000436:	fab1 f381 	clz	r3, r1
 800043a:	bf08      	it	eq
 800043c:	3320      	addeq	r3, #32
 800043e:	f1a3 030b 	sub.w	r3, r3, #11
 8000442:	f1b3 0220 	subs.w	r2, r3, #32
 8000446:	da0c      	bge.n	8000462 <__adddf3+0x16e>
 8000448:	320c      	adds	r2, #12
 800044a:	dd08      	ble.n	800045e <__adddf3+0x16a>
 800044c:	f102 0c14 	add.w	ip, r2, #20
 8000450:	f1c2 020c 	rsb	r2, r2, #12
 8000454:	fa01 f00c 	lsl.w	r0, r1, ip
 8000458:	fa21 f102 	lsr.w	r1, r1, r2
 800045c:	e00c      	b.n	8000478 <__adddf3+0x184>
 800045e:	f102 0214 	add.w	r2, r2, #20
 8000462:	bfd8      	it	le
 8000464:	f1c2 0c20 	rsble	ip, r2, #32
 8000468:	fa01 f102 	lsl.w	r1, r1, r2
 800046c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000470:	bfdc      	itt	le
 8000472:	ea41 010c 	orrle.w	r1, r1, ip
 8000476:	4090      	lslle	r0, r2
 8000478:	1ae4      	subs	r4, r4, r3
 800047a:	bfa2      	ittt	ge
 800047c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000480:	4329      	orrge	r1, r5
 8000482:	bd30      	popge	{r4, r5, pc}
 8000484:	ea6f 0404 	mvn.w	r4, r4
 8000488:	3c1f      	subs	r4, #31
 800048a:	da1c      	bge.n	80004c6 <__adddf3+0x1d2>
 800048c:	340c      	adds	r4, #12
 800048e:	dc0e      	bgt.n	80004ae <__adddf3+0x1ba>
 8000490:	f104 0414 	add.w	r4, r4, #20
 8000494:	f1c4 0220 	rsb	r2, r4, #32
 8000498:	fa20 f004 	lsr.w	r0, r0, r4
 800049c:	fa01 f302 	lsl.w	r3, r1, r2
 80004a0:	ea40 0003 	orr.w	r0, r0, r3
 80004a4:	fa21 f304 	lsr.w	r3, r1, r4
 80004a8:	ea45 0103 	orr.w	r1, r5, r3
 80004ac:	bd30      	pop	{r4, r5, pc}
 80004ae:	f1c4 040c 	rsb	r4, r4, #12
 80004b2:	f1c4 0220 	rsb	r2, r4, #32
 80004b6:	fa20 f002 	lsr.w	r0, r0, r2
 80004ba:	fa01 f304 	lsl.w	r3, r1, r4
 80004be:	ea40 0003 	orr.w	r0, r0, r3
 80004c2:	4629      	mov	r1, r5
 80004c4:	bd30      	pop	{r4, r5, pc}
 80004c6:	fa21 f004 	lsr.w	r0, r1, r4
 80004ca:	4629      	mov	r1, r5
 80004cc:	bd30      	pop	{r4, r5, pc}
 80004ce:	f094 0f00 	teq	r4, #0
 80004d2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004d6:	bf06      	itte	eq
 80004d8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004dc:	3401      	addeq	r4, #1
 80004de:	3d01      	subne	r5, #1
 80004e0:	e74e      	b.n	8000380 <__adddf3+0x8c>
 80004e2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004e6:	bf18      	it	ne
 80004e8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004ec:	d029      	beq.n	8000542 <__adddf3+0x24e>
 80004ee:	ea94 0f05 	teq	r4, r5
 80004f2:	bf08      	it	eq
 80004f4:	ea90 0f02 	teqeq	r0, r2
 80004f8:	d005      	beq.n	8000506 <__adddf3+0x212>
 80004fa:	ea54 0c00 	orrs.w	ip, r4, r0
 80004fe:	bf04      	itt	eq
 8000500:	4619      	moveq	r1, r3
 8000502:	4610      	moveq	r0, r2
 8000504:	bd30      	pop	{r4, r5, pc}
 8000506:	ea91 0f03 	teq	r1, r3
 800050a:	bf1e      	ittt	ne
 800050c:	2100      	movne	r1, #0
 800050e:	2000      	movne	r0, #0
 8000510:	bd30      	popne	{r4, r5, pc}
 8000512:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000516:	d105      	bne.n	8000524 <__adddf3+0x230>
 8000518:	0040      	lsls	r0, r0, #1
 800051a:	4149      	adcs	r1, r1
 800051c:	bf28      	it	cs
 800051e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8000522:	bd30      	pop	{r4, r5, pc}
 8000524:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000528:	bf3c      	itt	cc
 800052a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800052e:	bd30      	popcc	{r4, r5, pc}
 8000530:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000534:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000538:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800053c:	f04f 0000 	mov.w	r0, #0
 8000540:	bd30      	pop	{r4, r5, pc}
 8000542:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000546:	bf1a      	itte	ne
 8000548:	4619      	movne	r1, r3
 800054a:	4610      	movne	r0, r2
 800054c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000550:	bf1c      	itt	ne
 8000552:	460b      	movne	r3, r1
 8000554:	4602      	movne	r2, r0
 8000556:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800055a:	bf06      	itte	eq
 800055c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000560:	ea91 0f03 	teqeq	r1, r3
 8000564:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000568:	bd30      	pop	{r4, r5, pc}
 800056a:	bf00      	nop

0800056c <__aeabi_ui2d>:
 800056c:	f090 0f00 	teq	r0, #0
 8000570:	bf04      	itt	eq
 8000572:	2100      	moveq	r1, #0
 8000574:	4770      	bxeq	lr
 8000576:	b530      	push	{r4, r5, lr}
 8000578:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800057c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000580:	f04f 0500 	mov.w	r5, #0
 8000584:	f04f 0100 	mov.w	r1, #0
 8000588:	e750      	b.n	800042c <__adddf3+0x138>
 800058a:	bf00      	nop

0800058c <__aeabi_i2d>:
 800058c:	f090 0f00 	teq	r0, #0
 8000590:	bf04      	itt	eq
 8000592:	2100      	moveq	r1, #0
 8000594:	4770      	bxeq	lr
 8000596:	b530      	push	{r4, r5, lr}
 8000598:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800059c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005a0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80005a4:	bf48      	it	mi
 80005a6:	4240      	negmi	r0, r0
 80005a8:	f04f 0100 	mov.w	r1, #0
 80005ac:	e73e      	b.n	800042c <__adddf3+0x138>
 80005ae:	bf00      	nop

080005b0 <__aeabi_f2d>:
 80005b0:	0042      	lsls	r2, r0, #1
 80005b2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80005b6:	ea4f 0131 	mov.w	r1, r1, rrx
 80005ba:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80005be:	bf1f      	itttt	ne
 80005c0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80005c4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005c8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005cc:	4770      	bxne	lr
 80005ce:	f092 0f00 	teq	r2, #0
 80005d2:	bf14      	ite	ne
 80005d4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005d8:	4770      	bxeq	lr
 80005da:	b530      	push	{r4, r5, lr}
 80005dc:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005e0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005e4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005e8:	e720      	b.n	800042c <__adddf3+0x138>
 80005ea:	bf00      	nop

080005ec <__aeabi_ul2d>:
 80005ec:	ea50 0201 	orrs.w	r2, r0, r1
 80005f0:	bf08      	it	eq
 80005f2:	4770      	bxeq	lr
 80005f4:	b530      	push	{r4, r5, lr}
 80005f6:	f04f 0500 	mov.w	r5, #0
 80005fa:	e00a      	b.n	8000612 <__aeabi_l2d+0x16>

080005fc <__aeabi_l2d>:
 80005fc:	ea50 0201 	orrs.w	r2, r0, r1
 8000600:	bf08      	it	eq
 8000602:	4770      	bxeq	lr
 8000604:	b530      	push	{r4, r5, lr}
 8000606:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800060a:	d502      	bpl.n	8000612 <__aeabi_l2d+0x16>
 800060c:	4240      	negs	r0, r0
 800060e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000612:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000616:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800061a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800061e:	f43f aedc 	beq.w	80003da <__adddf3+0xe6>
 8000622:	f04f 0203 	mov.w	r2, #3
 8000626:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800062a:	bf18      	it	ne
 800062c:	3203      	addne	r2, #3
 800062e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000632:	bf18      	it	ne
 8000634:	3203      	addne	r2, #3
 8000636:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800063a:	f1c2 0320 	rsb	r3, r2, #32
 800063e:	fa00 fc03 	lsl.w	ip, r0, r3
 8000642:	fa20 f002 	lsr.w	r0, r0, r2
 8000646:	fa01 fe03 	lsl.w	lr, r1, r3
 800064a:	ea40 000e 	orr.w	r0, r0, lr
 800064e:	fa21 f102 	lsr.w	r1, r1, r2
 8000652:	4414      	add	r4, r2
 8000654:	e6c1      	b.n	80003da <__adddf3+0xe6>
 8000656:	bf00      	nop

08000658 <__aeabi_dmul>:
 8000658:	b570      	push	{r4, r5, r6, lr}
 800065a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800065e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000662:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000666:	bf1d      	ittte	ne
 8000668:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800066c:	ea94 0f0c 	teqne	r4, ip
 8000670:	ea95 0f0c 	teqne	r5, ip
 8000674:	f000 f8de 	bleq	8000834 <__aeabi_dmul+0x1dc>
 8000678:	442c      	add	r4, r5
 800067a:	ea81 0603 	eor.w	r6, r1, r3
 800067e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000682:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000686:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800068a:	bf18      	it	ne
 800068c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000690:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000694:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000698:	d038      	beq.n	800070c <__aeabi_dmul+0xb4>
 800069a:	fba0 ce02 	umull	ip, lr, r0, r2
 800069e:	f04f 0500 	mov.w	r5, #0
 80006a2:	fbe1 e502 	umlal	lr, r5, r1, r2
 80006a6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80006aa:	fbe0 e503 	umlal	lr, r5, r0, r3
 80006ae:	f04f 0600 	mov.w	r6, #0
 80006b2:	fbe1 5603 	umlal	r5, r6, r1, r3
 80006b6:	f09c 0f00 	teq	ip, #0
 80006ba:	bf18      	it	ne
 80006bc:	f04e 0e01 	orrne.w	lr, lr, #1
 80006c0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80006c4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80006c8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80006cc:	d204      	bcs.n	80006d8 <__aeabi_dmul+0x80>
 80006ce:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80006d2:	416d      	adcs	r5, r5
 80006d4:	eb46 0606 	adc.w	r6, r6, r6
 80006d8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006dc:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006e0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006e4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006e8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006ec:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006f0:	bf88      	it	hi
 80006f2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006f6:	d81e      	bhi.n	8000736 <__aeabi_dmul+0xde>
 80006f8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006fc:	bf08      	it	eq
 80006fe:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000702:	f150 0000 	adcs.w	r0, r0, #0
 8000706:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800070a:	bd70      	pop	{r4, r5, r6, pc}
 800070c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000710:	ea46 0101 	orr.w	r1, r6, r1
 8000714:	ea40 0002 	orr.w	r0, r0, r2
 8000718:	ea81 0103 	eor.w	r1, r1, r3
 800071c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000720:	bfc2      	ittt	gt
 8000722:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000726:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800072a:	bd70      	popgt	{r4, r5, r6, pc}
 800072c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000730:	f04f 0e00 	mov.w	lr, #0
 8000734:	3c01      	subs	r4, #1
 8000736:	f300 80ab 	bgt.w	8000890 <__aeabi_dmul+0x238>
 800073a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800073e:	bfde      	ittt	le
 8000740:	2000      	movle	r0, #0
 8000742:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000746:	bd70      	pople	{r4, r5, r6, pc}
 8000748:	f1c4 0400 	rsb	r4, r4, #0
 800074c:	3c20      	subs	r4, #32
 800074e:	da35      	bge.n	80007bc <__aeabi_dmul+0x164>
 8000750:	340c      	adds	r4, #12
 8000752:	dc1b      	bgt.n	800078c <__aeabi_dmul+0x134>
 8000754:	f104 0414 	add.w	r4, r4, #20
 8000758:	f1c4 0520 	rsb	r5, r4, #32
 800075c:	fa00 f305 	lsl.w	r3, r0, r5
 8000760:	fa20 f004 	lsr.w	r0, r0, r4
 8000764:	fa01 f205 	lsl.w	r2, r1, r5
 8000768:	ea40 0002 	orr.w	r0, r0, r2
 800076c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000770:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000774:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000778:	fa21 f604 	lsr.w	r6, r1, r4
 800077c:	eb42 0106 	adc.w	r1, r2, r6
 8000780:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000784:	bf08      	it	eq
 8000786:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800078a:	bd70      	pop	{r4, r5, r6, pc}
 800078c:	f1c4 040c 	rsb	r4, r4, #12
 8000790:	f1c4 0520 	rsb	r5, r4, #32
 8000794:	fa00 f304 	lsl.w	r3, r0, r4
 8000798:	fa20 f005 	lsr.w	r0, r0, r5
 800079c:	fa01 f204 	lsl.w	r2, r1, r4
 80007a0:	ea40 0002 	orr.w	r0, r0, r2
 80007a4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007a8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80007ac:	f141 0100 	adc.w	r1, r1, #0
 80007b0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007b4:	bf08      	it	eq
 80007b6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007ba:	bd70      	pop	{r4, r5, r6, pc}
 80007bc:	f1c4 0520 	rsb	r5, r4, #32
 80007c0:	fa00 f205 	lsl.w	r2, r0, r5
 80007c4:	ea4e 0e02 	orr.w	lr, lr, r2
 80007c8:	fa20 f304 	lsr.w	r3, r0, r4
 80007cc:	fa01 f205 	lsl.w	r2, r1, r5
 80007d0:	ea43 0302 	orr.w	r3, r3, r2
 80007d4:	fa21 f004 	lsr.w	r0, r1, r4
 80007d8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007dc:	fa21 f204 	lsr.w	r2, r1, r4
 80007e0:	ea20 0002 	bic.w	r0, r0, r2
 80007e4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007e8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007ec:	bf08      	it	eq
 80007ee:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007f2:	bd70      	pop	{r4, r5, r6, pc}
 80007f4:	f094 0f00 	teq	r4, #0
 80007f8:	d10f      	bne.n	800081a <__aeabi_dmul+0x1c2>
 80007fa:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007fe:	0040      	lsls	r0, r0, #1
 8000800:	eb41 0101 	adc.w	r1, r1, r1
 8000804:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000808:	bf08      	it	eq
 800080a:	3c01      	subeq	r4, #1
 800080c:	d0f7      	beq.n	80007fe <__aeabi_dmul+0x1a6>
 800080e:	ea41 0106 	orr.w	r1, r1, r6
 8000812:	f095 0f00 	teq	r5, #0
 8000816:	bf18      	it	ne
 8000818:	4770      	bxne	lr
 800081a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800081e:	0052      	lsls	r2, r2, #1
 8000820:	eb43 0303 	adc.w	r3, r3, r3
 8000824:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000828:	bf08      	it	eq
 800082a:	3d01      	subeq	r5, #1
 800082c:	d0f7      	beq.n	800081e <__aeabi_dmul+0x1c6>
 800082e:	ea43 0306 	orr.w	r3, r3, r6
 8000832:	4770      	bx	lr
 8000834:	ea94 0f0c 	teq	r4, ip
 8000838:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800083c:	bf18      	it	ne
 800083e:	ea95 0f0c 	teqne	r5, ip
 8000842:	d00c      	beq.n	800085e <__aeabi_dmul+0x206>
 8000844:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000848:	bf18      	it	ne
 800084a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800084e:	d1d1      	bne.n	80007f4 <__aeabi_dmul+0x19c>
 8000850:	ea81 0103 	eor.w	r1, r1, r3
 8000854:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000858:	f04f 0000 	mov.w	r0, #0
 800085c:	bd70      	pop	{r4, r5, r6, pc}
 800085e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000862:	bf06      	itte	eq
 8000864:	4610      	moveq	r0, r2
 8000866:	4619      	moveq	r1, r3
 8000868:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800086c:	d019      	beq.n	80008a2 <__aeabi_dmul+0x24a>
 800086e:	ea94 0f0c 	teq	r4, ip
 8000872:	d102      	bne.n	800087a <__aeabi_dmul+0x222>
 8000874:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000878:	d113      	bne.n	80008a2 <__aeabi_dmul+0x24a>
 800087a:	ea95 0f0c 	teq	r5, ip
 800087e:	d105      	bne.n	800088c <__aeabi_dmul+0x234>
 8000880:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000884:	bf1c      	itt	ne
 8000886:	4610      	movne	r0, r2
 8000888:	4619      	movne	r1, r3
 800088a:	d10a      	bne.n	80008a2 <__aeabi_dmul+0x24a>
 800088c:	ea81 0103 	eor.w	r1, r1, r3
 8000890:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000894:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000898:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800089c:	f04f 0000 	mov.w	r0, #0
 80008a0:	bd70      	pop	{r4, r5, r6, pc}
 80008a2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80008a6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80008aa:	bd70      	pop	{r4, r5, r6, pc}

080008ac <__aeabi_ddiv>:
 80008ac:	b570      	push	{r4, r5, r6, lr}
 80008ae:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80008b2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80008b6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80008ba:	bf1d      	ittte	ne
 80008bc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80008c0:	ea94 0f0c 	teqne	r4, ip
 80008c4:	ea95 0f0c 	teqne	r5, ip
 80008c8:	f000 f8a7 	bleq	8000a1a <__aeabi_ddiv+0x16e>
 80008cc:	eba4 0405 	sub.w	r4, r4, r5
 80008d0:	ea81 0e03 	eor.w	lr, r1, r3
 80008d4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008d8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008dc:	f000 8088 	beq.w	80009f0 <__aeabi_ddiv+0x144>
 80008e0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008e4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008e8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008ec:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008f0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008f4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008f8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008fc:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000900:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000904:	429d      	cmp	r5, r3
 8000906:	bf08      	it	eq
 8000908:	4296      	cmpeq	r6, r2
 800090a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800090e:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000912:	d202      	bcs.n	800091a <__aeabi_ddiv+0x6e>
 8000914:	085b      	lsrs	r3, r3, #1
 8000916:	ea4f 0232 	mov.w	r2, r2, rrx
 800091a:	1ab6      	subs	r6, r6, r2
 800091c:	eb65 0503 	sbc.w	r5, r5, r3
 8000920:	085b      	lsrs	r3, r3, #1
 8000922:	ea4f 0232 	mov.w	r2, r2, rrx
 8000926:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800092a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800092e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000932:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000936:	bf22      	ittt	cs
 8000938:	1ab6      	subcs	r6, r6, r2
 800093a:	4675      	movcs	r5, lr
 800093c:	ea40 000c 	orrcs.w	r0, r0, ip
 8000940:	085b      	lsrs	r3, r3, #1
 8000942:	ea4f 0232 	mov.w	r2, r2, rrx
 8000946:	ebb6 0e02 	subs.w	lr, r6, r2
 800094a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800094e:	bf22      	ittt	cs
 8000950:	1ab6      	subcs	r6, r6, r2
 8000952:	4675      	movcs	r5, lr
 8000954:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000958:	085b      	lsrs	r3, r3, #1
 800095a:	ea4f 0232 	mov.w	r2, r2, rrx
 800095e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000962:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000966:	bf22      	ittt	cs
 8000968:	1ab6      	subcs	r6, r6, r2
 800096a:	4675      	movcs	r5, lr
 800096c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000970:	085b      	lsrs	r3, r3, #1
 8000972:	ea4f 0232 	mov.w	r2, r2, rrx
 8000976:	ebb6 0e02 	subs.w	lr, r6, r2
 800097a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800097e:	bf22      	ittt	cs
 8000980:	1ab6      	subcs	r6, r6, r2
 8000982:	4675      	movcs	r5, lr
 8000984:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000988:	ea55 0e06 	orrs.w	lr, r5, r6
 800098c:	d018      	beq.n	80009c0 <__aeabi_ddiv+0x114>
 800098e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000992:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000996:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800099a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800099e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80009a2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80009a6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80009aa:	d1c0      	bne.n	800092e <__aeabi_ddiv+0x82>
 80009ac:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009b0:	d10b      	bne.n	80009ca <__aeabi_ddiv+0x11e>
 80009b2:	ea41 0100 	orr.w	r1, r1, r0
 80009b6:	f04f 0000 	mov.w	r0, #0
 80009ba:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80009be:	e7b6      	b.n	800092e <__aeabi_ddiv+0x82>
 80009c0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009c4:	bf04      	itt	eq
 80009c6:	4301      	orreq	r1, r0
 80009c8:	2000      	moveq	r0, #0
 80009ca:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80009ce:	bf88      	it	hi
 80009d0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80009d4:	f63f aeaf 	bhi.w	8000736 <__aeabi_dmul+0xde>
 80009d8:	ebb5 0c03 	subs.w	ip, r5, r3
 80009dc:	bf04      	itt	eq
 80009de:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009e2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009e6:	f150 0000 	adcs.w	r0, r0, #0
 80009ea:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009ee:	bd70      	pop	{r4, r5, r6, pc}
 80009f0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009f4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009f8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009fc:	bfc2      	ittt	gt
 80009fe:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000a02:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000a06:	bd70      	popgt	{r4, r5, r6, pc}
 8000a08:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000a0c:	f04f 0e00 	mov.w	lr, #0
 8000a10:	3c01      	subs	r4, #1
 8000a12:	e690      	b.n	8000736 <__aeabi_dmul+0xde>
 8000a14:	ea45 0e06 	orr.w	lr, r5, r6
 8000a18:	e68d      	b.n	8000736 <__aeabi_dmul+0xde>
 8000a1a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000a1e:	ea94 0f0c 	teq	r4, ip
 8000a22:	bf08      	it	eq
 8000a24:	ea95 0f0c 	teqeq	r5, ip
 8000a28:	f43f af3b 	beq.w	80008a2 <__aeabi_dmul+0x24a>
 8000a2c:	ea94 0f0c 	teq	r4, ip
 8000a30:	d10a      	bne.n	8000a48 <__aeabi_ddiv+0x19c>
 8000a32:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a36:	f47f af34 	bne.w	80008a2 <__aeabi_dmul+0x24a>
 8000a3a:	ea95 0f0c 	teq	r5, ip
 8000a3e:	f47f af25 	bne.w	800088c <__aeabi_dmul+0x234>
 8000a42:	4610      	mov	r0, r2
 8000a44:	4619      	mov	r1, r3
 8000a46:	e72c      	b.n	80008a2 <__aeabi_dmul+0x24a>
 8000a48:	ea95 0f0c 	teq	r5, ip
 8000a4c:	d106      	bne.n	8000a5c <__aeabi_ddiv+0x1b0>
 8000a4e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a52:	f43f aefd 	beq.w	8000850 <__aeabi_dmul+0x1f8>
 8000a56:	4610      	mov	r0, r2
 8000a58:	4619      	mov	r1, r3
 8000a5a:	e722      	b.n	80008a2 <__aeabi_dmul+0x24a>
 8000a5c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a60:	bf18      	it	ne
 8000a62:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a66:	f47f aec5 	bne.w	80007f4 <__aeabi_dmul+0x19c>
 8000a6a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a6e:	f47f af0d 	bne.w	800088c <__aeabi_dmul+0x234>
 8000a72:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a76:	f47f aeeb 	bne.w	8000850 <__aeabi_dmul+0x1f8>
 8000a7a:	e712      	b.n	80008a2 <__aeabi_dmul+0x24a>

08000a7c <__aeabi_d2uiz>:
 8000a7c:	004a      	lsls	r2, r1, #1
 8000a7e:	d211      	bcs.n	8000aa4 <__aeabi_d2uiz+0x28>
 8000a80:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000a84:	d211      	bcs.n	8000aaa <__aeabi_d2uiz+0x2e>
 8000a86:	d50d      	bpl.n	8000aa4 <__aeabi_d2uiz+0x28>
 8000a88:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000a8c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000a90:	d40e      	bmi.n	8000ab0 <__aeabi_d2uiz+0x34>
 8000a92:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a96:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000a9a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000a9e:	fa23 f002 	lsr.w	r0, r3, r2
 8000aa2:	4770      	bx	lr
 8000aa4:	f04f 0000 	mov.w	r0, #0
 8000aa8:	4770      	bx	lr
 8000aaa:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000aae:	d102      	bne.n	8000ab6 <__aeabi_d2uiz+0x3a>
 8000ab0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000ab4:	4770      	bx	lr
 8000ab6:	f04f 0000 	mov.w	r0, #0
 8000aba:	4770      	bx	lr

08000abc <memcpy>:
 8000abc:	e352000f 	cmp	r2, #15
 8000ac0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 8000ac4:	9a000029 	bls	8000b70 <memcpy+0xb4>
 8000ac8:	e1813000 	orr	r3, r1, r0
 8000acc:	e3130003 	tst	r3, #3
 8000ad0:	1a000031 	bne	8000b9c <memcpy+0xe0>
 8000ad4:	e1a0e002 	mov	lr, r2
 8000ad8:	e280c010 	add	ip, r0, #16
 8000adc:	e2813010 	add	r3, r1, #16
 8000ae0:	e5137010 	ldr	r7, [r3, #-16]
 8000ae4:	e513600c 	ldr	r6, [r3, #-12]
 8000ae8:	e5135008 	ldr	r5, [r3, #-8]
 8000aec:	e5134004 	ldr	r4, [r3, #-4]
 8000af0:	e24ee010 	sub	lr, lr, #16
 8000af4:	e35e000f 	cmp	lr, #15
 8000af8:	e50c7010 	str	r7, [ip, #-16]
 8000afc:	e50c600c 	str	r6, [ip, #-12]
 8000b00:	e50c5008 	str	r5, [ip, #-8]
 8000b04:	e50c4004 	str	r4, [ip, #-4]
 8000b08:	e2833010 	add	r3, r3, #16
 8000b0c:	e28cc010 	add	ip, ip, #16
 8000b10:	8afffff2 	bhi	8000ae0 <memcpy+0x24>
 8000b14:	e2423010 	sub	r3, r2, #16
 8000b18:	e3c3300f 	bic	r3, r3, #15
 8000b1c:	e202600f 	and	r6, r2, #15
 8000b20:	e2833010 	add	r3, r3, #16
 8000b24:	e3560003 	cmp	r6, #3
 8000b28:	e0811003 	add	r1, r1, r3
 8000b2c:	e0803003 	add	r3, r0, r3
 8000b30:	9a00001b 	bls	8000ba4 <memcpy+0xe8>
 8000b34:	e1a04001 	mov	r4, r1
 8000b38:	e1a0c006 	mov	ip, r6
 8000b3c:	e243e004 	sub	lr, r3, #4
 8000b40:	e24cc004 	sub	ip, ip, #4
 8000b44:	e4945004 	ldr	r5, [r4], #4
 8000b48:	e35c0003 	cmp	ip, #3
 8000b4c:	e5ae5004 	str	r5, [lr, #4]!
 8000b50:	8afffffa 	bhi	8000b40 <memcpy+0x84>
 8000b54:	e246c004 	sub	ip, r6, #4
 8000b58:	e3ccc003 	bic	ip, ip, #3
 8000b5c:	e28cc004 	add	ip, ip, #4
 8000b60:	e083300c 	add	r3, r3, ip
 8000b64:	e081100c 	add	r1, r1, ip
 8000b68:	e2022003 	and	r2, r2, #3
 8000b6c:	ea000000 	b	8000b74 <memcpy+0xb8>
 8000b70:	e1a03000 	mov	r3, r0
 8000b74:	e3520000 	cmp	r2, #0
 8000b78:	0a000005 	beq	8000b94 <memcpy+0xd8>
 8000b7c:	e2433001 	sub	r3, r3, #1
 8000b80:	e0812002 	add	r2, r1, r2
 8000b84:	e4d1c001 	ldrb	ip, [r1], #1
 8000b88:	e1510002 	cmp	r1, r2
 8000b8c:	e5e3c001 	strb	ip, [r3, #1]!
 8000b90:	1afffffb 	bne	8000b84 <memcpy+0xc8>
 8000b94:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
 8000b98:	e12fff1e 	bx	lr
 8000b9c:	e1a03000 	mov	r3, r0
 8000ba0:	eafffff5 	b	8000b7c <memcpy+0xc0>
 8000ba4:	e1a02006 	mov	r2, r6
 8000ba8:	eafffff1 	b	8000b74 <memcpy+0xb8>
 8000bac:	00000000 	andeq	r0, r0, r0

08000bb0 <notify2.lto_priv.44>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8000bb0:	4a02      	ldr	r2, [pc, #8]	; (8000bbc <notify2.lto_priv.44+0xc>)
 8000bb2:	68d3      	ldr	r3, [r2, #12]
 8000bb4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000bb8:	60d3      	str	r3, [r2, #12]
 8000bba:	4770      	bx	lr
 8000bbc:	40004400 	.word	0x40004400

08000bc0 <pwm_lld_serve_interrupt>:
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8000bc0:	6983      	ldr	r3, [r0, #24]
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8000bc2:	b570      	push	{r4, r5, r6, lr}
  sr  = pwmp->tim->SR;
 8000bc4:	691c      	ldr	r4, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8000bc6:	68da      	ldr	r2, [r3, #12]
 8000bc8:	4014      	ands	r4, r2
 8000bca:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 8000bcc:	43d2      	mvns	r2, r2
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8000bce:	07a6      	lsls	r6, r4, #30
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8000bd0:	4605      	mov	r5, r0
  pwmp->tim->SR = ~sr;
 8000bd2:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8000bd4:	d503      	bpl.n	8000bde <pwm_lld_serve_interrupt+0x1e>
      (pwmp->config->channels[0].callback != NULL))
 8000bd6:	6843      	ldr	r3, [r0, #4]
 8000bd8:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8000bda:	b103      	cbz	r3, 8000bde <pwm_lld_serve_interrupt+0x1e>
    pwmp->config->channels[0].callback(pwmp);
 8000bdc:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8000bde:	0760      	lsls	r0, r4, #29
 8000be0:	d504      	bpl.n	8000bec <pwm_lld_serve_interrupt+0x2c>
      (pwmp->config->channels[1].callback != NULL))
 8000be2:	686b      	ldr	r3, [r5, #4]
 8000be4:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8000be6:	b10b      	cbz	r3, 8000bec <pwm_lld_serve_interrupt+0x2c>
    pwmp->config->channels[1].callback(pwmp);
 8000be8:	4628      	mov	r0, r5
 8000bea:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8000bec:	0721      	lsls	r1, r4, #28
 8000bee:	d504      	bpl.n	8000bfa <pwm_lld_serve_interrupt+0x3a>
      (pwmp->config->channels[2].callback != NULL))
 8000bf0:	686b      	ldr	r3, [r5, #4]
 8000bf2:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8000bf4:	b10b      	cbz	r3, 8000bfa <pwm_lld_serve_interrupt+0x3a>
    pwmp->config->channels[2].callback(pwmp);
 8000bf6:	4628      	mov	r0, r5
 8000bf8:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8000bfa:	06e2      	lsls	r2, r4, #27
 8000bfc:	d504      	bpl.n	8000c08 <pwm_lld_serve_interrupt+0x48>
      (pwmp->config->channels[3].callback != NULL))
 8000bfe:	686b      	ldr	r3, [r5, #4]
 8000c00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8000c02:	b10b      	cbz	r3, 8000c08 <pwm_lld_serve_interrupt+0x48>
    pwmp->config->channels[3].callback(pwmp);
 8000c04:	4628      	mov	r0, r5
 8000c06:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8000c08:	07e3      	lsls	r3, r4, #31
 8000c0a:	d506      	bpl.n	8000c1a <pwm_lld_serve_interrupt+0x5a>
 8000c0c:	686b      	ldr	r3, [r5, #4]
 8000c0e:	689b      	ldr	r3, [r3, #8]
 8000c10:	b11b      	cbz	r3, 8000c1a <pwm_lld_serve_interrupt+0x5a>
    pwmp->config->callback(pwmp);
 8000c12:	4628      	mov	r0, r5
}
 8000c14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pwmp->config->callback(pwmp);
 8000c18:	4718      	bx	r3
 8000c1a:	bd70      	pop	{r4, r5, r6, pc}
 8000c1c:	0000      	movs	r0, r0
	...

08000c20 <spi_lld_serve_tx_interrupt.lto_priv.58>:
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000c20:	f011 0f0c 	tst.w	r1, #12
 8000c24:	d100      	bne.n	8000c28 <spi_lld_serve_tx_interrupt.lto_priv.58+0x8>
 8000c26:	4770      	bx	lr
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c28:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000c2a:	4b02      	ldr	r3, [pc, #8]	; (8000c34 <spi_lld_serve_tx_interrupt.lto_priv.58+0x14>)
 8000c2c:	4a02      	ldr	r2, [pc, #8]	; (8000c38 <spi_lld_serve_tx_interrupt.lto_priv.58+0x18>)
 8000c2e:	62da      	str	r2, [r3, #44]	; 0x2c
 8000c30:	e7fe      	b.n	8000c30 <spi_lld_serve_tx_interrupt.lto_priv.58+0x10>
 8000c32:	bf00      	nop
 8000c34:	20000cc4 	.word	0x20000cc4
 8000c38:	08003044 	.word	0x08003044
 8000c3c:	00000000 	.word	0x00000000

08000c40 <_ctl.lto_priv.56>:
#else
    break;
#endif
  }
  return MSG_OK;
}
 8000c40:	2000      	movs	r0, #0
 8000c42:	4770      	bx	lr
	...

08000c50 <spi_lld_serve_rx_interrupt.lto_priv.57>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000c50:	f011 0f0c 	tst.w	r1, #12
 8000c54:	d14b      	bne.n	8000cee <spi_lld_serve_rx_interrupt.lto_priv.57+0x9e>
  if (spip->config->circular) {
 8000c56:	6843      	ldr	r3, [r0, #4]
 8000c58:	781a      	ldrb	r2, [r3, #0]
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8000c5a:	b570      	push	{r4, r5, r6, lr}
 8000c5c:	4604      	mov	r4, r0
  if (spip->config->circular) {
 8000c5e:	b13a      	cbz	r2, 8000c70 <spi_lld_serve_rx_interrupt.lto_priv.57+0x20>
    if ((flags & STM32_DMA_ISR_HTIF) != 0U) {
 8000c60:	06ce      	lsls	r6, r1, #27
      _spi_isr_code_half1(spip);
 8000c62:	685b      	ldr	r3, [r3, #4]
    if ((flags & STM32_DMA_ISR_HTIF) != 0U) {
 8000c64:	d538      	bpl.n	8000cd8 <spi_lld_serve_rx_interrupt.lto_priv.57+0x88>
      _spi_isr_code_half1(spip);
 8000c66:	2b00      	cmp	r3, #0
 8000c68:	d035      	beq.n	8000cd6 <spi_lld_serve_rx_interrupt.lto_priv.57+0x86>
}
 8000c6a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      _spi_isr_code_half1(spip);
 8000c6e:	4718      	bx	r3
    dmaStreamDisable(spip->dmatx);
 8000c70:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8000c72:	680a      	ldr	r2, [r1, #0]
 8000c74:	6810      	ldr	r0, [r2, #0]
 8000c76:	f020 001f 	bic.w	r0, r0, #31
 8000c7a:	6010      	str	r0, [r2, #0]
 8000c7c:	6810      	ldr	r0, [r2, #0]
 8000c7e:	07c5      	lsls	r5, r0, #31
 8000c80:	d4fc      	bmi.n	8000c7c <spi_lld_serve_rx_interrupt.lto_priv.57+0x2c>
 8000c82:	7a0e      	ldrb	r6, [r1, #8]
    dmaStreamDisable(spip->dmarx);
 8000c84:	6a22      	ldr	r2, [r4, #32]
    dmaStreamDisable(spip->dmatx);
 8000c86:	684d      	ldr	r5, [r1, #4]
    dmaStreamDisable(spip->dmarx);
 8000c88:	6811      	ldr	r1, [r2, #0]
    dmaStreamDisable(spip->dmatx);
 8000c8a:	203d      	movs	r0, #61	; 0x3d
 8000c8c:	40b0      	lsls	r0, r6
 8000c8e:	6028      	str	r0, [r5, #0]
    dmaStreamDisable(spip->dmarx);
 8000c90:	6808      	ldr	r0, [r1, #0]
 8000c92:	f020 001f 	bic.w	r0, r0, #31
 8000c96:	6008      	str	r0, [r1, #0]
 8000c98:	6808      	ldr	r0, [r1, #0]
 8000c9a:	07c0      	lsls	r0, r0, #31
 8000c9c:	d4fc      	bmi.n	8000c98 <spi_lld_serve_rx_interrupt.lto_priv.57+0x48>
 8000c9e:	7a10      	ldrb	r0, [r2, #8]
    _spi_isr_code(spip);
 8000ca0:	6859      	ldr	r1, [r3, #4]
    dmaStreamDisable(spip->dmarx);
 8000ca2:	6852      	ldr	r2, [r2, #4]
 8000ca4:	233d      	movs	r3, #61	; 0x3d
 8000ca6:	4083      	lsls	r3, r0
 8000ca8:	6013      	str	r3, [r2, #0]
    _spi_isr_code(spip);
 8000caa:	b329      	cbz	r1, 8000cf8 <spi_lld_serve_rx_interrupt.lto_priv.57+0xa8>
 8000cac:	2304      	movs	r3, #4
 8000cae:	7023      	strb	r3, [r4, #0]
 8000cb0:	4620      	mov	r0, r4
 8000cb2:	4788      	blx	r1
 8000cb4:	7823      	ldrb	r3, [r4, #0]
 8000cb6:	2b04      	cmp	r3, #4
 8000cb8:	d01e      	beq.n	8000cf8 <spi_lld_serve_rx_interrupt.lto_priv.57+0xa8>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000cba:	2320      	movs	r3, #32
 8000cbc:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8000cc0:	68a3      	ldr	r3, [r4, #8]
 8000cc2:	b12b      	cbz	r3, 8000cd0 <spi_lld_serve_rx_interrupt.lto_priv.57+0x80>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8000cc4:	2200      	movs	r2, #0
 8000cc6:	60a2      	str	r2, [r4, #8]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8000cc8:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
 8000cca:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000ccc:	f001 fd08 	bl	80026e0 <chSchReadyI>
 8000cd0:	2300      	movs	r3, #0
 8000cd2:	f383 8811 	msr	BASEPRI, r3
 8000cd6:	bd70      	pop	{r4, r5, r6, pc}
      _spi_isr_code_half2(spip);
 8000cd8:	2b00      	cmp	r3, #0
 8000cda:	d0fc      	beq.n	8000cd6 <spi_lld_serve_rx_interrupt.lto_priv.57+0x86>
 8000cdc:	2204      	movs	r2, #4
 8000cde:	7002      	strb	r2, [r0, #0]
 8000ce0:	4798      	blx	r3
 8000ce2:	7823      	ldrb	r3, [r4, #0]
 8000ce4:	2b04      	cmp	r3, #4
 8000ce6:	d1f6      	bne.n	8000cd6 <spi_lld_serve_rx_interrupt.lto_priv.57+0x86>
 8000ce8:	2303      	movs	r3, #3
 8000cea:	7023      	strb	r3, [r4, #0]
 8000cec:	bd70      	pop	{r4, r5, r6, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8000cee:	b672      	cpsid	i
 8000cf0:	4b03      	ldr	r3, [pc, #12]	; (8000d00 <spi_lld_serve_rx_interrupt.lto_priv.57+0xb0>)
 8000cf2:	4a04      	ldr	r2, [pc, #16]	; (8000d04 <spi_lld_serve_rx_interrupt.lto_priv.57+0xb4>)
 8000cf4:	62da      	str	r2, [r3, #44]	; 0x2c
 8000cf6:	e7fe      	b.n	8000cf6 <spi_lld_serve_rx_interrupt.lto_priv.57+0xa6>
    _spi_isr_code(spip);
 8000cf8:	2302      	movs	r3, #2
 8000cfa:	7023      	strb	r3, [r4, #0]
 8000cfc:	e7dd      	b.n	8000cba <spi_lld_serve_rx_interrupt.lto_priv.57+0x6a>
 8000cfe:	bf00      	nop
 8000d00:	20000cc4 	.word	0x20000cc4
 8000d04:	08003044 	.word	0x08003044
	...

08000d10 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8000d10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000d12:	4604      	mov	r4, r0
 8000d14:	460f      	mov	r7, r1
 8000d16:	4616      	mov	r6, r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000d18:	2320      	movs	r3, #32
 8000d1a:	f383 8811 	msr	BASEPRI, r3
 8000d1e:	e003      	b.n	8000d28 <oqPutTimeout+0x18>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
 8000d20:	f001 fca6 	bl	8002670 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000d24:	2800      	cmp	r0, #0
 8000d26:	db19      	blt.n	8000d5c <oqPutTimeout+0x4c>
  while (oqIsFullI(oqp)) {
 8000d28:	68a5      	ldr	r5, [r4, #8]
 8000d2a:	4631      	mov	r1, r6
 8000d2c:	4620      	mov	r0, r4
 8000d2e:	2d00      	cmp	r5, #0
 8000d30:	d0f6      	beq.n	8000d20 <oqPutTimeout+0x10>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8000d32:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
 8000d34:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000d36:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 8000d38:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8000d3a:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
 8000d3c:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000d3e:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000d40:	6923      	ldr	r3, [r4, #16]
 8000d42:	6962      	ldr	r2, [r4, #20]
 8000d44:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8000d46:	bf24      	itt	cs
 8000d48:	68e3      	ldrcs	r3, [r4, #12]
 8000d4a:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8000d4c:	69e3      	ldr	r3, [r4, #28]
 8000d4e:	b10b      	cbz	r3, 8000d54 <oqPutTimeout+0x44>
    oqp->q_notify(oqp);
 8000d50:	4620      	mov	r0, r4
 8000d52:	4798      	blx	r3
 8000d54:	2000      	movs	r0, #0
 8000d56:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
 8000d5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000d5c:	f385 8811 	msr	BASEPRI, r5
 8000d60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000d62:	bf00      	nop
	...

08000d70 <_putt.lto_priv.52>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000d70:	3030      	adds	r0, #48	; 0x30
 8000d72:	f7ff bfcd 	b.w	8000d10 <oqPutTimeout>
 8000d76:	bf00      	nop
	...

08000d80 <_put.lto_priv.50>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000d80:	3030      	adds	r0, #48	; 0x30
 8000d82:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000d86:	f7ff bfc3 	b.w	8000d10 <oqPutTimeout>
 8000d8a:	bf00      	nop
 8000d8c:	0000      	movs	r0, r0
	...

08000d90 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8000d90:	b570      	push	{r4, r5, r6, lr}
 8000d92:	2320      	movs	r3, #32
 8000d94:	4604      	mov	r4, r0
 8000d96:	460e      	mov	r6, r1
 8000d98:	f383 8811 	msr	BASEPRI, r3
 8000d9c:	e003      	b.n	8000da6 <iqGetTimeout+0x16>
 8000d9e:	f001 fc67 	bl	8002670 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8000da2:	2800      	cmp	r0, #0
 8000da4:	db1a      	blt.n	8000ddc <iqGetTimeout+0x4c>
  while (iqIsEmptyI(iqp)) {
 8000da6:	68a5      	ldr	r5, [r4, #8]
 8000da8:	4631      	mov	r1, r6
 8000daa:	4620      	mov	r0, r4
 8000dac:	2d00      	cmp	r5, #0
 8000dae:	d0f6      	beq.n	8000d9e <iqGetTimeout+0xe>
  b = *iqp->q_rdptr++;
 8000db0:	69a1      	ldr	r1, [r4, #24]
  iqp->q_counter--;
 8000db2:	68a3      	ldr	r3, [r4, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000db4:	6920      	ldr	r0, [r4, #16]
  b = *iqp->q_rdptr++;
 8000db6:	1c4a      	adds	r2, r1, #1
  iqp->q_counter--;
 8000db8:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 8000dba:	4282      	cmp	r2, r0
  iqp->q_counter--;
 8000dbc:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8000dbe:	61a2      	str	r2, [r4, #24]
    iqp->q_rdptr = iqp->q_buffer;
 8000dc0:	bf28      	it	cs
 8000dc2:	68e3      	ldrcs	r3, [r4, #12]
  b = *iqp->q_rdptr++;
 8000dc4:	780d      	ldrb	r5, [r1, #0]
    iqp->q_rdptr = iqp->q_buffer;
 8000dc6:	bf28      	it	cs
 8000dc8:	61a3      	strcs	r3, [r4, #24]
  if (iqp->q_notify != NULL) {
 8000dca:	69e3      	ldr	r3, [r4, #28]
 8000dcc:	b10b      	cbz	r3, 8000dd2 <iqGetTimeout+0x42>
    iqp->q_notify(iqp);
 8000dce:	4620      	mov	r0, r4
 8000dd0:	4798      	blx	r3
 8000dd2:	2300      	movs	r3, #0
 8000dd4:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 8000dd8:	4628      	mov	r0, r5
}
 8000dda:	bd70      	pop	{r4, r5, r6, pc}
 8000ddc:	f385 8811 	msr	BASEPRI, r5
 8000de0:	bd70      	pop	{r4, r5, r6, pc}
 8000de2:	bf00      	nop
	...

08000df0 <_gett.lto_priv.53>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000df0:	300c      	adds	r0, #12
 8000df2:	f7ff bfcd 	b.w	8000d90 <iqGetTimeout>
 8000df6:	bf00      	nop
	...

08000e00 <_get.lto_priv.51>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000e00:	300c      	adds	r0, #12
 8000e02:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8000e06:	f7ff bfc3 	b.w	8000d90 <iqGetTimeout>
 8000e0a:	bf00      	nop
 8000e0c:	0000      	movs	r0, r0
	...

08000e10 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8000e10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000e14:	b083      	sub	sp, #12
 8000e16:	4617      	mov	r7, r2
 8000e18:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 8000e1a:	f8d0 a01c 	ldr.w	sl, [r0, #28]
 8000e1e:	f04f 0b20 	mov.w	fp, #32
 8000e22:	f38b 8811 	msr	BASEPRI, fp

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (wr < n) {
 8000e26:	2a00      	cmp	r2, #0
 8000e28:	d051      	beq.n	8000ece <oqWriteTimeout+0xbe>
 8000e2a:	4604      	mov	r4, r0
 8000e2c:	460e      	mov	r6, r1
 8000e2e:	f04f 0800 	mov.w	r8, #0
 8000e32:	e017      	b.n	8000e64 <oqWriteTimeout+0x54>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000e34:	462a      	mov	r2, r5
 8000e36:	4631      	mov	r1, r6
 8000e38:	f7ff fe40 	bl	8000abc <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8000e3c:	68e3      	ldr	r3, [r4, #12]
 8000e3e:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 8000e40:	68a3      	ldr	r3, [r4, #8]
 8000e42:	1b5b      	subs	r3, r3, r5
 8000e44:	60a3      	str	r3, [r4, #8]
    size_t done;

    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
 8000e46:	b36d      	cbz	r5, 8000ea4 <oqWriteTimeout+0x94>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 8000e48:	f1ba 0f00 	cmp.w	sl, #0
 8000e4c:	d001      	beq.n	8000e52 <oqWriteTimeout+0x42>
        nfy(oqp);
 8000e4e:	4620      	mov	r0, r4
 8000e50:	47d0      	blx	sl
 8000e52:	2300      	movs	r3, #0
 8000e54:	f383 8811 	msr	BASEPRI, r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      wr += done;
 8000e58:	44a8      	add	r8, r5
      bp += done;
 8000e5a:	442e      	add	r6, r5
 8000e5c:	f38b 8811 	msr	BASEPRI, fp
  while (wr < n) {
 8000e60:	4547      	cmp	r7, r8
 8000e62:	d925      	bls.n	8000eb0 <oqWriteTimeout+0xa0>
  if (n > oqGetEmptyI(oqp)) {
 8000e64:	68a3      	ldr	r3, [r4, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8000e66:	6960      	ldr	r0, [r4, #20]
  if (n > oqGetEmptyI(oqp)) {
 8000e68:	429f      	cmp	r7, r3
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8000e6a:	6923      	ldr	r3, [r4, #16]
    n = oqGetEmptyI(oqp);
 8000e6c:	bf8c      	ite	hi
 8000e6e:	68a5      	ldrhi	r5, [r4, #8]
  if (n > oqGetEmptyI(oqp)) {
 8000e70:	463d      	movls	r5, r7
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8000e72:	1a1b      	subs	r3, r3, r0
  if (n < s1) {
 8000e74:	42ab      	cmp	r3, r5
 8000e76:	d822      	bhi.n	8000ebe <oqWriteTimeout+0xae>
  else if (n > s1) {
 8000e78:	d2dc      	bcs.n	8000e34 <oqWriteTimeout+0x24>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8000e7a:	461a      	mov	r2, r3
 8000e7c:	4631      	mov	r1, r6
    s2 = n - s1;
 8000e7e:	eba5 0903 	sub.w	r9, r5, r3
 8000e82:	9300      	str	r3, [sp, #0]
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8000e84:	f7ff fe1a 	bl	8000abc <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8000e88:	9b00      	ldr	r3, [sp, #0]
 8000e8a:	68e0      	ldr	r0, [r4, #12]
 8000e8c:	18f1      	adds	r1, r6, r3
 8000e8e:	464a      	mov	r2, r9
 8000e90:	f7ff fe14 	bl	8000abc <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8000e94:	68e3      	ldr	r3, [r4, #12]
 8000e96:	444b      	add	r3, r9
 8000e98:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 8000e9a:	68a3      	ldr	r3, [r4, #8]
 8000e9c:	1b5b      	subs	r3, r3, r5
 8000e9e:	60a3      	str	r3, [r4, #8]
    if (done == (size_t)0) {
 8000ea0:	2d00      	cmp	r5, #0
 8000ea2:	d1d1      	bne.n	8000e48 <oqWriteTimeout+0x38>
 8000ea4:	9901      	ldr	r1, [sp, #4]
 8000ea6:	4620      	mov	r0, r4
 8000ea8:	f001 fbe2 	bl	8002670 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8000eac:	2800      	cmp	r0, #0
 8000eae:	d0d7      	beq.n	8000e60 <oqWriteTimeout+0x50>
 8000eb0:	2300      	movs	r3, #0
 8000eb2:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return wr;
}
 8000eb6:	4640      	mov	r0, r8
 8000eb8:	b003      	add	sp, #12
 8000eba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000ebe:	462a      	mov	r2, r5
 8000ec0:	4631      	mov	r1, r6
 8000ec2:	f7ff fdfb 	bl	8000abc <memcpy>
    oqp->q_wrptr += n;
 8000ec6:	6963      	ldr	r3, [r4, #20]
 8000ec8:	442b      	add	r3, r5
 8000eca:	6163      	str	r3, [r4, #20]
 8000ecc:	e7b8      	b.n	8000e40 <oqWriteTimeout+0x30>
  size_t wr = 0;
 8000ece:	4690      	mov	r8, r2
 8000ed0:	e7ee      	b.n	8000eb0 <oqWriteTimeout+0xa0>
 8000ed2:	bf00      	nop
	...

08000ee0 <_writet.lto_priv.54>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000ee0:	3030      	adds	r0, #48	; 0x30
 8000ee2:	f7ff bf95 	b.w	8000e10 <oqWriteTimeout>
 8000ee6:	bf00      	nop
	...

08000ef0 <_write.lto_priv.48>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000ef0:	3030      	adds	r0, #48	; 0x30
 8000ef2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000ef6:	f7ff bf8b 	b.w	8000e10 <oqWriteTimeout>
 8000efa:	bf00      	nop
 8000efc:	0000      	movs	r0, r0
	...

08000f00 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 8000f00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000f04:	b083      	sub	sp, #12
 8000f06:	4617      	mov	r7, r2
 8000f08:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = iqp->q_notify;
 8000f0a:	f8d0 a01c 	ldr.w	sl, [r0, #28]
 8000f0e:	f04f 0b20 	mov.w	fp, #32
 8000f12:	f38b 8811 	msr	BASEPRI, fp
  while (rd < n) {
 8000f16:	2a00      	cmp	r2, #0
 8000f18:	d051      	beq.n	8000fbe <iqReadTimeout+0xbe>
 8000f1a:	4604      	mov	r4, r0
 8000f1c:	460e      	mov	r6, r1
 8000f1e:	f04f 0800 	mov.w	r8, #0
 8000f22:	e017      	b.n	8000f54 <iqReadTimeout+0x54>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000f24:	462a      	mov	r2, r5
 8000f26:	4630      	mov	r0, r6
 8000f28:	f7ff fdc8 	bl	8000abc <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8000f2c:	68e3      	ldr	r3, [r4, #12]
 8000f2e:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 8000f30:	68a3      	ldr	r3, [r4, #8]
 8000f32:	1b5b      	subs	r3, r3, r5
 8000f34:	60a3      	str	r3, [r4, #8]
    if (done == (size_t)0) {
 8000f36:	b36d      	cbz	r5, 8000f94 <iqReadTimeout+0x94>
      if (nfy != NULL) {
 8000f38:	f1ba 0f00 	cmp.w	sl, #0
 8000f3c:	d001      	beq.n	8000f42 <iqReadTimeout+0x42>
        nfy(iqp);
 8000f3e:	4620      	mov	r0, r4
 8000f40:	47d0      	blx	sl
 8000f42:	2300      	movs	r3, #0
 8000f44:	f383 8811 	msr	BASEPRI, r3
      rd += done;
 8000f48:	44a8      	add	r8, r5
      bp += done;
 8000f4a:	442e      	add	r6, r5
 8000f4c:	f38b 8811 	msr	BASEPRI, fp
  while (rd < n) {
 8000f50:	4547      	cmp	r7, r8
 8000f52:	d925      	bls.n	8000fa0 <iqReadTimeout+0xa0>
  if (n > iqGetFullI(iqp)) {
 8000f54:	68a3      	ldr	r3, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000f56:	69a1      	ldr	r1, [r4, #24]
  if (n > iqGetFullI(iqp)) {
 8000f58:	429f      	cmp	r7, r3
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000f5a:	6923      	ldr	r3, [r4, #16]
    n = iqGetFullI(iqp);
 8000f5c:	bf8c      	ite	hi
 8000f5e:	68a5      	ldrhi	r5, [r4, #8]
  if (n > iqGetFullI(iqp)) {
 8000f60:	463d      	movls	r5, r7
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000f62:	1a5b      	subs	r3, r3, r1
  if (n < s1) {
 8000f64:	42ab      	cmp	r3, r5
 8000f66:	d822      	bhi.n	8000fae <iqReadTimeout+0xae>
  else if (n > s1) {
 8000f68:	d2dc      	bcs.n	8000f24 <iqReadTimeout+0x24>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8000f6a:	461a      	mov	r2, r3
 8000f6c:	4630      	mov	r0, r6
    s2 = n - s1;
 8000f6e:	eba5 0903 	sub.w	r9, r5, r3
 8000f72:	9300      	str	r3, [sp, #0]
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8000f74:	f7ff fda2 	bl	8000abc <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8000f78:	9b00      	ldr	r3, [sp, #0]
 8000f7a:	68e1      	ldr	r1, [r4, #12]
 8000f7c:	18f0      	adds	r0, r6, r3
 8000f7e:	464a      	mov	r2, r9
 8000f80:	f7ff fd9c 	bl	8000abc <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 8000f84:	68e3      	ldr	r3, [r4, #12]
 8000f86:	444b      	add	r3, r9
 8000f88:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 8000f8a:	68a3      	ldr	r3, [r4, #8]
 8000f8c:	1b5b      	subs	r3, r3, r5
 8000f8e:	60a3      	str	r3, [r4, #8]
    if (done == (size_t)0) {
 8000f90:	2d00      	cmp	r5, #0
 8000f92:	d1d1      	bne.n	8000f38 <iqReadTimeout+0x38>
 8000f94:	9901      	ldr	r1, [sp, #4]
 8000f96:	4620      	mov	r0, r4
 8000f98:	f001 fb6a 	bl	8002670 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8000f9c:	2800      	cmp	r0, #0
 8000f9e:	d0d7      	beq.n	8000f50 <iqReadTimeout+0x50>
 8000fa0:	2300      	movs	r3, #0
 8000fa2:	f383 8811 	msr	BASEPRI, r3
}
 8000fa6:	4640      	mov	r0, r8
 8000fa8:	b003      	add	sp, #12
 8000faa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000fae:	462a      	mov	r2, r5
 8000fb0:	4630      	mov	r0, r6
 8000fb2:	f7ff fd83 	bl	8000abc <memcpy>
    iqp->q_rdptr += n;
 8000fb6:	69a3      	ldr	r3, [r4, #24]
 8000fb8:	442b      	add	r3, r5
 8000fba:	61a3      	str	r3, [r4, #24]
 8000fbc:	e7b8      	b.n	8000f30 <iqReadTimeout+0x30>
  size_t rd = 0;
 8000fbe:	4690      	mov	r8, r2
 8000fc0:	e7ee      	b.n	8000fa0 <iqReadTimeout+0xa0>
 8000fc2:	bf00      	nop
	...

08000fd0 <_readt.lto_priv.55>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000fd0:	300c      	adds	r0, #12
 8000fd2:	f7ff bf95 	b.w	8000f00 <iqReadTimeout>
 8000fd6:	bf00      	nop
	...

08000fe0 <_read.lto_priv.49>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000fe0:	300c      	adds	r0, #12
 8000fe2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000fe6:	f7ff bf8b 	b.w	8000f00 <iqReadTimeout>
 8000fea:	bf00      	nop
 8000fec:	0000      	movs	r0, r0
	...

08000ff0 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8000ff0:	4a86      	ldr	r2, [pc, #536]	; (800120c <__early_init+0x21c>)
  gpiop->OTYPER  = config->otyper;
 8000ff2:	f8df c24c 	ldr.w	ip, [pc, #588]	; 8001240 <__early_init+0x250>
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8000ff6:	6911      	ldr	r1, [r2, #16]
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8000ff8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8000ffc:	f240 19ff 	movw	r9, #511	; 0x1ff
 8001000:	2300      	movs	r3, #0
 8001002:	ea41 0109 	orr.w	r1, r1, r9
 8001006:	6111      	str	r1, [r2, #16]
 8001008:	6113      	str	r3, [r2, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 800100a:	6b11      	ldr	r1, [r2, #48]	; 0x30
  gpiop->OTYPER  = config->otyper;
 800100c:	4f80      	ldr	r7, [pc, #512]	; (8001210 <__early_init+0x220>)
 800100e:	4e81      	ldr	r6, [pc, #516]	; (8001214 <__early_init+0x224>)
 8001010:	4d81      	ldr	r5, [pc, #516]	; (8001218 <__early_init+0x228>)
 8001012:	f8df e230 	ldr.w	lr, [pc, #560]	; 8001244 <__early_init+0x254>
 8001016:	4c81      	ldr	r4, [pc, #516]	; (800121c <__early_init+0x22c>)
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8001018:	ea41 0109 	orr.w	r1, r1, r9
 800101c:	6311      	str	r1, [r2, #48]	; 0x30
 800101e:	6d11      	ldr	r1, [r2, #80]	; 0x50
 8001020:	ea41 0909 	orr.w	r9, r1, r9
 8001024:	f8c2 9050 	str.w	r9, [r2, #80]	; 0x50
  gpiop->OSPEEDR = config->ospeedr;
 8001028:	f46f 49a8 	mvn.w	r9, #21504	; 0x5400
  gpiop->OTYPER  = config->otyper;
 800102c:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001030:	f8cc 9008 	str.w	r9, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 8001034:	f8df 9210 	ldr.w	r9, [pc, #528]	; 8001248 <__early_init+0x258>
 8001038:	f8cc 900c 	str.w	r9, [ip, #12]
  gpiop->ODR     = config->odr;
 800103c:	f64f 71ff 	movw	r1, #65535	; 0xffff
  gpiop->AFRL    = config->afrl;
 8001040:	f8df 9208 	ldr.w	r9, [pc, #520]	; 800124c <__early_init+0x25c>
  gpiop->ODR     = config->odr;
 8001044:	f8cc 1014 	str.w	r1, [ip, #20]
  gpiop->AFRL    = config->afrl;
 8001048:	f8cc 9020 	str.w	r9, [ip, #32]
  gpiop->AFRH    = config->afrh;
 800104c:	f8df 9200 	ldr.w	r9, [pc, #512]	; 8001250 <__early_init+0x260>
 8001050:	f8cc 9024 	str.w	r9, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001054:	f109 592a 	add.w	r9, r9, #713031680	; 0x2a800000
 8001058:	f509 19b0 	add.w	r9, r9, #1441792	; 0x160000
 800105c:	f8cc 9000 	str.w	r9, [ip]
  gpiop->OTYPER  = config->otyper;
 8001060:	f44f 7c10 	mov.w	ip, #576	; 0x240
 8001064:	f8c7 c004 	str.w	ip, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001068:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  gpiop->PUPDR   = config->pupdr;
 800106c:	f8df c1e4 	ldr.w	ip, [pc, #484]	; 8001254 <__early_init+0x264>
  gpiop->OSPEEDR = config->ospeedr;
 8001070:	60b8      	str	r0, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8001072:	f8c7 c00c 	str.w	ip, [r7, #12]
  gpiop->AFRL    = config->afrl;
 8001076:	f04f 6c80 	mov.w	ip, #67108864	; 0x4000000
  gpiop->ODR     = config->odr;
 800107a:	6179      	str	r1, [r7, #20]
  gpiop->AFRL    = config->afrl;
 800107c:	f8c7 c020 	str.w	ip, [r7, #32]
  gpiop->MODER   = config->moder;
 8001080:	f8df c1d4 	ldr.w	ip, [pc, #468]	; 8001258 <__early_init+0x268>
  gpiop->AFRH    = config->afrh;
 8001084:	f04f 0840 	mov.w	r8, #64	; 0x40
 8001088:	f8c7 8024 	str.w	r8, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800108c:	f8c7 c000 	str.w	ip, [r7]
  gpiop->PUPDR   = config->pupdr;
 8001090:	f10c 4caa 	add.w	ip, ip, #1426063360	; 0x55000000
 8001094:	f5ac 0c43 	sub.w	ip, ip, #12779520	; 0xc30000
 8001098:	f6ac 3c2c 	subw	ip, ip, #2860	; 0xb2c
  gpiop->OTYPER  = config->otyper;
 800109c:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800109e:	60b0      	str	r0, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 80010a0:	f8c6 c00c 	str.w	ip, [r6, #12]
  gpiop->AFRL    = config->afrl;
 80010a4:	f04f 4cc0 	mov.w	ip, #1610612736	; 0x60000000
  gpiop->ODR     = config->odr;
 80010a8:	6171      	str	r1, [r6, #20]
  gpiop->AFRL    = config->afrl;
 80010aa:	f8c6 c020 	str.w	ip, [r6, #32]
  gpiop->AFRH    = config->afrh;
 80010ae:	f8df c1ac 	ldr.w	ip, [pc, #428]	; 800125c <__early_init+0x26c>
 80010b2:	f8c6 c024 	str.w	ip, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80010b6:	f8df c1a8 	ldr.w	ip, [pc, #424]	; 8001260 <__early_init+0x270>
 80010ba:	f8c6 c000 	str.w	ip, [r6]
  gpiop->PUPDR   = config->pupdr;
 80010be:	f8df c1a4 	ldr.w	ip, [pc, #420]	; 8001264 <__early_init+0x274>
  gpiop->OTYPER  = config->otyper;
 80010c2:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80010c4:	60a8      	str	r0, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 80010c6:	f8c5 c00c 	str.w	ip, [r5, #12]
  gpiop->ODR     = config->odr;
 80010ca:	f640 7cff 	movw	ip, #4095	; 0xfff
 80010ce:	f8c5 c014 	str.w	ip, [r5, #20]
  gpiop->OTYPER  = config->otyper;
 80010d2:	f507 5780 	add.w	r7, r7, #4096	; 0x1000
  gpiop->MODER   = config->moder;
 80010d6:	f8df c190 	ldr.w	ip, [pc, #400]	; 8001268 <__early_init+0x278>
  gpiop->AFRL    = config->afrl;
 80010da:	622b      	str	r3, [r5, #32]
  gpiop->OTYPER  = config->otyper;
 80010dc:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
  gpiop->AFRH    = config->afrh;
 80010e0:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80010e2:	f8c5 c000 	str.w	ip, [r5]
  gpiop->OTYPER  = config->otyper;
 80010e6:	f505 5580 	add.w	r5, r5, #4096	; 0x1000
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 80010ea:	f8df c138 	ldr.w	ip, [pc, #312]	; 8001224 <__early_init+0x234>
 80010ee:	f8ce 3004 	str.w	r3, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80010f2:	f8ce 0008 	str.w	r0, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 80010f6:	f8ce 300c 	str.w	r3, [lr, #12]
  gpiop->ODR     = config->odr;
 80010fa:	f8ce 1014 	str.w	r1, [lr, #20]
  gpiop->AFRL    = config->afrl;
 80010fe:	f8ce 3020 	str.w	r3, [lr, #32]
  gpiop->AFRH    = config->afrh;
 8001102:	f8ce 3024 	str.w	r3, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001106:	f8ce 8000 	str.w	r8, [lr]
  gpiop->OTYPER  = config->otyper;
 800110a:	607b      	str	r3, [r7, #4]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800110c:	f04f 5e80 	mov.w	lr, #268435456	; 0x10000000
  gpiop->OSPEEDR = config->ospeedr;
 8001110:	60b8      	str	r0, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8001112:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 8001114:	6179      	str	r1, [r7, #20]
  gpiop->AFRL    = config->afrl;
 8001116:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8001118:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800111a:	603b      	str	r3, [r7, #0]
  PWR->CR = STM32_VOS;
 800111c:	f44f 4740 	mov.w	r7, #49152	; 0xc000
  gpiop->OTYPER  = config->otyper;
 8001120:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001122:	60b0      	str	r0, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8001124:	60f3      	str	r3, [r6, #12]
  gpiop->ODR     = config->odr;
 8001126:	6171      	str	r1, [r6, #20]
  gpiop->AFRL    = config->afrl;
 8001128:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
 800112a:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800112c:	6033      	str	r3, [r6, #0]
  gpiop->OTYPER  = config->otyper;
 800112e:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001130:	60a8      	str	r0, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 8001132:	60eb      	str	r3, [r5, #12]
  gpiop->ODR     = config->odr;
 8001134:	6169      	str	r1, [r5, #20]
  gpiop->AFRL    = config->afrl;
 8001136:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8001138:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800113a:	602b      	str	r3, [r5, #0]
  gpiop->OTYPER  = config->otyper;
 800113c:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800113e:	60a0      	str	r0, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8001140:	60e3      	str	r3, [r4, #12]
  gpiop->ODR     = config->odr;
 8001142:	6161      	str	r1, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8001144:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8001146:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001148:	6023      	str	r3, [r4, #0]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800114a:	f8c2 e040 	str.w	lr, [r2, #64]	; 0x40
  PWR->CR = STM32_VOS;
 800114e:	f8cc 7000 	str.w	r7, [ip]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001152:	6813      	ldr	r3, [r2, #0]
 8001154:	f043 0301 	orr.w	r3, r3, #1
 8001158:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800115a:	4613      	mov	r3, r2
 800115c:	681a      	ldr	r2, [r3, #0]
 800115e:	0794      	lsls	r4, r2, #30
 8001160:	d5fc      	bpl.n	800115c <__early_init+0x16c>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8001162:	6899      	ldr	r1, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001164:	4a29      	ldr	r2, [pc, #164]	; (800120c <__early_init+0x21c>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8001166:	f021 0103 	bic.w	r1, r1, #3
 800116a:	6099      	str	r1, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800116c:	6893      	ldr	r3, [r2, #8]
 800116e:	f013 030c 	ands.w	r3, r3, #12
 8001172:	d1fb      	bne.n	800116c <__early_init+0x17c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001174:	6810      	ldr	r0, [r2, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8001176:	4925      	ldr	r1, [pc, #148]	; (800120c <__early_init+0x21c>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001178:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
 800117c:	6010      	str	r0, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800117e:	6093      	str	r3, [r2, #8]
  RCC->CR |= RCC_CR_HSEON;
 8001180:	6813      	ldr	r3, [r2, #0]
 8001182:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001186:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8001188:	680b      	ldr	r3, [r1, #0]
 800118a:	0398      	lsls	r0, r3, #14
 800118c:	d5fc      	bpl.n	8001188 <__early_init+0x198>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800118e:	6f4b      	ldr	r3, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001190:	4a1e      	ldr	r2, [pc, #120]	; (800120c <__early_init+0x21c>)
  RCC->CSR |= RCC_CSR_LSION;
 8001192:	f043 0301 	orr.w	r3, r3, #1
 8001196:	674b      	str	r3, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001198:	6f53      	ldr	r3, [r2, #116]	; 0x74
 800119a:	0799      	lsls	r1, r3, #30
 800119c:	d5fc      	bpl.n	8001198 <__early_init+0x1a8>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 800119e:	4b20      	ldr	r3, [pc, #128]	; (8001220 <__early_init+0x230>)
 80011a0:	6053      	str	r3, [r2, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 80011a2:	6813      	ldr	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80011a4:	491f      	ldr	r1, [pc, #124]	; (8001224 <__early_init+0x234>)
  RCC->CR |= RCC_CR_PLLON;
 80011a6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80011aa:	6013      	str	r3, [r2, #0]
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80011ac:	684b      	ldr	r3, [r1, #4]
 80011ae:	045a      	lsls	r2, r3, #17
 80011b0:	d5fc      	bpl.n	80011ac <__early_init+0x1bc>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80011b2:	4a16      	ldr	r2, [pc, #88]	; (800120c <__early_init+0x21c>)
 80011b4:	6813      	ldr	r3, [r2, #0]
 80011b6:	019b      	lsls	r3, r3, #6
 80011b8:	d5fc      	bpl.n	80011b4 <__early_init+0x1c4>

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80011ba:	4b1b      	ldr	r3, [pc, #108]	; (8001228 <__early_init+0x238>)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80011bc:	491b      	ldr	r1, [pc, #108]	; (800122c <__early_init+0x23c>)
 80011be:	6091      	str	r1, [r2, #8]
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80011c0:	681a      	ldr	r2, [r3, #0]
 80011c2:	4b1b      	ldr	r3, [pc, #108]	; (8001230 <__early_init+0x240>)
 80011c4:	429a      	cmp	r2, r3
 80011c6:	d017      	beq.n	80011f8 <__early_init+0x208>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80011c8:	4b1a      	ldr	r3, [pc, #104]	; (8001234 <__early_init+0x244>)
 80011ca:	f240 7205 	movw	r2, #1797	; 0x705
 80011ce:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80011d0:	4a0e      	ldr	r2, [pc, #56]	; (800120c <__early_init+0x21c>)
 80011d2:	6893      	ldr	r3, [r2, #8]
 80011d4:	f043 0302 	orr.w	r3, r3, #2
 80011d8:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80011da:	6893      	ldr	r3, [r2, #8]
 80011dc:	f003 030c 	and.w	r3, r3, #12
 80011e0:	2b08      	cmp	r3, #8
 80011e2:	d1fa      	bne.n	80011da <__early_init+0x1ea>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 80011e4:	6c53      	ldr	r3, [r2, #68]	; 0x44
 80011e6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80011ea:	6453      	str	r3, [r2, #68]	; 0x44
 80011ec:	6e53      	ldr	r3, [r2, #100]	; 0x64
 80011ee:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80011f2:	6653      	str	r3, [r2, #100]	; 0x64
 80011f4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80011f8:	4a0f      	ldr	r2, [pc, #60]	; (8001238 <__early_init+0x248>)
 80011fa:	4b10      	ldr	r3, [pc, #64]	; (800123c <__early_init+0x24c>)
 80011fc:	6812      	ldr	r2, [r2, #0]
 80011fe:	429a      	cmp	r2, r3
 8001200:	d1e2      	bne.n	80011c8 <__early_init+0x1d8>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 8001202:	4b0c      	ldr	r3, [pc, #48]	; (8001234 <__early_init+0x244>)
 8001204:	f240 1205 	movw	r2, #261	; 0x105
 8001208:	601a      	str	r2, [r3, #0]
 800120a:	e7e1      	b.n	80011d0 <__early_init+0x1e0>
 800120c:	40023800 	.word	0x40023800
 8001210:	40020400 	.word	0x40020400
 8001214:	40020800 	.word	0x40020800
 8001218:	40020c00 	.word	0x40020c00
 800121c:	40022000 	.word	0x40022000
 8001220:	07405408 	.word	0x07405408
 8001224:	40007000 	.word	0x40007000
 8001228:	e0042000 	.word	0xe0042000
 800122c:	38889400 	.word	0x38889400
 8001230:	20006411 	.word	0x20006411
 8001234:	40023c00 	.word	0x40023c00
 8001238:	e000ed00 	.word	0xe000ed00
 800123c:	410fc241 	.word	0x410fc241
 8001240:	40020000 	.word	0x40020000
 8001244:	40021000 	.word	0x40021000
 8001248:	40010054 	.word	0x40010054
 800124c:	55560000 	.word	0x55560000
 8001250:	000aaa00 	.word	0x000aaa00
 8001254:	55514515 	.word	0x55514515
 8001258:	00082080 	.word	0x00082080
 800125c:	00060600 	.word	0x00060600
 8001260:	02208001 	.word	0x02208001
 8001264:	00555055 	.word	0x00555055
 8001268:	55000100 	.word	0x55000100
 800126c:	00000000 	.word	0x00000000

08001270 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8001270:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  USART_TypeDef *u = sdp->usart;
 8001274:	4d69      	ldr	r5, [pc, #420]	; (800141c <VectorD8+0x1ac>)
 8001276:	6f6e      	ldr	r6, [r5, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8001278:	f8d6 800c 	ldr.w	r8, [r6, #12]
  uint16_t sr = u->SR;
 800127c:	6833      	ldr	r3, [r6, #0]
  if (sr & USART_SR_LBD) {
 800127e:	05da      	lsls	r2, r3, #23
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8001280:	b083      	sub	sp, #12
  uint16_t sr = u->SR;
 8001282:	b29c      	uxth	r4, r3
  if (sr & USART_SR_LBD) {
 8001284:	d47c      	bmi.n	8001380 <VectorD8+0x110>
 8001286:	2320      	movs	r3, #32
 8001288:	f383 8811 	msr	BASEPRI, r3
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800128c:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001290:	d049      	beq.n	8001326 <VectorD8+0xb6>
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8001292:	4f63      	ldr	r7, [pc, #396]	; (8001420 <VectorD8+0x1b0>)

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8001294:	f04f 0900 	mov.w	r9, #0
 8001298:	e007      	b.n	80012aa <VectorD8+0x3a>
    if (sr & USART_SR_RXNE)
 800129a:	06a1      	lsls	r1, r4, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 800129c:	6873      	ldr	r3, [r6, #4]
    if (sr & USART_SR_RXNE)
 800129e:	d41c      	bmi.n	80012da <VectorD8+0x6a>
    sr = u->SR;
 80012a0:	6834      	ldr	r4, [r6, #0]
 80012a2:	b2a4      	uxth	r4, r4
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80012a4:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80012a8:	d03d      	beq.n	8001326 <VectorD8+0xb6>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80012aa:	0723      	lsls	r3, r4, #28
 80012ac:	d0f5      	beq.n	800129a <VectorD8+0x2a>
    sts |= SD_OVERRUN_ERROR;
 80012ae:	f014 0f08 	tst.w	r4, #8
 80012b2:	bf0c      	ite	eq
 80012b4:	2000      	moveq	r0, #0
 80012b6:	2080      	movne	r0, #128	; 0x80
  if (sr & USART_SR_PE)
 80012b8:	07e1      	lsls	r1, r4, #31
    sts |= SD_PARITY_ERROR;
 80012ba:	bf48      	it	mi
 80012bc:	f040 0020 	orrmi.w	r0, r0, #32
  if (sr & USART_SR_FE)
 80012c0:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 80012c2:	bf48      	it	mi
 80012c4:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40
  if (sr & USART_SR_NE)
 80012c8:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 80012ca:	bf48      	it	mi
 80012cc:	f440 7080 	orrmi.w	r0, r0, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80012d0:	f001 fbbe 	bl	8002a50 <chEvtBroadcastFlagsI.constprop.30>
    if (sr & USART_SR_RXNE)
 80012d4:	06a1      	lsls	r1, r4, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 80012d6:	6873      	ldr	r3, [r6, #4]
    if (sr & USART_SR_RXNE)
 80012d8:	d5e2      	bpl.n	80012a0 <VectorD8+0x30>
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80012da:	696a      	ldr	r2, [r5, #20]
    b = (uint8_t)u->DR & sdp->rxmask;
 80012dc:	f895 4078 	ldrb.w	r4, [r5, #120]	; 0x78
 80012e0:	2a00      	cmp	r2, #0
 80012e2:	d03c      	beq.n	800135e <VectorD8+0xee>
  if (!iqIsFullI(iqp)) {
 80012e4:	6a2a      	ldr	r2, [r5, #32]
 80012e6:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80012e8:	428a      	cmp	r2, r1
 80012ea:	d041      	beq.n	8001370 <VectorD8+0x100>
    iqp->q_counter++;
 80012ec:	6969      	ldr	r1, [r5, #20]
 80012ee:	4023      	ands	r3, r4
    *iqp->q_wrptr++ = b;
 80012f0:	1c50      	adds	r0, r2, #1
    iqp->q_counter++;
 80012f2:	3101      	adds	r1, #1
    *iqp->q_wrptr++ = b;
 80012f4:	6228      	str	r0, [r5, #32]
    iqp->q_counter++;
 80012f6:	6169      	str	r1, [r5, #20]
    *iqp->q_wrptr++ = b;
 80012f8:	7013      	strb	r3, [r2, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 80012fa:	6a2a      	ldr	r2, [r5, #32]
 80012fc:	69eb      	ldr	r3, [r5, #28]
 80012fe:	429a      	cmp	r2, r3
 8001300:	d301      	bcc.n	8001306 <VectorD8+0x96>
      iqp->q_wrptr = iqp->q_buffer;
 8001302:	69ab      	ldr	r3, [r5, #24]
 8001304:	622b      	str	r3, [r5, #32]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8001306:	68eb      	ldr	r3, [r5, #12]
 8001308:	42bb      	cmp	r3, r7
 800130a:	d0c9      	beq.n	80012a0 <VectorD8+0x30>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800130c:	681a      	ldr	r2, [r3, #0]
 800130e:	60ea      	str	r2, [r5, #12]
  (void) chSchReadyI(tp);
 8001310:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
 8001312:	6057      	str	r7, [r2, #4]
  tp->u.rdymsg = msg;
 8001314:	f8c3 9024 	str.w	r9, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8001318:	f001 f9e2 	bl	80026e0 <chSchReadyI>
    sr = u->SR;
 800131c:	6834      	ldr	r4, [r6, #0]
 800131e:	b2a4      	uxth	r4, r4
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8001320:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001324:	d1c1      	bne.n	80012aa <VectorD8+0x3a>
 8001326:	2300      	movs	r3, #0
 8001328:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 800132c:	f018 0f80 	tst.w	r8, #128	; 0x80
 8001330:	d001      	beq.n	8001336 <VectorD8+0xc6>
 8001332:	0622      	lsls	r2, r4, #24
 8001334:	d432      	bmi.n	800139c <VectorD8+0x12c>
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 8001336:	f018 0f40 	tst.w	r8, #64	; 0x40
 800133a:	d00b      	beq.n	8001354 <VectorD8+0xe4>
 800133c:	0663      	lsls	r3, r4, #25
 800133e:	d509      	bpl.n	8001354 <VectorD8+0xe4>
 8001340:	2320      	movs	r3, #32
 8001342:	f383 8811 	msr	BASEPRI, r3
    if (oqIsEmptyI(&sdp->oqueue)) {
 8001346:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8001348:	6cab      	ldr	r3, [r5, #72]	; 0x48
 800134a:	429a      	cmp	r2, r3
 800134c:	d04b      	beq.n	80013e6 <VectorD8+0x176>
 800134e:	2300      	movs	r3, #0
 8001350:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
}
 8001354:	b003      	add	sp, #12
 8001356:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
 800135a:	f001 b921 	b.w	80025a0 <_port_irq_epilogue>
 800135e:	2004      	movs	r0, #4
 8001360:	9301      	str	r3, [sp, #4]
 8001362:	f001 fb75 	bl	8002a50 <chEvtBroadcastFlagsI.constprop.30>
  if (!iqIsFullI(iqp)) {
 8001366:	6a2a      	ldr	r2, [r5, #32]
 8001368:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800136a:	9b01      	ldr	r3, [sp, #4]
 800136c:	428a      	cmp	r2, r1
 800136e:	d1bd      	bne.n	80012ec <VectorD8+0x7c>
 8001370:	6969      	ldr	r1, [r5, #20]
 8001372:	2900      	cmp	r1, #0
 8001374:	d0ba      	beq.n	80012ec <VectorD8+0x7c>
 8001376:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800137a:	f001 fb69 	bl	8002a50 <chEvtBroadcastFlagsI.constprop.30>
 800137e:	e78f      	b.n	80012a0 <VectorD8+0x30>
 8001380:	2320      	movs	r3, #32
 8001382:	f383 8811 	msr	BASEPRI, r3
 8001386:	f44f 7000 	mov.w	r0, #512	; 0x200
 800138a:	f001 fb61 	bl	8002a50 <chEvtBroadcastFlagsI.constprop.30>
    u->SR = ~USART_SR_LBD;
 800138e:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8001392:	6033      	str	r3, [r6, #0]
 8001394:	2300      	movs	r3, #0
 8001396:	f383 8811 	msr	BASEPRI, r3
 800139a:	e774      	b.n	8001286 <VectorD8+0x16>
 800139c:	2320      	movs	r3, #32
 800139e:	f383 8811 	msr	BASEPRI, r3
  if (!oqIsEmptyI(oqp)) {
 80013a2:	6cab      	ldr	r3, [r5, #72]	; 0x48
 80013a4:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 80013a6:	429a      	cmp	r2, r3
 80013a8:	d029      	beq.n	80013fe <VectorD8+0x18e>
    oqp->q_counter++;
 80013aa:	6baa      	ldr	r2, [r5, #56]	; 0x38
    if (oqp->q_rdptr >= oqp->q_top) {
 80013ac:	6c29      	ldr	r1, [r5, #64]	; 0x40
    b = *oqp->q_rdptr++;
 80013ae:	1c58      	adds	r0, r3, #1
    oqp->q_counter++;
 80013b0:	3201      	adds	r2, #1
 80013b2:	63aa      	str	r2, [r5, #56]	; 0x38
    b = *oqp->q_rdptr++;
 80013b4:	64a8      	str	r0, [r5, #72]	; 0x48
    if (oqp->q_rdptr >= oqp->q_top) {
 80013b6:	4288      	cmp	r0, r1
    b = *oqp->q_rdptr++;
 80013b8:	781f      	ldrb	r7, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 80013ba:	d301      	bcc.n	80013c0 <VectorD8+0x150>
      oqp->q_rdptr = oqp->q_buffer;
 80013bc:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 80013be:	64ab      	str	r3, [r5, #72]	; 0x48
  return (bool)(tqp->next != (const thread_t *)tqp);
 80013c0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80013c2:	4a18      	ldr	r2, [pc, #96]	; (8001424 <VectorD8+0x1b4>)
 80013c4:	4293      	cmp	r3, r2
 80013c6:	d009      	beq.n	80013dc <VectorD8+0x16c>
  tqp->next             = tp->queue.next;
 80013c8:	6819      	ldr	r1, [r3, #0]
 80013ca:	6329      	str	r1, [r5, #48]	; 0x30
  tp->u.rdymsg = msg;
 80013cc:	f04f 0e00 	mov.w	lr, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80013d0:	604a      	str	r2, [r1, #4]
  (void) chSchReadyI(tp);
 80013d2:	4618      	mov	r0, r3
  tp->u.rdymsg = msg;
 80013d4:	f8c3 e024 	str.w	lr, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 80013d8:	f001 f982 	bl	80026e0 <chSchReadyI>
      u->DR = b;
 80013dc:	6077      	str	r7, [r6, #4]
 80013de:	2300      	movs	r3, #0
 80013e0:	f383 8811 	msr	BASEPRI, r3
 80013e4:	e7a7      	b.n	8001336 <VectorD8+0xc6>
    if (oqIsEmptyI(&sdp->oqueue)) {
 80013e6:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80013e8:	2b00      	cmp	r3, #0
 80013ea:	d0b0      	beq.n	800134e <VectorD8+0xde>
 80013ec:	2010      	movs	r0, #16
 80013ee:	f001 fb2f 	bl	8002a50 <chEvtBroadcastFlagsI.constprop.30>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 80013f2:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 80013f6:	ea08 0303 	and.w	r3, r8, r3
 80013fa:	60f3      	str	r3, [r6, #12]
 80013fc:	e7a7      	b.n	800134e <VectorD8+0xde>
  if (!oqIsEmptyI(oqp)) {
 80013fe:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8001400:	2a00      	cmp	r2, #0
 8001402:	d0d2      	beq.n	80013aa <VectorD8+0x13a>
 8001404:	2008      	movs	r0, #8
 8001406:	f001 fb23 	bl	8002a50 <chEvtBroadcastFlagsI.constprop.30>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800140a:	f64f 733f 	movw	r3, #65343	; 0xff3f
 800140e:	ea08 0303 	and.w	r3, r8, r3
 8001412:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001416:	60f3      	str	r3, [r6, #12]
 8001418:	e7e1      	b.n	80013de <VectorD8+0x16e>
 800141a:	bf00      	nop
 800141c:	20000c18 	.word	0x20000c18
 8001420:	20000c24 	.word	0x20000c24
 8001424:	20000c48 	.word	0x20000c48
	...

08001430 <VectorB8>:
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8001430:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD4);
 8001432:	4803      	ldr	r0, [pc, #12]	; (8001440 <VectorB8+0x10>)
 8001434:	f7ff fbc4 	bl	8000bc0 <pwm_lld_serve_interrupt>
}
 8001438:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800143c:	f001 b8b0 	b.w	80025a0 <_port_irq_epilogue>
 8001440:	2000086c 	.word	0x2000086c
	...

08001450 <VectorB4>:
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8001450:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD3);
 8001452:	4803      	ldr	r0, [pc, #12]	; (8001460 <VectorB4+0x10>)
 8001454:	f7ff fbb4 	bl	8000bc0 <pwm_lld_serve_interrupt>
}
 8001458:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800145c:	f001 b8a0 	b.w	80025a0 <_port_irq_epilogue>
 8001460:	20000850 	.word	0x20000850
	...

08001470 <VectorA4>:
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8001470:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD1);
 8001472:	4803      	ldr	r0, [pc, #12]	; (8001480 <VectorA4+0x10>)
 8001474:	f7ff fba4 	bl	8000bc0 <pwm_lld_serve_interrupt>
}
 8001478:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800147c:	f001 b890 	b.w	80025a0 <_port_irq_epilogue>
 8001480:	20000834 	.word	0x20000834
	...

08001490 <VectorAC>:
 8001490:	f7ff bfee 	b.w	8001470 <VectorA4>
	...

080014a0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80014a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80014a4:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 80014a8:	693b      	ldr	r3, [r7, #16]
 80014aa:	079b      	lsls	r3, r3, #30
 80014ac:	d403      	bmi.n	80014b6 <VectorB0+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 80014ae:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 80014b2:	f001 b875 	b.w	80025a0 <_port_irq_epilogue>
    STM32_ST_TIM->SR = 0U;
 80014b6:	2100      	movs	r1, #0
 80014b8:	6139      	str	r1, [r7, #16]
 80014ba:	2320      	movs	r3, #32
 80014bc:	f383 8811 	msr	BASEPRI, r3
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 80014c0:	4c1e      	ldr	r4, [pc, #120]	; (800153c <VectorB0+0x9c>)
 80014c2:	46a1      	mov	r9, r4
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80014c4:	46b8      	mov	r8, r7
 80014c6:	f859 3f1c 	ldr.w	r3, [r9, #28]!
 80014ca:	689a      	ldr	r2, [r3, #8]
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 80014cc:	460f      	mov	r7, r1
 80014ce:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 80014d2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80014d4:	1a45      	subs	r5, r0, r1
    if (nowdelta < vtp->delta) {
 80014d6:	4295      	cmp	r5, r2
 80014d8:	d31b      	bcc.n	8001512 <VectorB0+0x72>
 80014da:	2620      	movs	r6, #32
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 80014dc:	6818      	ldr	r0, [r3, #0]
      fn = vtp->func;
 80014de:	f8d3 a00c 	ldr.w	sl, [r3, #12]
      ch.vtlist.lasttime += vtp->delta;
 80014e2:	4411      	add	r1, r2

      /* if the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80014e4:	4548      	cmp	r0, r9
      ch.vtlist.lasttime += vtp->delta;
 80014e6:	62a1      	str	r1, [r4, #40]	; 0x28
      nowdelta -= vtp->delta;
 80014e8:	eba5 0502 	sub.w	r5, r5, r2
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 80014ec:	f8c0 9004 	str.w	r9, [r0, #4]
      ch.vtlist.next = vtp->next;
 80014f0:	61e0      	str	r0, [r4, #28]
      vtp->func = NULL;
 80014f2:	60df      	str	r7, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80014f4:	bf08      	it	eq
 80014f6:	f8c8 700c 	streq.w	r7, [r8, #12]
 80014fa:	f387 8811 	msr	BASEPRI, r7
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 80014fe:	6918      	ldr	r0, [r3, #16]
 8001500:	47d0      	blx	sl
 8001502:	f386 8811 	msr	BASEPRI, r6
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 8001506:	69e3      	ldr	r3, [r4, #28]
    }
    while (vtp->delta <= nowdelta);
 8001508:	689a      	ldr	r2, [r3, #8]
 800150a:	4295      	cmp	r5, r2
 800150c:	d3df      	bcc.n	80014ce <VectorB0+0x2e>
 800150e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001510:	e7e4      	b.n	80014dc <VectorB0+0x3c>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8001512:	69e2      	ldr	r2, [r4, #28]
 8001514:	454a      	cmp	r2, r9
 8001516:	d00a      	beq.n	800152e <VectorB0+0x8e>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 8001518:	6891      	ldr	r1, [r2, #8]
  ch.vtlist.lasttime += nowdelta;
 800151a:	62a0      	str	r0, [r4, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 800151c:	1b4d      	subs	r5, r1, r5
 800151e:	6095      	str	r5, [r2, #8]
  return systime + (systime_t)interval;
 8001520:	689b      	ldr	r3, [r3, #8]
 8001522:	2b02      	cmp	r3, #2
 8001524:	bf2c      	ite	cs
 8001526:	18c0      	addcs	r0, r0, r3
 8001528:	3002      	addcc	r0, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800152a:	f8c8 0034 	str.w	r0, [r8, #52]	; 0x34
 800152e:	2300      	movs	r3, #0
 8001530:	f383 8811 	msr	BASEPRI, r3
}
 8001534:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 8001538:	f001 b832 	b.w	80025a0 <_port_irq_epilogue>
 800153c:	20000cc4 	.word	0x20000cc4

08001540 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001540:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001544:	f002 0a03 	and.w	sl, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8001548:	f3c2 0880 	ubfx	r8, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800154c:	f3c2 0cc1 	ubfx	ip, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001550:	f3c2 1e41 	ubfx	lr, r2, #5, #2
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001554:	46d1      	mov	r9, sl
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8001556:	f3c2 12c3 	ubfx	r2, r2, #7, #4
  uint32_t bit     = 0;
 800155a:	2700      	movs	r7, #0
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800155c:	f04f 0b0f 	mov.w	fp, #15
 8001560:	e00f      	b.n	8001582 <_pal_lld_setgroupmode+0x42>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001562:	6a03      	ldr	r3, [r0, #32]
 8001564:	ea23 0404 	bic.w	r4, r3, r4
 8001568:	4325      	orrs	r5, r4
 800156a:	6205      	str	r5, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 800156c:	0849      	lsrs	r1, r1, #1
 800156e:	d039      	beq.n	80015e4 <_pal_lld_setgroupmode+0xa4>
      return;
    otyper <<= 1;
 8001570:	ea4f 0848 	mov.w	r8, r8, lsl #1
    ospeedr <<= 2;
 8001574:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    pupdr <<= 2;
 8001578:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    moder <<= 2;
 800157c:	ea4f 0989 	mov.w	r9, r9, lsl #2
    bit++;
 8001580:	3701      	adds	r7, #1
    if ((mask & 1) != 0) {
 8001582:	07cb      	lsls	r3, r1, #31
 8001584:	d5f2      	bpl.n	800156c <_pal_lld_setgroupmode+0x2c>
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001586:	6843      	ldr	r3, [r0, #4]
      m1 = 1 << bit;
 8001588:	2401      	movs	r4, #1
 800158a:	40bc      	lsls	r4, r7
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800158c:	ea23 0304 	bic.w	r3, r3, r4
 8001590:	ea43 0308 	orr.w	r3, r3, r8
 8001594:	6043      	str	r3, [r0, #4]
      m2 = 3 << (bit * 2);
 8001596:	2503      	movs	r5, #3
 8001598:	007b      	lsls	r3, r7, #1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800159a:	6884      	ldr	r4, [r0, #8]
      m2 = 3 << (bit * 2);
 800159c:	fa05 f303 	lsl.w	r3, r5, r3
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80015a0:	43db      	mvns	r3, r3
 80015a2:	401c      	ands	r4, r3
 80015a4:	ea44 040c 	orr.w	r4, r4, ip
 80015a8:	6084      	str	r4, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80015aa:	68c5      	ldr	r5, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 80015ac:	f007 0407 	and.w	r4, r7, #7
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80015b0:	401d      	ands	r5, r3
 80015b2:	ea45 050e 	orr.w	r5, r5, lr
      altrmask = altr << ((bit & 7) * 4);
 80015b6:	00a4      	lsls	r4, r4, #2
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 80015b8:	f1ba 0f02 	cmp.w	sl, #2
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80015bc:	60c5      	str	r5, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 80015be:	fa02 f504 	lsl.w	r5, r2, r4
      m4 = 15 << ((bit & 7) * 4);
 80015c2:	fa0b f404 	lsl.w	r4, fp, r4
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 80015c6:	d00f      	beq.n	80015e8 <_pal_lld_setgroupmode+0xa8>
        port->MODER   = (port->MODER & ~m2) | moder;
 80015c8:	6806      	ldr	r6, [r0, #0]
 80015ca:	4033      	ands	r3, r6
 80015cc:	ea43 0309 	orr.w	r3, r3, r9
        if (bit < 8)
 80015d0:	2f07      	cmp	r7, #7
        port->MODER   = (port->MODER & ~m2) | moder;
 80015d2:	6003      	str	r3, [r0, #0]
        if (bit < 8)
 80015d4:	d9c5      	bls.n	8001562 <_pal_lld_setgroupmode+0x22>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80015d6:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80015d8:	ea23 0404 	bic.w	r4, r3, r4
 80015dc:	4325      	orrs	r5, r4
    if (!mask)
 80015de:	0849      	lsrs	r1, r1, #1
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80015e0:	6245      	str	r5, [r0, #36]	; 0x24
    if (!mask)
 80015e2:	d1c5      	bne.n	8001570 <_pal_lld_setgroupmode+0x30>
 80015e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (bit < 8)
 80015e8:	2f07      	cmp	r7, #7
 80015ea:	d80a      	bhi.n	8001602 <_pal_lld_setgroupmode+0xc2>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80015ec:	6a06      	ldr	r6, [r0, #32]
 80015ee:	ea26 0404 	bic.w	r4, r6, r4
 80015f2:	4325      	orrs	r5, r4
 80015f4:	6205      	str	r5, [r0, #32]
        port->MODER   = (port->MODER & ~m2) | moder;
 80015f6:	6804      	ldr	r4, [r0, #0]
 80015f8:	4023      	ands	r3, r4
 80015fa:	ea43 0309 	orr.w	r3, r3, r9
 80015fe:	6003      	str	r3, [r0, #0]
 8001600:	e7b4      	b.n	800156c <_pal_lld_setgroupmode+0x2c>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001602:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8001604:	ea26 0404 	bic.w	r4, r6, r4
 8001608:	4325      	orrs	r5, r4
 800160a:	6245      	str	r5, [r0, #36]	; 0x24
 800160c:	e7f3      	b.n	80015f6 <_pal_lld_setgroupmode+0xb6>
 800160e:	bf00      	nop

08001610 <Vector158>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001610:	4b08      	ldr	r3, [pc, #32]	; (8001634 <Vector158+0x24>)
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 8001612:	4809      	ldr	r0, [pc, #36]	; (8001638 <Vector158+0x28>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001614:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[15].dma_func)
 8001616:	6f82      	ldr	r2, [r0, #120]	; 0x78
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001618:	0d89      	lsrs	r1, r1, #22
 800161a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 800161e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 22U;
 8001620:	058c      	lsls	r4, r1, #22
 8001622:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 8001624:	b10a      	cbz	r2, 800162a <Vector158+0x1a>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8001626:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8001628:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800162a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800162e:	f000 bfb7 	b.w	80025a0 <_port_irq_epilogue>
 8001632:	bf00      	nop
 8001634:	40026400 	.word	0x40026400
 8001638:	20000d3c 	.word	0x20000d3c
 800163c:	00000000 	.word	0x00000000

08001640 <Vector154>:
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8001640:	4b08      	ldr	r3, [pc, #32]	; (8001664 <Vector154+0x24>)
  if (dma_isr_redir[14].dma_func)
 8001642:	4809      	ldr	r0, [pc, #36]	; (8001668 <Vector154+0x28>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8001644:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[14].dma_func)
 8001646:	6f02      	ldr	r2, [r0, #112]	; 0x70
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8001648:	0c09      	lsrs	r1, r1, #16
 800164a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 800164e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 16U;
 8001650:	040c      	lsls	r4, r1, #16
 8001652:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 8001654:	b10a      	cbz	r2, 800165a <Vector154+0x1a>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8001656:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8001658:	4790      	blx	r2
}
 800165a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800165e:	f000 bf9f 	b.w	80025a0 <_port_irq_epilogue>
 8001662:	bf00      	nop
 8001664:	40026400 	.word	0x40026400
 8001668:	20000d3c 	.word	0x20000d3c
 800166c:	00000000 	.word	0x00000000

08001670 <Vector150>:
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8001670:	4b08      	ldr	r3, [pc, #32]	; (8001694 <Vector150+0x24>)
  if (dma_isr_redir[13].dma_func)
 8001672:	4809      	ldr	r0, [pc, #36]	; (8001698 <Vector150+0x28>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8001674:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[13].dma_func)
 8001676:	6e82      	ldr	r2, [r0, #104]	; 0x68
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8001678:	0989      	lsrs	r1, r1, #6
 800167a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 800167e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 6U;
 8001680:	018c      	lsls	r4, r1, #6
 8001682:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 8001684:	b10a      	cbz	r2, 800168a <Vector150+0x1a>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8001686:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8001688:	4790      	blx	r2
}
 800168a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800168e:	f000 bf87 	b.w	80025a0 <_port_irq_epilogue>
 8001692:	bf00      	nop
 8001694:	40026400 	.word	0x40026400
 8001698:	20000d3c 	.word	0x20000d3c
 800169c:	00000000 	.word	0x00000000

080016a0 <Vector130>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 80016a0:	b508      	push	{r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80016a2:	4b07      	ldr	r3, [pc, #28]	; (80016c0 <Vector130+0x20>)
  if (dma_isr_redir[12].dma_func)
 80016a4:	4807      	ldr	r0, [pc, #28]	; (80016c4 <Vector130+0x24>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80016a6:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[12].dma_func)
 80016a8:	6e02      	ldr	r2, [r0, #96]	; 0x60
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80016aa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 80016ae:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 80016b0:	b10a      	cbz	r2, 80016b6 <Vector130+0x16>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 80016b2:	6e40      	ldr	r0, [r0, #100]	; 0x64
 80016b4:	4790      	blx	r2
}
 80016b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 80016ba:	f000 bf71 	b.w	80025a0 <_port_irq_epilogue>
 80016be:	bf00      	nop
 80016c0:	40026400 	.word	0x40026400
 80016c4:	20000d3c 	.word	0x20000d3c
	...

080016d0 <Vector12C>:
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80016d0:	4b08      	ldr	r3, [pc, #32]	; (80016f4 <Vector12C+0x24>)
  if (dma_isr_redir[11].dma_func)
 80016d2:	4809      	ldr	r0, [pc, #36]	; (80016f8 <Vector12C+0x28>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80016d4:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[11].dma_func)
 80016d6:	6d82      	ldr	r2, [r0, #88]	; 0x58
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80016d8:	0d89      	lsrs	r1, r1, #22
 80016da:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 80016de:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 22U;
 80016e0:	058c      	lsls	r4, r1, #22
 80016e2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 80016e4:	b10a      	cbz	r2, 80016ea <Vector12C+0x1a>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 80016e6:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 80016e8:	4790      	blx	r2
}
 80016ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80016ee:	f000 bf57 	b.w	80025a0 <_port_irq_epilogue>
 80016f2:	bf00      	nop
 80016f4:	40026400 	.word	0x40026400
 80016f8:	20000d3c 	.word	0x20000d3c
 80016fc:	00000000 	.word	0x00000000

08001700 <Vector128>:
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8001700:	4b08      	ldr	r3, [pc, #32]	; (8001724 <Vector128+0x24>)
  if (dma_isr_redir[10].dma_func)
 8001702:	4809      	ldr	r0, [pc, #36]	; (8001728 <Vector128+0x28>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8001704:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[10].dma_func)
 8001706:	6d02      	ldr	r2, [r0, #80]	; 0x50
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8001708:	0c09      	lsrs	r1, r1, #16
 800170a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 800170e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 16U;
 8001710:	040c      	lsls	r4, r1, #16
 8001712:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 8001714:	b10a      	cbz	r2, 800171a <Vector128+0x1a>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8001716:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8001718:	4790      	blx	r2
}
 800171a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800171e:	f000 bf3f 	b.w	80025a0 <_port_irq_epilogue>
 8001722:	bf00      	nop
 8001724:	40026400 	.word	0x40026400
 8001728:	20000d3c 	.word	0x20000d3c
 800172c:	00000000 	.word	0x00000000

08001730 <Vector124>:
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8001730:	4b08      	ldr	r3, [pc, #32]	; (8001754 <Vector124+0x24>)
  if (dma_isr_redir[9].dma_func)
 8001732:	4809      	ldr	r0, [pc, #36]	; (8001758 <Vector124+0x28>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8001734:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[9].dma_func)
 8001736:	6c82      	ldr	r2, [r0, #72]	; 0x48
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8001738:	0989      	lsrs	r1, r1, #6
 800173a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 800173e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 6U;
 8001740:	018c      	lsls	r4, r1, #6
 8001742:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 8001744:	b10a      	cbz	r2, 800174a <Vector124+0x1a>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8001746:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8001748:	4790      	blx	r2
}
 800174a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800174e:	f000 bf27 	b.w	80025a0 <_port_irq_epilogue>
 8001752:	bf00      	nop
 8001754:	40026400 	.word	0x40026400
 8001758:	20000d3c 	.word	0x20000d3c
 800175c:	00000000 	.word	0x00000000

08001760 <Vector120>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8001760:	b508      	push	{r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8001762:	4b07      	ldr	r3, [pc, #28]	; (8001780 <Vector120+0x20>)
  if (dma_isr_redir[8].dma_func)
 8001764:	4807      	ldr	r0, [pc, #28]	; (8001784 <Vector120+0x24>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8001766:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[8].dma_func)
 8001768:	6c02      	ldr	r2, [r0, #64]	; 0x40
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800176a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 800176e:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 8001770:	b10a      	cbz	r2, 8001776 <Vector120+0x16>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 8001772:	6c40      	ldr	r0, [r0, #68]	; 0x44
 8001774:	4790      	blx	r2
}
 8001776:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800177a:	f000 bf11 	b.w	80025a0 <_port_irq_epilogue>
 800177e:	bf00      	nop
 8001780:	40026400 	.word	0x40026400
 8001784:	20000d3c 	.word	0x20000d3c
	...

08001790 <VectorFC>:
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001790:	4b08      	ldr	r3, [pc, #32]	; (80017b4 <VectorFC+0x24>)
  if (dma_isr_redir[7].dma_func)
 8001792:	4809      	ldr	r0, [pc, #36]	; (80017b8 <VectorFC+0x28>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001794:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[7].dma_func)
 8001796:	6b82      	ldr	r2, [r0, #56]	; 0x38
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001798:	0d89      	lsrs	r1, r1, #22
 800179a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 800179e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 22U;
 80017a0:	058c      	lsls	r4, r1, #22
 80017a2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 80017a4:	b10a      	cbz	r2, 80017aa <VectorFC+0x1a>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 80017a6:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 80017a8:	4790      	blx	r2
}
 80017aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80017ae:	f000 bef7 	b.w	80025a0 <_port_irq_epilogue>
 80017b2:	bf00      	nop
 80017b4:	40026000 	.word	0x40026000
 80017b8:	20000d3c 	.word	0x20000d3c
 80017bc:	00000000 	.word	0x00000000

080017c0 <Vector84>:
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80017c0:	4b08      	ldr	r3, [pc, #32]	; (80017e4 <Vector84+0x24>)
  if (dma_isr_redir[6].dma_func)
 80017c2:	4809      	ldr	r0, [pc, #36]	; (80017e8 <Vector84+0x28>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80017c4:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[6].dma_func)
 80017c6:	6b02      	ldr	r2, [r0, #48]	; 0x30
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80017c8:	0c09      	lsrs	r1, r1, #16
 80017ca:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 80017ce:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 16U;
 80017d0:	040c      	lsls	r4, r1, #16
 80017d2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 80017d4:	b10a      	cbz	r2, 80017da <Vector84+0x1a>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 80017d6:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80017d8:	4790      	blx	r2
}
 80017da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80017de:	f000 bedf 	b.w	80025a0 <_port_irq_epilogue>
 80017e2:	bf00      	nop
 80017e4:	40026000 	.word	0x40026000
 80017e8:	20000d3c 	.word	0x20000d3c
 80017ec:	00000000 	.word	0x00000000

080017f0 <Vector80>:
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80017f0:	4b08      	ldr	r3, [pc, #32]	; (8001814 <Vector80+0x24>)
  if (dma_isr_redir[5].dma_func)
 80017f2:	4809      	ldr	r0, [pc, #36]	; (8001818 <Vector80+0x28>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80017f4:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[5].dma_func)
 80017f6:	6a82      	ldr	r2, [r0, #40]	; 0x28
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80017f8:	0989      	lsrs	r1, r1, #6
 80017fa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 80017fe:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 6U;
 8001800:	018c      	lsls	r4, r1, #6
 8001802:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 8001804:	b10a      	cbz	r2, 800180a <Vector80+0x1a>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8001806:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8001808:	4790      	blx	r2
}
 800180a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800180e:	f000 bec7 	b.w	80025a0 <_port_irq_epilogue>
 8001812:	bf00      	nop
 8001814:	40026000 	.word	0x40026000
 8001818:	20000d3c 	.word	0x20000d3c
 800181c:	00000000 	.word	0x00000000

08001820 <Vector7C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8001820:	b508      	push	{r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8001822:	4b07      	ldr	r3, [pc, #28]	; (8001840 <Vector7C+0x20>)
  if (dma_isr_redir[4].dma_func)
 8001824:	4807      	ldr	r0, [pc, #28]	; (8001844 <Vector7C+0x24>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8001826:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[4].dma_func)
 8001828:	6a02      	ldr	r2, [r0, #32]
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800182a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 800182e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 8001830:	b10a      	cbz	r2, 8001836 <Vector7C+0x16>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8001832:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8001834:	4790      	blx	r2
}
 8001836:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800183a:	f000 beb1 	b.w	80025a0 <_port_irq_epilogue>
 800183e:	bf00      	nop
 8001840:	40026000 	.word	0x40026000
 8001844:	20000d3c 	.word	0x20000d3c
	...

08001850 <Vector78>:
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8001850:	4b08      	ldr	r3, [pc, #32]	; (8001874 <Vector78+0x24>)
  if (dma_isr_redir[3].dma_func)
 8001852:	4809      	ldr	r0, [pc, #36]	; (8001878 <Vector78+0x28>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8001854:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[3].dma_func)
 8001856:	6982      	ldr	r2, [r0, #24]
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8001858:	0d89      	lsrs	r1, r1, #22
 800185a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 800185e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 22U;
 8001860:	058c      	lsls	r4, r1, #22
 8001862:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 8001864:	b10a      	cbz	r2, 800186a <Vector78+0x1a>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8001866:	69c0      	ldr	r0, [r0, #28]
 8001868:	4790      	blx	r2
}
 800186a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800186e:	f000 be97 	b.w	80025a0 <_port_irq_epilogue>
 8001872:	bf00      	nop
 8001874:	40026000 	.word	0x40026000
 8001878:	20000d3c 	.word	0x20000d3c
 800187c:	00000000 	.word	0x00000000

08001880 <Vector74>:
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8001880:	4b08      	ldr	r3, [pc, #32]	; (80018a4 <Vector74+0x24>)
  if (dma_isr_redir[2].dma_func)
 8001882:	4809      	ldr	r0, [pc, #36]	; (80018a8 <Vector74+0x28>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8001884:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[2].dma_func)
 8001886:	6902      	ldr	r2, [r0, #16]
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8001888:	0c09      	lsrs	r1, r1, #16
 800188a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 800188e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 16U;
 8001890:	040c      	lsls	r4, r1, #16
 8001892:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 8001894:	b10a      	cbz	r2, 800189a <Vector74+0x1a>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8001896:	6940      	ldr	r0, [r0, #20]
 8001898:	4790      	blx	r2
}
 800189a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 800189e:	f000 be7f 	b.w	80025a0 <_port_irq_epilogue>
 80018a2:	bf00      	nop
 80018a4:	40026000 	.word	0x40026000
 80018a8:	20000d3c 	.word	0x20000d3c
 80018ac:	00000000 	.word	0x00000000

080018b0 <Vector70>:
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80018b0:	4b08      	ldr	r3, [pc, #32]	; (80018d4 <Vector70+0x24>)
  if (dma_isr_redir[1].dma_func)
 80018b2:	4809      	ldr	r0, [pc, #36]	; (80018d8 <Vector70+0x28>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80018b4:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[1].dma_func)
 80018b6:	6882      	ldr	r2, [r0, #8]
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80018b8:	0989      	lsrs	r1, r1, #6
 80018ba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 80018be:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 6U;
 80018c0:	018c      	lsls	r4, r1, #6
 80018c2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 80018c4:	b10a      	cbz	r2, 80018ca <Vector70+0x1a>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 80018c6:	68c0      	ldr	r0, [r0, #12]
 80018c8:	4790      	blx	r2
}
 80018ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80018ce:	f000 be67 	b.w	80025a0 <_port_irq_epilogue>
 80018d2:	bf00      	nop
 80018d4:	40026000 	.word	0x40026000
 80018d8:	20000d3c 	.word	0x20000d3c
 80018dc:	00000000 	.word	0x00000000

080018e0 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 80018e0:	b508      	push	{r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80018e2:	4b07      	ldr	r3, [pc, #28]	; (8001900 <Vector6C+0x20>)
  if (dma_isr_redir[0].dma_func)
 80018e4:	4a07      	ldr	r2, [pc, #28]	; (8001904 <Vector6C+0x24>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80018e6:	6819      	ldr	r1, [r3, #0]
 80018e8:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 80018ec:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 80018ee:	6813      	ldr	r3, [r2, #0]
 80018f0:	b10b      	cbz	r3, 80018f6 <Vector6C+0x16>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 80018f2:	6850      	ldr	r0, [r2, #4]
 80018f4:	4798      	blx	r3
}
 80018f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 80018fa:	f000 be51 	b.w	80025a0 <_port_irq_epilogue>
 80018fe:	bf00      	nop
 8001900:	40026000 	.word	0x40026000
 8001904:	20000d3c 	.word	0x20000d3c
	...

08001910 <Vector88>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
 8001910:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
 8001912:	4b24      	ldr	r3, [pc, #144]	; (80019a4 <Vector88+0x94>)
 8001914:	681a      	ldr	r2, [r3, #0]
  ADC1->SR = 0;
 8001916:	2100      	movs	r1, #0
 8001918:	6019      	str	r1, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 800191a:	0693      	lsls	r3, r2, #26
 800191c:	d539      	bpl.n	8001992 <Vector88+0x82>
 800191e:	4c22      	ldr	r4, [pc, #136]	; (80019a8 <Vector88+0x98>)
 8001920:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8001922:	680a      	ldr	r2, [r1, #0]
 8001924:	6853      	ldr	r3, [r2, #4]
 8001926:	2b00      	cmp	r3, #0
 8001928:	d033      	beq.n	8001992 <Vector88+0x82>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
 800192a:	6920      	ldr	r0, [r4, #16]
 800192c:	2800      	cmp	r0, #0
 800192e:	d030      	beq.n	8001992 <Vector88+0x82>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8001930:	6813      	ldr	r3, [r2, #0]
 8001932:	f023 031f 	bic.w	r3, r3, #31
 8001936:	6013      	str	r3, [r2, #0]
 8001938:	6813      	ldr	r3, [r2, #0]
 800193a:	f013 0301 	ands.w	r3, r3, #1
 800193e:	d1fb      	bne.n	8001938 <Vector88+0x28>
 8001940:	7a0f      	ldrb	r7, [r1, #8]
 8001942:	684e      	ldr	r6, [r1, #4]
  adcp->adc->CR1 = 0;
 8001944:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 8001946:	6885      	ldr	r5, [r0, #8]
  dmaStreamDisable(adcp->dmastp);
 8001948:	213d      	movs	r1, #61	; 0x3d
 800194a:	40b9      	lsls	r1, r7
 800194c:	6031      	str	r1, [r6, #0]
  adcp->adc->CR1 = 0;
 800194e:	6053      	str	r3, [r2, #4]
  /* Because ticket #822, preserving injected conversions.*/
  adcp->adc->CR2 &= ~(ADC_CR2_SWSTART);
 8001950:	6893      	ldr	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 8001952:	2101      	movs	r1, #1
  adcp->adc->CR2 &= ~(ADC_CR2_SWSTART);
 8001954:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8001958:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 800195a:	6091      	str	r1, [r2, #8]
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 800195c:	b1ed      	cbz	r5, 800199a <Vector88+0x8a>
 800195e:	2305      	movs	r3, #5
 8001960:	7023      	strb	r3, [r4, #0]
 8001962:	4811      	ldr	r0, [pc, #68]	; (80019a8 <Vector88+0x98>)
 8001964:	47a8      	blx	r5
 8001966:	7823      	ldrb	r3, [r4, #0]
 8001968:	2b05      	cmp	r3, #5
 800196a:	bf04      	itt	eq
 800196c:	2302      	moveq	r3, #2
 800196e:	7023      	strbeq	r3, [r4, #0]
 8001970:	2300      	movs	r3, #0
 8001972:	6123      	str	r3, [r4, #16]
 8001974:	2320      	movs	r3, #32
 8001976:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
 800197a:	6960      	ldr	r0, [r4, #20]
 800197c:	b130      	cbz	r0, 800198c <Vector88+0x7c>
    tp->u.rdymsg = msg;
 800197e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001982:	6243      	str	r3, [r0, #36]	; 0x24
    *trp = NULL;
 8001984:	2300      	movs	r3, #0
 8001986:	6163      	str	r3, [r4, #20]
    (void) chSchReadyI(tp);
 8001988:	f000 feaa 	bl	80026e0 <chSchReadyI>
 800198c:	2300      	movs	r3, #0
 800198e:	f383 8811 	msr	BASEPRI, r3
}
 8001992:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_EPILOGUE();
 8001996:	f000 be03 	b.w	80025a0 <_port_irq_epilogue>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 800199a:	2302      	movs	r3, #2
 800199c:	6125      	str	r5, [r4, #16]
 800199e:	7023      	strb	r3, [r4, #0]
 80019a0:	e7e8      	b.n	8001974 <Vector88+0x64>
 80019a2:	bf00      	nop
 80019a4:	40012000 	.word	0x40012000
 80019a8:	20000800 	.word	0x20000800
 80019ac:	00000000 	.word	0x00000000

080019b0 <VectorE0>:
OSAL_IRQ_HANDLER(VectorE0) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 80019b0:	4b1a      	ldr	r3, [pc, #104]	; (8001a1c <VectorE0+0x6c>)
OSAL_IRQ_HANDLER(VectorE0) {
 80019b2:	b510      	push	{r4, lr}
  pr = EXTI->PR;
 80019b4:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
 80019b6:	681a      	ldr	r2, [r3, #0]
 80019b8:	4014      	ands	r4, r2
 80019ba:	f404 427c 	and.w	r2, r4, #64512	; 0xfc00
                     (1U << 14) | (1U << 15));
  EXTI->PR = pr;
 80019be:	615a      	str	r2, [r3, #20]

  exti_serve_irq(pr, 10);
 80019c0:	0562      	lsls	r2, r4, #21
 80019c2:	d504      	bpl.n	80019ce <VectorE0+0x1e>
 80019c4:	4a16      	ldr	r2, [pc, #88]	; (8001a20 <VectorE0+0x70>)
 80019c6:	6d13      	ldr	r3, [r2, #80]	; 0x50
 80019c8:	b10b      	cbz	r3, 80019ce <VectorE0+0x1e>
 80019ca:	6d50      	ldr	r0, [r2, #84]	; 0x54
 80019cc:	4798      	blx	r3
  exti_serve_irq(pr, 11);
 80019ce:	0523      	lsls	r3, r4, #20
 80019d0:	d504      	bpl.n	80019dc <VectorE0+0x2c>
 80019d2:	4a13      	ldr	r2, [pc, #76]	; (8001a20 <VectorE0+0x70>)
 80019d4:	6d93      	ldr	r3, [r2, #88]	; 0x58
 80019d6:	b10b      	cbz	r3, 80019dc <VectorE0+0x2c>
 80019d8:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
 80019da:	4798      	blx	r3
  exti_serve_irq(pr, 12);
 80019dc:	04e0      	lsls	r0, r4, #19
 80019de:	d504      	bpl.n	80019ea <VectorE0+0x3a>
 80019e0:	4a0f      	ldr	r2, [pc, #60]	; (8001a20 <VectorE0+0x70>)
 80019e2:	6e13      	ldr	r3, [r2, #96]	; 0x60
 80019e4:	b10b      	cbz	r3, 80019ea <VectorE0+0x3a>
 80019e6:	6e50      	ldr	r0, [r2, #100]	; 0x64
 80019e8:	4798      	blx	r3
  exti_serve_irq(pr, 13);
 80019ea:	04a1      	lsls	r1, r4, #18
 80019ec:	d504      	bpl.n	80019f8 <VectorE0+0x48>
 80019ee:	4a0c      	ldr	r2, [pc, #48]	; (8001a20 <VectorE0+0x70>)
 80019f0:	6e93      	ldr	r3, [r2, #104]	; 0x68
 80019f2:	b10b      	cbz	r3, 80019f8 <VectorE0+0x48>
 80019f4:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80019f6:	4798      	blx	r3
  exti_serve_irq(pr, 14);
 80019f8:	0462      	lsls	r2, r4, #17
 80019fa:	d504      	bpl.n	8001a06 <VectorE0+0x56>
 80019fc:	4a08      	ldr	r2, [pc, #32]	; (8001a20 <VectorE0+0x70>)
 80019fe:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8001a00:	b10b      	cbz	r3, 8001a06 <VectorE0+0x56>
 8001a02:	6f50      	ldr	r0, [r2, #116]	; 0x74
 8001a04:	4798      	blx	r3
  exti_serve_irq(pr, 15);
 8001a06:	0423      	lsls	r3, r4, #16
 8001a08:	d504      	bpl.n	8001a14 <VectorE0+0x64>
 8001a0a:	4a05      	ldr	r2, [pc, #20]	; (8001a20 <VectorE0+0x70>)
 8001a0c:	6f93      	ldr	r3, [r2, #120]	; 0x78
 8001a0e:	b10b      	cbz	r3, 8001a14 <VectorE0+0x64>
 8001a10:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
 8001a12:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001a14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001a18:	f000 bdc2 	b.w	80025a0 <_port_irq_epilogue>
 8001a1c:	40013c00 	.word	0x40013c00
 8001a20:	20000888 	.word	0x20000888
	...

08001a30 <Vector9C>:
  pr = EXTI->PR;
 8001a30:	4b17      	ldr	r3, [pc, #92]	; (8001a90 <Vector9C+0x60>)
OSAL_IRQ_HANDLER(Vector9C) {
 8001a32:	b510      	push	{r4, lr}
  pr = EXTI->PR;
 8001a34:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
 8001a36:	681a      	ldr	r2, [r3, #0]
 8001a38:	4014      	ands	r4, r2
 8001a3a:	f404 7278 	and.w	r2, r4, #992	; 0x3e0
  EXTI->PR = pr;
 8001a3e:	615a      	str	r2, [r3, #20]
  exti_serve_irq(pr, 5);
 8001a40:	06a3      	lsls	r3, r4, #26
 8001a42:	d504      	bpl.n	8001a4e <Vector9C+0x1e>
 8001a44:	4a13      	ldr	r2, [pc, #76]	; (8001a94 <Vector9C+0x64>)
 8001a46:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8001a48:	b10b      	cbz	r3, 8001a4e <Vector9C+0x1e>
 8001a4a:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8001a4c:	4798      	blx	r3
  exti_serve_irq(pr, 6);
 8001a4e:	0660      	lsls	r0, r4, #25
 8001a50:	d504      	bpl.n	8001a5c <Vector9C+0x2c>
 8001a52:	4a10      	ldr	r2, [pc, #64]	; (8001a94 <Vector9C+0x64>)
 8001a54:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001a56:	b10b      	cbz	r3, 8001a5c <Vector9C+0x2c>
 8001a58:	6b50      	ldr	r0, [r2, #52]	; 0x34
 8001a5a:	4798      	blx	r3
  exti_serve_irq(pr, 7);
 8001a5c:	0621      	lsls	r1, r4, #24
 8001a5e:	d504      	bpl.n	8001a6a <Vector9C+0x3a>
 8001a60:	4a0c      	ldr	r2, [pc, #48]	; (8001a94 <Vector9C+0x64>)
 8001a62:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8001a64:	b10b      	cbz	r3, 8001a6a <Vector9C+0x3a>
 8001a66:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 8001a68:	4798      	blx	r3
  exti_serve_irq(pr, 8);
 8001a6a:	05e2      	lsls	r2, r4, #23
 8001a6c:	d504      	bpl.n	8001a78 <Vector9C+0x48>
 8001a6e:	4a09      	ldr	r2, [pc, #36]	; (8001a94 <Vector9C+0x64>)
 8001a70:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8001a72:	b10b      	cbz	r3, 8001a78 <Vector9C+0x48>
 8001a74:	6c50      	ldr	r0, [r2, #68]	; 0x44
 8001a76:	4798      	blx	r3
  exti_serve_irq(pr, 9);
 8001a78:	05a3      	lsls	r3, r4, #22
 8001a7a:	d504      	bpl.n	8001a86 <Vector9C+0x56>
 8001a7c:	4a05      	ldr	r2, [pc, #20]	; (8001a94 <Vector9C+0x64>)
 8001a7e:	6c93      	ldr	r3, [r2, #72]	; 0x48
 8001a80:	b10b      	cbz	r3, 8001a86 <Vector9C+0x56>
 8001a82:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
 8001a84:	4798      	blx	r3
}
 8001a86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001a8a:	f000 bd89 	b.w	80025a0 <_port_irq_epilogue>
 8001a8e:	bf00      	nop
 8001a90:	40013c00 	.word	0x40013c00
 8001a94:	20000888 	.word	0x20000888
	...

08001aa0 <Vector68>:
  pr = EXTI->PR;
 8001aa0:	4a08      	ldr	r2, [pc, #32]	; (8001ac4 <Vector68+0x24>)
OSAL_IRQ_HANDLER(Vector68) {
 8001aa2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 8001aa4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 4);
 8001aa6:	6811      	ldr	r1, [r2, #0]
 8001aa8:	400b      	ands	r3, r1
 8001aaa:	f003 0310 	and.w	r3, r3, #16
  EXTI->PR = pr;
 8001aae:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 4);
 8001ab0:	b123      	cbz	r3, 8001abc <Vector68+0x1c>
 8001ab2:	4a05      	ldr	r2, [pc, #20]	; (8001ac8 <Vector68+0x28>)
 8001ab4:	6a13      	ldr	r3, [r2, #32]
 8001ab6:	b10b      	cbz	r3, 8001abc <Vector68+0x1c>
 8001ab8:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8001aba:	4798      	blx	r3
}
 8001abc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001ac0:	f000 bd6e 	b.w	80025a0 <_port_irq_epilogue>
 8001ac4:	40013c00 	.word	0x40013c00
 8001ac8:	20000888 	.word	0x20000888
 8001acc:	00000000 	.word	0x00000000

08001ad0 <Vector64>:
  pr = EXTI->PR;
 8001ad0:	4a08      	ldr	r2, [pc, #32]	; (8001af4 <Vector64+0x24>)
OSAL_IRQ_HANDLER(Vector64) {
 8001ad2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 8001ad4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 3);
 8001ad6:	6811      	ldr	r1, [r2, #0]
 8001ad8:	400b      	ands	r3, r1
 8001ada:	f003 0308 	and.w	r3, r3, #8
  EXTI->PR = pr;
 8001ade:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 3);
 8001ae0:	b123      	cbz	r3, 8001aec <Vector64+0x1c>
 8001ae2:	4a05      	ldr	r2, [pc, #20]	; (8001af8 <Vector64+0x28>)
 8001ae4:	6993      	ldr	r3, [r2, #24]
 8001ae6:	b10b      	cbz	r3, 8001aec <Vector64+0x1c>
 8001ae8:	69d0      	ldr	r0, [r2, #28]
 8001aea:	4798      	blx	r3
}
 8001aec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001af0:	f000 bd56 	b.w	80025a0 <_port_irq_epilogue>
 8001af4:	40013c00 	.word	0x40013c00
 8001af8:	20000888 	.word	0x20000888
 8001afc:	00000000 	.word	0x00000000

08001b00 <Vector60>:
  pr = EXTI->PR;
 8001b00:	4a08      	ldr	r2, [pc, #32]	; (8001b24 <Vector60+0x24>)
OSAL_IRQ_HANDLER(Vector60) {
 8001b02:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 8001b04:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 2);
 8001b06:	6811      	ldr	r1, [r2, #0]
 8001b08:	400b      	ands	r3, r1
 8001b0a:	f003 0304 	and.w	r3, r3, #4
  EXTI->PR = pr;
 8001b0e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 2);
 8001b10:	b123      	cbz	r3, 8001b1c <Vector60+0x1c>
 8001b12:	4a05      	ldr	r2, [pc, #20]	; (8001b28 <Vector60+0x28>)
 8001b14:	6913      	ldr	r3, [r2, #16]
 8001b16:	b10b      	cbz	r3, 8001b1c <Vector60+0x1c>
 8001b18:	6950      	ldr	r0, [r2, #20]
 8001b1a:	4798      	blx	r3
}
 8001b1c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001b20:	f000 bd3e 	b.w	80025a0 <_port_irq_epilogue>
 8001b24:	40013c00 	.word	0x40013c00
 8001b28:	20000888 	.word	0x20000888
 8001b2c:	00000000 	.word	0x00000000

08001b30 <Vector5C>:
  pr = EXTI->PR;
 8001b30:	4a08      	ldr	r2, [pc, #32]	; (8001b54 <Vector5C+0x24>)
OSAL_IRQ_HANDLER(Vector5C) {
 8001b32:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 8001b34:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 1);
 8001b36:	6811      	ldr	r1, [r2, #0]
 8001b38:	400b      	ands	r3, r1
 8001b3a:	f003 0302 	and.w	r3, r3, #2
  EXTI->PR = pr;
 8001b3e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 1);
 8001b40:	b123      	cbz	r3, 8001b4c <Vector5C+0x1c>
 8001b42:	4a05      	ldr	r2, [pc, #20]	; (8001b58 <Vector5C+0x28>)
 8001b44:	6893      	ldr	r3, [r2, #8]
 8001b46:	b10b      	cbz	r3, 8001b4c <Vector5C+0x1c>
 8001b48:	68d0      	ldr	r0, [r2, #12]
 8001b4a:	4798      	blx	r3
}
 8001b4c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001b50:	f000 bd26 	b.w	80025a0 <_port_irq_epilogue>
 8001b54:	40013c00 	.word	0x40013c00
 8001b58:	20000888 	.word	0x20000888
 8001b5c:	00000000 	.word	0x00000000

08001b60 <Vector58>:
  pr = EXTI->PR;
 8001b60:	4a08      	ldr	r2, [pc, #32]	; (8001b84 <Vector58+0x24>)
OSAL_IRQ_HANDLER(Vector58) {
 8001b62:	b508      	push	{r3, lr}
  pr = EXTI->PR;
 8001b64:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 0);
 8001b66:	6811      	ldr	r1, [r2, #0]
 8001b68:	400b      	ands	r3, r1
 8001b6a:	f003 0301 	and.w	r3, r3, #1
  EXTI->PR = pr;
 8001b6e:	6153      	str	r3, [r2, #20]
  exti_serve_irq(pr, 0);
 8001b70:	b123      	cbz	r3, 8001b7c <Vector58+0x1c>
 8001b72:	4a05      	ldr	r2, [pc, #20]	; (8001b88 <Vector58+0x28>)
 8001b74:	6813      	ldr	r3, [r2, #0]
 8001b76:	b10b      	cbz	r3, 8001b7c <Vector58+0x1c>
 8001b78:	6850      	ldr	r0, [r2, #4]
 8001b7a:	4798      	blx	r3
}
 8001b7c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001b80:	f000 bd0e 	b.w	80025a0 <_port_irq_epilogue>
 8001b84:	40013c00 	.word	0x40013c00
 8001b88:	20000888 	.word	0x20000888
 8001b8c:	00000000 	.word	0x00000000

08001b90 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001b90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001b92:	4f13      	ldr	r7, [pc, #76]	; (8001be0 <__init_ram_areas+0x50>)
 8001b94:	4d13      	ldr	r5, [pc, #76]	; (8001be4 <__init_ram_areas+0x54>)
 8001b96:	4c14      	ldr	r4, [pc, #80]	; (8001be8 <__init_ram_areas+0x58>)
 8001b98:	4b14      	ldr	r3, [pc, #80]	; (8001bec <__init_ram_areas+0x5c>)
 8001b9a:	4915      	ldr	r1, [pc, #84]	; (8001bf0 <__init_ram_areas+0x60>)
 8001b9c:	f107 0e70 	add.w	lr, r7, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001ba0:	2600      	movs	r6, #0
    while (p < rap->clear_area) {
 8001ba2:	429c      	cmp	r4, r3
 8001ba4:	d911      	bls.n	8001bca <__init_ram_areas+0x3a>
 8001ba6:	3904      	subs	r1, #4
 8001ba8:	461a      	mov	r2, r3
      *p = *tp;
 8001baa:	f851 0f04 	ldr.w	r0, [r1, #4]!
 8001bae:	f842 0b04 	str.w	r0, [r2], #4
    while (p < rap->clear_area) {
 8001bb2:	4294      	cmp	r4, r2
 8001bb4:	d8f9      	bhi.n	8001baa <__init_ram_areas+0x1a>
 8001bb6:	43da      	mvns	r2, r3
 8001bb8:	4414      	add	r4, r2
 8001bba:	f024 0403 	bic.w	r4, r4, #3
 8001bbe:	3404      	adds	r4, #4
 8001bc0:	4423      	add	r3, r4
    while (p < rap->no_init_area) {
 8001bc2:	429d      	cmp	r5, r3
 8001bc4:	d903      	bls.n	8001bce <__init_ram_areas+0x3e>
      *p = 0;
 8001bc6:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->no_init_area) {
 8001bca:	429d      	cmp	r5, r3
 8001bcc:	d8fb      	bhi.n	8001bc6 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001bce:	4577      	cmp	r7, lr
 8001bd0:	d004      	beq.n	8001bdc <__init_ram_areas+0x4c>
 8001bd2:	f107 0110 	add.w	r1, r7, #16
 8001bd6:	c93a      	ldmia	r1, {r1, r3, r4, r5}
 8001bd8:	3710      	adds	r7, #16
 8001bda:	e7e2      	b.n	8001ba2 <__init_ram_areas+0x12>
 8001bdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001bde:	bf00      	nop
 8001be0:	08002fc4 	.word	0x08002fc4
 8001be4:	20000dc0 	.word	0x20000dc0
 8001be8:	20000dc0 	.word	0x20000dc0
 8001bec:	20000dc0 	.word	0x20000dc0
 8001bf0:	080031f4 	.word	0x080031f4
	...

08001c00 <__default_exit>:
void __default_exit(void) {
 8001c00:	e7fe      	b.n	8001c00 <__default_exit>
 8001c02:	bf00      	nop
	...

08001c10 <__late_init>:
 8001c10:	4770      	bx	lr
 8001c12:	bf00      	nop
	...

08001c20 <__core_init>:
void __core_init(void) {
 8001c20:	4770      	bx	lr
 8001c22:	bf00      	nop
	...

08001c30 <Thread5>:
  i = (i >> 3 ) *0.25; // *0.25degC
  return i;
}

static THD_WORKING_AREA(waThread5, 256);
static THD_FUNCTION(Thread5, arg) {
 8001c30:	b580      	push	{r7, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8001c32:	4b29      	ldr	r3, [pc, #164]	; (8001cd8 <Thread5+0xa8>)
  (void)arg;
  chRegSetThreadName("Thermocouple");
  /*
   * SPI2 I/O pins setup.
   */
  palSetPadMode(GPIOB, 13, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);       /* New SCK.     */
 8001c34:	4e29      	ldr	r6, [pc, #164]	; (8001cdc <Thread5+0xac>)
 8001c36:	699b      	ldr	r3, [r3, #24]
 8001c38:	4a29      	ldr	r2, [pc, #164]	; (8001ce0 <Thread5+0xb0>)
 8001c3a:	619a      	str	r2, [r3, #24]
static THD_FUNCTION(Thread5, arg) {
 8001c3c:	b082      	sub	sp, #8
  palSetPadMode(GPIOB, 13, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);       /* New SCK.     */
 8001c3e:	4630      	mov	r0, r6
 8001c40:	f240 229a 	movw	r2, #666	; 0x29a
 8001c44:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8001c48:	f7ff fc7a 	bl	8001540 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 14, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);       /* New MISO.    */
 8001c4c:	4630      	mov	r0, r6
 8001c4e:	f240 229a 	movw	r2, #666	; 0x29a
 8001c52:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8001c56:	f7ff fc73 	bl	8001540 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 11, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);       /* CS 1     */
  palSetPad(GPIOB, 11);
  palSetPadMode(GPIOE, 15, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);       /* CS 2.      */
 8001c5a:	4f22      	ldr	r7, [pc, #136]	; (8001ce4 <Thread5+0xb4>)
 8001c5c:	4d22      	ldr	r5, [pc, #136]	; (8001ce8 <Thread5+0xb8>)
 8001c5e:	4c23      	ldr	r4, [pc, #140]	; (8001cec <Thread5+0xbc>)
  palSetPad(GPIOE, 15);
  while (true) {

    uint16_t temp1 = ReadThermocouple(ls_spicfg_cs1);
    uint16_t temp2 = ReadThermocouple(ls_spicfg_cs2);
    chprintf((BaseSequentialStream *)&SD2,"Temp 1 (C) : %.2d \r\n\r\n", temp1);
 8001c60:	f8df 9094 	ldr.w	r9, [pc, #148]	; 8001cf8 <Thread5+0xc8>
  palSetPadMode(GPIOB, 11, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);       /* CS 1     */
 8001c64:	4630      	mov	r0, r6
 8001c66:	2219      	movs	r2, #25
 8001c68:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001c6c:	f7ff fc68 	bl	8001540 <_pal_lld_setgroupmode>
  palSetPad(GPIOB, 11);
 8001c70:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001c74:	8333      	strh	r3, [r6, #24]
  palSetPadMode(GPIOE, 15, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);       /* CS 2.      */
 8001c76:	4638      	mov	r0, r7
 8001c78:	2219      	movs	r2, #25
 8001c7a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001c7e:	f7ff fc5f 	bl	8001540 <_pal_lld_setgroupmode>
    chprintf((BaseSequentialStream *)&SD2,"Temp 1 (C) : %.2d \r\n\r\n", temp1);
 8001c82:	4e1b      	ldr	r6, [pc, #108]	; (8001cf0 <Thread5+0xc0>)
    uint16_t temp1 = ReadThermocouple(ls_spicfg_cs1);
 8001c84:	f8d5 8010 	ldr.w	r8, [r5, #16]
  palSetPad(GPIOE, 15);
 8001c88:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8001c8c:	833b      	strh	r3, [r7, #24]
    uint16_t temp1 = ReadThermocouple(ls_spicfg_cs1);
 8001c8e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8001c92:	f8cd 8000 	str.w	r8, [sp]
 8001c96:	f000 fd3b 	bl	8002710 <ReadThermocouple>
    uint16_t temp2 = ReadThermocouple(ls_spicfg_cs2);
 8001c9a:	6923      	ldr	r3, [r4, #16]
 8001c9c:	9300      	str	r3, [sp, #0]
    uint16_t temp1 = ReadThermocouple(ls_spicfg_cs1);
 8001c9e:	4682      	mov	sl, r0
    uint16_t temp2 = ReadThermocouple(ls_spicfg_cs2);
 8001ca0:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8001ca4:	f000 fd34 	bl	8002710 <ReadThermocouple>
    chprintf((BaseSequentialStream *)&SD2,"Temp 1 (C) : %.2d \r\n\r\n", temp1);
 8001ca8:	4652      	mov	r2, sl
    uint16_t temp2 = ReadThermocouple(ls_spicfg_cs2);
 8001caa:	4607      	mov	r7, r0
    chprintf((BaseSequentialStream *)&SD2,"Temp 1 (C) : %.2d \r\n\r\n", temp1);
 8001cac:	4649      	mov	r1, r9
 8001cae:	4630      	mov	r0, r6
 8001cb0:	f000 ffa6 	bl	8002c00 <chprintf.constprop.0>
    chprintf((BaseSequentialStream *)&SD2,"Temp 2 (C) : %.2d \r\n\r\n", temp2);
 8001cb4:	463a      	mov	r2, r7
 8001cb6:	490f      	ldr	r1, [pc, #60]	; (8001cf4 <Thread5+0xc4>)
 8001cb8:	4630      	mov	r0, r6
 8001cba:	f000 ffa1 	bl	8002c00 <chprintf.constprop.0>
 8001cbe:	2320      	movs	r3, #32
 8001cc0:	f383 8811 	msr	BASEPRI, r3
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8001cc4:	f241 3188 	movw	r1, #5000	; 0x1388
 8001cc8:	2008      	movs	r0, #8
 8001cca:	f000 fbd9 	bl	8002480 <chSchGoSleepTimeoutS>
 8001cce:	2300      	movs	r3, #0
 8001cd0:	f383 8811 	msr	BASEPRI, r3
 8001cd4:	e7db      	b.n	8001c8e <Thread5+0x5e>
 8001cd6:	bf00      	nop
 8001cd8:	20000cc4 	.word	0x20000cc4
 8001cdc:	40020400 	.word	0x40020400
 8001ce0:	08003050 	.word	0x08003050
 8001ce4:	40021000 	.word	0x40021000
 8001ce8:	08003168 	.word	0x08003168
 8001cec:	0800317c 	.word	0x0800317c
 8001cf0:	20000c18 	.word	0x20000c18
 8001cf4:	08003078 	.word	0x08003078
 8001cf8:	08003060 	.word	0x08003060
 8001cfc:	00000000 	.word	0x00000000

08001d00 <main>:
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001d00:	4b1e      	ldr	r3, [pc, #120]	; (8001d7c <main+0x7c>)
  PWR->CR |= PWR_CR_DBP;
 8001d02:	481f      	ldr	r0, [pc, #124]	; (8001d80 <main+0x80>)
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001d04:	6919      	ldr	r1, [r3, #16]
 8001d06:	ea6f 51c1 	mvn.w	r1, r1, lsl #23
 8001d0a:	2200      	movs	r2, #0
 8001d0c:	ea6f 51d1 	mvn.w	r1, r1, lsr #23
/*--------------------------------------------------------------------------*/
/*=============================================================================*/
/*
 * Application entry point.
 */
int main(void) {
 8001d10:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  rccResetAHB2(~0);
 8001d14:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001d18:	6119      	str	r1, [r3, #16]
 8001d1a:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8001d1c:	6959      	ldr	r1, [r3, #20]
 8001d1e:	615c      	str	r4, [r3, #20]
 8001d20:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8001d22:	6a19      	ldr	r1, [r3, #32]
 8001d24:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 8001d28:	6219      	str	r1, [r3, #32]
 8001d2a:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8001d2c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8001d2e:	625c      	str	r4, [r3, #36]	; 0x24
 8001d30:	625a      	str	r2, [r3, #36]	; 0x24
  rccEnablePWRInterface(true);
 8001d32:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8001d34:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001d38:	6419      	str	r1, [r3, #64]	; 0x40
 8001d3a:	6e19      	ldr	r1, [r3, #96]	; 0x60
 8001d3c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001d40:	6619      	str	r1, [r3, #96]	; 0x60
  PWR->CR |= PWR_CR_DBP;
 8001d42:	6801      	ldr	r1, [r0, #0]
 8001d44:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8001d48:	6001      	str	r1, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8001d4a:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8001d4c:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8001d50:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8001d54:	b087      	sub	sp, #28
 8001d56:	d003      	beq.n	8001d60 <main+0x60>
    RCC->BDCR = RCC_BDCR_BDRST;
 8001d58:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8001d5c:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8001d5e:	671a      	str	r2, [r3, #112]	; 0x70
  PWR->CSR &= ~PWR_CSR_BRE;
 8001d60:	4c07      	ldr	r4, [pc, #28]	; (8001d80 <main+0x80>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
 8001d62:	4e08      	ldr	r6, [pc, #32]	; (8001d84 <main+0x84>)
 8001d64:	6862      	ldr	r2, [r4, #4]
 8001d66:	4908      	ldr	r1, [pc, #32]	; (8001d88 <main+0x88>)
 8001d68:	4d08      	ldr	r5, [pc, #32]	; (8001d8c <main+0x8c>)
 8001d6a:	4f09      	ldr	r7, [pc, #36]	; (8001d90 <main+0x90>)
 8001d6c:	2000      	movs	r0, #0
 8001d6e:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8001d72:	6062      	str	r2, [r4, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8001d74:	4603      	mov	r3, r0
    _stm32_dma_streams[i].stream->CR = 0U;
 8001d76:	4602      	mov	r2, r0
  dma_streams_mask = 0U;
 8001d78:	6030      	str	r0, [r6, #0]
 8001d7a:	e00d      	b.n	8001d98 <main+0x98>
 8001d7c:	40023800 	.word	0x40023800
 8001d80:	40007000 	.word	0x40007000
 8001d84:	20000dbc 	.word	0x20000dbc
 8001d88:	0800309c 	.word	0x0800309c
 8001d8c:	40026010 	.word	0x40026010
 8001d90:	20000d3c 	.word	0x20000d3c
 8001d94:	f851 5c0c 	ldr.w	r5, [r1, #-12]
    _stm32_dma_streams[i].stream->CR = 0U;
 8001d98:	602a      	str	r2, [r5, #0]
    dma_isr_redir[i].dma_func = NULL;
 8001d9a:	f847 2033 	str.w	r2, [r7, r3, lsl #3]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8001d9e:	3301      	adds	r3, #1
 8001da0:	2b10      	cmp	r3, #16
 8001da2:	f101 010c 	add.w	r1, r1, #12
 8001da6:	d1f5      	bne.n	8001d94 <main+0x94>

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001da8:	4bbd      	ldr	r3, [pc, #756]	; (80020a0 <main+0x3a0>)
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8001daa:	48be      	ldr	r0, [pc, #760]	; (80020a4 <main+0x3a4>)
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 8001dac:	4ebe      	ldr	r6, [pc, #760]	; (80020a8 <main+0x3a8>)
 8001dae:	49bf      	ldr	r1, [pc, #764]	; (80020ac <main+0x3ac>)
 8001db0:	2260      	movs	r2, #96	; 0x60
  DMA1->LIFCR = 0xFFFFFFFFU;
 8001db2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001db6:	2540      	movs	r5, #64	; 0x40
 8001db8:	6084      	str	r4, [r0, #8]
 8001dba:	2780      	movs	r7, #128	; 0x80
  DMA1->HIFCR = 0xFFFFFFFFU;
 8001dbc:	60c4      	str	r4, [r0, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 8001dbe:	60b4      	str	r4, [r6, #8]
 8001dc0:	f44f 7080 	mov.w	r0, #256	; 0x100
  DMA2->HIFCR = 0xFFFFFFFFU;
 8001dc4:	60f4      	str	r4, [r6, #12]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001dc6:	f883 2306 	strb.w	r2, [r3, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001dca:	f44f 7600 	mov.w	r6, #512	; 0x200
 8001dce:	f8c3 5180 	str.w	r5, [r3, #384]	; 0x180
 8001dd2:	f44f 6480 	mov.w	r4, #1024	; 0x400
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001dd6:	601d      	str	r5, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001dd8:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001ddc:	f883 2307 	strb.w	r2, [r3, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001de0:	f8c3 7180 	str.w	r7, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001de4:	601f      	str	r7, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001de6:	f883 2308 	strb.w	r2, [r3, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001dea:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001dee:	6018      	str	r0, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001df0:	f883 2309 	strb.w	r2, [r3, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001df4:	f8c3 6180 	str.w	r6, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001df8:	601e      	str	r6, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001dfa:	f883 230a 	strb.w	r2, [r3, #778]	; 0x30a
 8001dfe:	19ce      	adds	r6, r1, r7
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001e00:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001e04:	601c      	str	r4, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001e06:	f883 2317 	strb.w	r2, [r3, #791]	; 0x317
    _pal_init_event(i);
 8001e0a:	2400      	movs	r4, #0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001e0c:	f8c3 5180 	str.w	r5, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001e10:	601d      	str	r5, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001e12:	f883 2328 	strb.w	r2, [r3, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001e16:	f8c3 0184 	str.w	r0, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001e1a:	6058      	str	r0, [r3, #4]
 8001e1c:	600c      	str	r4, [r1, #0]
 8001e1e:	604c      	str	r4, [r1, #4]
 8001e20:	3108      	adds	r1, #8
  for (i = 0; i < 16; i++) {
 8001e22:	42b1      	cmp	r1, r6
 8001e24:	d1fa      	bne.n	8001e1c <main+0x11c>
  sdp->vmt = &vmt;
 8001e26:	4ea2      	ldr	r6, [pc, #648]	; (80020b0 <main+0x3b0>)
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8001e28:	4ba2      	ldr	r3, [pc, #648]	; (80020b4 <main+0x3b4>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001e2a:	f8df a274 	ldr.w	sl, [pc, #628]	; 80020a0 <main+0x3a0>
  ADCD1.adc = ADC1;
 8001e2e:	4fa2      	ldr	r7, [pc, #648]	; (80020b8 <main+0x3b8>)
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 8001e30:	f8df 92d0 	ldr.w	r9, [pc, #720]	; 8002104 <main+0x404>
  ADCD1.adc = ADC1;
 8001e34:	629f      	str	r7, [r3, #40]	; 0x28
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 8001e36:	f8c3 9030 	str.w	r9, [r3, #48]	; 0x30
 8001e3a:	2701      	movs	r7, #1
 8001e3c:	46b4      	mov	ip, r6
 8001e3e:	f04f 0960 	mov.w	r9, #96	; 0x60
  adcp->config   = NULL;
 8001e42:	605c      	str	r4, [r3, #4]
  adcp->samples  = NULL;
 8001e44:	609c      	str	r4, [r3, #8]
  adcp->depth    = 0;
 8001e46:	60dc      	str	r4, [r3, #12]
  adcp->grpp     = NULL;
 8001e48:	611c      	str	r4, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8001e4a:	615c      	str	r4, [r3, #20]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8001e4c:	621c      	str	r4, [r3, #32]
  adcp->state    = ADC_STOP;
 8001e4e:	701f      	strb	r7, [r3, #0]
 8001e50:	f8df b2b4 	ldr.w	fp, [pc, #692]	; 8002108 <main+0x408>
 8001e54:	f88a 9312 	strb.w	r9, [sl, #786]	; 0x312
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001e58:	f44f 2980 	mov.w	r9, #262144	; 0x40000
 8001e5c:	f8ca 9180 	str.w	r9, [sl, #384]	; 0x180
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 8001e60:	4d96      	ldr	r5, [pc, #600]	; (80020bc <main+0x3bc>)
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001e62:	f8ca 9000 	str.w	r9, [sl]
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 8001e66:	4996      	ldr	r1, [pc, #600]	; (80020c0 <main+0x3c0>)
 8001e68:	f84c bb04 	str.w	fp, [ip], #4
  tqp->next = (thread_t *)tqp;
 8001e6c:	f103 0918 	add.w	r9, r3, #24
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 8001e70:	4a94      	ldr	r2, [pc, #592]	; (80020c4 <main+0x3c4>)
 8001e72:	f8df e298 	ldr.w	lr, [pc, #664]	; 800210c <main+0x40c>
 8001e76:	4894      	ldr	r0, [pc, #592]	; (80020c8 <main+0x3c8>)
 8001e78:	f8c3 9018 	str.w	r9, [r3, #24]
  tqp->prev = (thread_t *)tqp;
 8001e7c:	f8c3 901c 	str.w	r9, [r3, #28]
 8001e80:	62d9      	str	r1, [r3, #44]	; 0x2c
  PWMD3.tim = STM32_TIM3;
 8001e82:	4b92      	ldr	r3, [pc, #584]	; (80020cc <main+0x3cc>)

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001e84:	f8df 9288 	ldr.w	r9, [pc, #648]	; 8002110 <main+0x410>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8001e88:	f8c6 c004 	str.w	ip, [r6, #4]
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8001e8c:	f04f 0b04 	mov.w	fp, #4
  PWMD3.tim = STM32_TIM3;
 8001e90:	61ab      	str	r3, [r5, #24]
  PWMD1.tim = STM32_TIM1;
 8001e92:	f8df 8280 	ldr.w	r8, [pc, #640]	; 8002114 <main+0x414>
  PWMD4.tim = STM32_TIM4;
 8001e96:	f8df c280 	ldr.w	ip, [pc, #640]	; 8002118 <main+0x418>
 8001e9a:	f88e 7000 	strb.w	r7, [lr]
  oqp->q_counter = size;
 8001e9e:	2310      	movs	r3, #16
  pwmp->config   = NULL;
 8001ea0:	f8ce 4004 	str.w	r4, [lr, #4]
  pwmp->enabled  = 0;
 8001ea4:	f8ce 400c 	str.w	r4, [lr, #12]
  PWMD1.tim = STM32_TIM1;
 8001ea8:	f8ce 8018 	str.w	r8, [lr, #24]
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8001eac:	f88e b010 	strb.w	fp, [lr, #16]
  pwmp->state    = PWM_STOP;
 8001eb0:	702f      	strb	r7, [r5, #0]
  pwmp->config   = NULL;
 8001eb2:	606c      	str	r4, [r5, #4]
  pwmp->enabled  = 0;
 8001eb4:	60ec      	str	r4, [r5, #12]
  PWMD3.channels = STM32_TIM3_CHANNELS;
 8001eb6:	f885 b010 	strb.w	fp, [r5, #16]
  pwmp->state    = PWM_STOP;
 8001eba:	7007      	strb	r7, [r0, #0]
  pwmp->config   = NULL;
 8001ebc:	6044      	str	r4, [r0, #4]
  pwmp->enabled  = 0;
 8001ebe:	60c4      	str	r4, [r0, #12]
  PWMD4.channels = STM32_TIM4_CHANNELS;
 8001ec0:	f880 b010 	strb.w	fp, [r0, #16]
  PWMD4.tim = STM32_TIM4;
 8001ec4:	f8c0 c018 	str.w	ip, [r0, #24]
  sdp->state = SD_STOP;
 8001ec8:	7237      	strb	r7, [r6, #8]
  iqp->q_counter = 0;
 8001eca:	6174      	str	r4, [r6, #20]
 8001ecc:	7017      	strb	r7, [r2, #0]
  oqp->q_counter = size;
 8001ece:	63b3      	str	r3, [r6, #56]	; 0x38
 8001ed0:	f8d9 3040 	ldr.w	r3, [r9, #64]	; 0x40
  oqp->q_notify  = onfy;
 8001ed4:	f8df c244 	ldr.w	ip, [pc, #580]	; 800211c <main+0x41c>
  iqp->q_notify  = infy;
 8001ed8:	62b4      	str	r4, [r6, #40]	; 0x28
 8001eda:	433b      	orrs	r3, r7
  oqp->q_top     = bp + size;
 8001edc:	f106 0074 	add.w	r0, r6, #116	; 0x74
 8001ee0:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8001ee4:	f8df e238 	ldr.w	lr, [pc, #568]	; 8002120 <main+0x420>
 8001ee8:	6430      	str	r0, [r6, #64]	; 0x40
  oqp->q_notify  = onfy;
 8001eea:	f8c6 c04c 	str.w	ip, [r6, #76]	; 0x4c
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 8001eee:	f1a1 006c 	sub.w	r0, r1, #108	; 0x6c
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8001ef2:	f8df c230 	ldr.w	ip, [pc, #560]	; 8002124 <main+0x424>
  SPID2.spi       = SPI2;
 8001ef6:	4d76      	ldr	r5, [pc, #472]	; (80020d0 <main+0x3d0>)
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 8001ef8:	4b76      	ldr	r3, [pc, #472]	; (80020d4 <main+0x3d4>)
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8001efa:	f8c2 c02c 	str.w	ip, [r2, #44]	; 0x2c
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 8001efe:	3960      	subs	r1, #96	; 0x60
 8001f00:	f8c6 e074 	str.w	lr, [r6, #116]	; 0x74
  SPID2.spi       = SPI2;
 8001f04:	61d5      	str	r5, [r2, #28]
  tqp->next = (thread_t *)tqp;
 8001f06:	f106 0e0c 	add.w	lr, r6, #12
  iqp->q_buffer  = bp;
 8001f0a:	f106 0554 	add.w	r5, r6, #84	; 0x54
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 8001f0e:	6210      	str	r0, [r2, #32]
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 8001f10:	6251      	str	r1, [r2, #36]	; 0x24
  iqp->q_top     = bp + size;
 8001f12:	f106 0064 	add.w	r0, r6, #100	; 0x64
 8001f16:	f106 0130 	add.w	r1, r6, #48	; 0x30
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 8001f1a:	6293      	str	r3, [r2, #40]	; 0x28
 8001f1c:	f102 030c 	add.w	r3, r2, #12
  spip->config = NULL;
 8001f20:	6054      	str	r4, [r2, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 8001f22:	6094      	str	r4, [r2, #8]
 8001f24:	6154      	str	r4, [r2, #20]
 8001f26:	f8c6 e00c 	str.w	lr, [r6, #12]
  tqp->prev = (thread_t *)tqp;
 8001f2a:	f8c6 e010 	str.w	lr, [r6, #16]
  iqp->q_buffer  = bp;
 8001f2e:	61b5      	str	r5, [r6, #24]
  iqp->q_rdptr   = bp;
 8001f30:	6275      	str	r5, [r6, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8001f32:	6235      	str	r5, [r6, #32]
  iqp->q_top     = bp + size;
 8001f34:	61f0      	str	r0, [r6, #28]
  oqp->q_buffer  = bp;
 8001f36:	63f0      	str	r0, [r6, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8001f38:	64b0      	str	r0, [r6, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8001f3a:	6470      	str	r0, [r6, #68]	; 0x44
  tqp->next = (thread_t *)tqp;
 8001f3c:	6331      	str	r1, [r6, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 8001f3e:	6371      	str	r1, [r6, #52]	; 0x34
  iqp->q_link    = link;
 8001f40:	62f6      	str	r6, [r6, #44]	; 0x2c
  oqp->q_link    = link;
 8001f42:	6536      	str	r6, [r6, #80]	; 0x50
  tqp->next = (thread_t *)tqp;
 8001f44:	60d3      	str	r3, [r2, #12]
  tqp->prev = (thread_t *)tqp;
 8001f46:	6113      	str	r3, [r2, #16]
 8001f48:	f8d9 3060 	ldr.w	r3, [r9, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001f4c:	4862      	ldr	r0, [pc, #392]	; (80020d8 <main+0x3d8>)
  tqp->next = (thread_t *)tqp;
 8001f4e:	4d63      	ldr	r5, [pc, #396]	; (80020dc <main+0x3dc>)
  ST_ENABLE_CLOCK();
 8001f50:	433b      	orrs	r3, r7
 8001f52:	f8c9 3060 	str.w	r3, [r9, #96]	; 0x60
  ST_ENABLE_STOP();
 8001f56:	6881      	ldr	r1, [r0, #8]
  tqp->prev = (thread_t *)tqp;
 8001f58:	606d      	str	r5, [r5, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001f5a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  ST_ENABLE_STOP();
 8001f5e:	4339      	orrs	r1, r7
 8001f60:	6081      	str	r1, [r0, #8]
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001f62:	f242 0ecf 	movw	lr, #8399	; 0x20cf
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001f66:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001f6a:	f04f 0880 	mov.w	r8, #128	; 0x80
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001f6e:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001f72:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8001f76:	f105 011c 	add.w	r1, r5, #28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001f7a:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8001f7c:	619c      	str	r4, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8001f7e:	635c      	str	r4, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8001f80:	60dc      	str	r4, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8001f82:	605c      	str	r4, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001f84:	615f      	str	r7, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001f86:	601f      	str	r7, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001f88:	f88a 831c 	strb.w	r8, [sl, #796]	; 0x31c

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8001f8c:	2300      	movs	r3, #0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001f8e:	f8ca 0180 	str.w	r0, [sl, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001f92:	f8ca 0000 	str.w	r0, [sl]
  chTMStartMeasurementX(&tm);
 8001f96:	4668      	mov	r0, sp
  tmp->worst      = (rtcnt_t)0;
 8001f98:	e88d 0014 	stmia.w	sp, {r2, r4}
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (sysinterval_t)-1;
 8001f9c:	626a      	str	r2, [r5, #36]	; 0x24
  tqp->next = (thread_t *)tqp;
 8001f9e:	602d      	str	r5, [r5, #0]
  tmp->cumulative = (rttime_t)0;
 8001fa0:	2200      	movs	r2, #0
 8001fa2:	e9cd 2304 	strd	r2, r3, [sp, #16]
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8001fa6:	61e9      	str	r1, [r5, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8001fa8:	6229      	str	r1, [r5, #32]
  tmp->last       = (rtcnt_t)0;
 8001faa:	9402      	str	r4, [sp, #8]
  tmp->n          = (ucnt_t)0;
 8001fac:	9403      	str	r4, [sp, #12]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8001fae:	60ac      	str	r4, [r5, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8001fb0:	612d      	str	r5, [r5, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8001fb2:	616d      	str	r5, [r5, #20]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8001fb4:	62ac      	str	r4, [r5, #40]	; 0x28
  ch.tm.offset = (rtcnt_t)0;
 8001fb6:	676c      	str	r4, [r5, #116]	; 0x74
  chTMStartMeasurementX(&tm);
 8001fb8:	f000 fe1a 	bl	8002bf0 <chTMStartMeasurementX.constprop.5>
  chTMStopMeasurementX(&tm);
 8001fbc:	4668      	mov	r0, sp
 8001fbe:	f000 fb2f 	bl	8002620 <chTMStopMeasurementX>
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8001fc2:	4947      	ldr	r1, [pc, #284]	; (80020e0 <main+0x3e0>)
  ch.tm.offset = tm.last;
 8001fc4:	9b02      	ldr	r3, [sp, #8]
 8001fc6:	4a47      	ldr	r2, [pc, #284]	; (80020e4 <main+0x3e4>)
 8001fc8:	676b      	str	r3, [r5, #116]	; 0x74
 8001fca:	4b47      	ldr	r3, [pc, #284]	; (80020e8 <main+0x3e8>)
 8001fcc:	600b      	str	r3, [r1, #0]
 8001fce:	f101 030c 	add.w	r3, r1, #12
  H_NEXT(&default_heap.header) = NULL;
 8001fd2:	604c      	str	r4, [r1, #4]
  H_PAGES(&default_heap.header) = 0;
 8001fd4:	608c      	str	r4, [r1, #8]
 8001fd6:	614c      	str	r4, [r1, #20]
 8001fd8:	60cb      	str	r3, [r1, #12]
  tqp->prev = (thread_t *)tqp;
 8001fda:	610b      	str	r3, [r1, #16]
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 8001fdc:	f102 0110 	add.w	r1, r2, #16
                             unsigned align, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
  mp->object_size = size;
 8001fe0:	2314      	movs	r3, #20
 8001fe2:	f102 0c24 	add.w	ip, r2, #36	; 0x24
 8001fe6:	6111      	str	r1, [r2, #16]
 8001fe8:	6193      	str	r3, [r2, #24]
 8001fea:	f102 0128 	add.w	r1, r2, #40	; 0x28
 8001fee:	231c      	movs	r3, #28
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001ff0:	483e      	ldr	r0, [pc, #248]	; (80020ec <main+0x3ec>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 8001ff2:	f8df e134 	ldr.w	lr, [pc, #308]	; 8002128 <main+0x428>
 8001ff6:	f8c2 c024 	str.w	ip, [r2, #36]	; 0x24
 8001ffa:	6291      	str	r1, [r2, #40]	; 0x28
 8001ffc:	f102 0c3c 	add.w	ip, r2, #60	; 0x3c
 8002000:	f102 0140 	add.w	r1, r2, #64	; 0x40
 8002004:	6313      	str	r3, [r2, #48]	; 0x30
  mp->align = align;
  mp->provider = provider;
 8002006:	4b3a      	ldr	r3, [pc, #232]	; (80020f0 <main+0x3f0>)
 8002008:	f8c2 c03c 	str.w	ip, [r2, #60]	; 0x3c
 800200c:	6411      	str	r1, [r2, #64]	; 0x40
 800200e:	6213      	str	r3, [r2, #32]
 8002010:	6393      	str	r3, [r2, #56]	; 0x38
 8002012:	f8df c118 	ldr.w	ip, [pc, #280]	; 800212c <main+0x42c>
  ch_memcore.endmem  = __heap_end__;
 8002016:	4937      	ldr	r1, [pc, #220]	; (80020f4 <main+0x3f4>)
  tp->name      = name;
 8002018:	4b37      	ldr	r3, [pc, #220]	; (80020f8 <main+0x3f8>)
 800201a:	6094      	str	r4, [r2, #8]
  mp->next = NULL;
 800201c:	6154      	str	r4, [r2, #20]
  mp->align = align;
 800201e:	f8c2 b01c 	str.w	fp, [r2, #28]
  mp->next = NULL;
 8002022:	62d4      	str	r4, [r2, #44]	; 0x2c
  mp->align = align;
 8002024:	f8c2 b034 	str.w	fp, [r2, #52]	; 0x34
  ch_memcore.nextmem = __heap_base__;
 8002028:	f8ce c000 	str.w	ip, [lr]
  ch_memcore.endmem  = __heap_end__;
 800202c:	f8ce 1004 	str.w	r1, [lr, #4]
  tp->prio      = prio;
 8002030:	f8c5 8038 	str.w	r8, [r5, #56]	; 0x38
  tp->flags     = CH_FLAG_MODE_STATIC;
 8002034:	f885 4051 	strb.w	r4, [r5, #81]	; 0x51
  tp->realprio  = prio;
 8002038:	f8c5 806c 	str.w	r8, [r5, #108]	; 0x6c
  tp->mtxlist   = NULL;
 800203c:	66ac      	str	r4, [r5, #104]	; 0x68
  tp->epending  = (eventmask_t)0;
 800203e:	666c      	str	r4, [r5, #100]	; 0x64
  tp->refs      = (trefs_t)1;
 8002040:	f885 7052 	strb.w	r7, [r5, #82]	; 0x52
  tqp->next = (thread_t *)tqp;
 8002044:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 8002046:	6052      	str	r2, [r2, #4]
  tp->name      = name;
 8002048:	64ab      	str	r3, [r5, #72]	; 0x48
 800204a:	68c1      	ldr	r1, [r0, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800204c:	4b2b      	ldr	r3, [pc, #172]	; (80020fc <main+0x3fc>)
  REG_INSERT(tp);
 800204e:	f8d5 c014 	ldr.w	ip, [r5, #20]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8002052:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 8002130 <main+0x430>
 8002056:	642d      	str	r5, [r5, #64]	; 0x40
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8002058:	f64f 02ff 	movw	r2, #63743	; 0xf8ff
 800205c:	4011      	ands	r1, r2
  reg_value  =  (reg_value                                   |
 800205e:	430b      	orrs	r3, r1
 8002060:	f105 0230 	add.w	r2, r5, #48	; 0x30
 8002064:	f8c5 c044 	str.w	ip, [r5, #68]	; 0x44
 8002068:	f8cc 2010 	str.w	r2, [ip, #16]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800206c:	60c3      	str	r3, [r0, #12]
 800206e:	f8de 300c 	ldr.w	r3, [lr, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8002072:	4923      	ldr	r1, [pc, #140]	; (8002100 <main+0x400>)
 8002074:	616a      	str	r2, [r5, #20]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8002076:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800207a:	f8ce 300c 	str.w	r3, [lr, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800207e:	680b      	ldr	r3, [r1, #0]
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8002080:	61aa      	str	r2, [r5, #24]
 8002082:	433b      	orrs	r3, r7
  currp->wabase = NULL;
 8002084:	64ec      	str	r4, [r5, #76]	; 0x4c
  currp->state = CH_STATE_CURRENT;
 8002086:	f885 7050 	strb.w	r7, [r5, #80]	; 0x50
  tqp->next = (thread_t *)tqp;
 800208a:	f105 025c 	add.w	r2, r5, #92	; 0x5c
 800208e:	600b      	str	r3, [r1, #0]
  tlp->next = (thread_t *)tlp;
 8002090:	f105 0e58 	add.w	lr, r5, #88	; 0x58
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002094:	f04f 0b20 	mov.w	fp, #32
 8002098:	f04f 0310 	mov.w	r3, #16
 800209c:	e04a      	b.n	8002134 <main+0x434>
 800209e:	bf00      	nop
 80020a0:	e000e100 	.word	0xe000e100
 80020a4:	40026000 	.word	0x40026000
 80020a8:	40026400 	.word	0x40026400
 80020ac:	20000888 	.word	0x20000888
 80020b0:	20000c18 	.word	0x20000c18
 80020b4:	20000800 	.word	0x20000800
 80020b8:	40012000 	.word	0x40012000
 80020bc:	20000850 	.word	0x20000850
 80020c0:	08003120 	.word	0x08003120
 80020c4:	20000c94 	.word	0x20000c94
 80020c8:	2000086c 	.word	0x2000086c
 80020cc:	40000400 	.word	0x40000400
 80020d0:	40003800 	.word	0x40003800
 80020d4:	00010016 	.word	0x00010016
 80020d8:	e0042000 	.word	0xe0042000
 80020dc:	20000cc4 	.word	0x20000cc4
 80020e0:	20000a30 	.word	0x20000a30
 80020e4:	20000908 	.word	0x20000908
 80020e8:	08002381 	.word	0x08002381
 80020ec:	e000ed00 	.word	0xe000ed00
 80020f0:	08002341 	.word	0x08002341
 80020f4:	20020000 	.word	0x20020000
 80020f8:	08003150 	.word	0x08003150
 80020fc:	05fa0300 	.word	0x05fa0300
 8002100:	e0001000 	.word	0xe0001000
 8002104:	00022c16 	.word	0x00022c16
 8002108:	080031c0 	.word	0x080031c0
 800210c:	20000834 	.word	0x20000834
 8002110:	40023800 	.word	0x40023800
 8002114:	40010000 	.word	0x40010000
 8002118:	40000800 	.word	0x40000800
 800211c:	08000bb1 	.word	0x08000bb1
 8002120:	40004400 	.word	0x40004400
 8002124:	00010046 	.word	0x00010046
 8002128:	20000a28 	.word	0x20000a28
 800212c:	20000dc0 	.word	0x20000dc0
 8002130:	e000edf0 	.word	0xe000edf0
 8002134:	f8c5 e058 	str.w	lr, [r5, #88]	; 0x58
 8002138:	77c3      	strb	r3, [r0, #31]
  tqp->next = (thread_t *)tqp;
 800213a:	65ea      	str	r2, [r5, #92]	; 0x5c
 800213c:	f880 b022 	strb.w	fp, [r0, #34]	; 0x22
  tqp->prev = (thread_t *)tqp;
 8002140:	662a      	str	r2, [r5, #96]	; 0x60
 8002142:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 8002146:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002148:	f38b 8811 	msr	BASEPRI, fp
  tp->wabase = tdp->wbase;
 800214c:	4b6d      	ldr	r3, [pc, #436]	; (8002304 <main+0x604>)
  REG_INSERT(tp);
 800214e:	6969      	ldr	r1, [r5, #20]
  tp->name      = name;
 8002150:	486d      	ldr	r0, [pc, #436]	; (8002308 <main+0x608>)
  tp->prio      = prio;
 8002152:	f8c3 7098 	str.w	r7, [r3, #152]	; 0x98
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002156:	f103 026c 	add.w	r2, r3, #108	; 0x6c
  tp->realprio  = prio;
 800215a:	f8c3 70cc 	str.w	r7, [r3, #204]	; 0xcc
  tp->refs      = (trefs_t)1;
 800215e:	f883 70b2 	strb.w	r7, [r3, #178]	; 0xb2
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002162:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  tp->name      = name;
 8002166:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
  REG_INSERT(tp);
 800216a:	f103 0290 	add.w	r2, r3, #144	; 0x90
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800216e:	f8df e1bc 	ldr.w	lr, [pc, #444]	; 800232c <main+0x62c>
 8002172:	4866      	ldr	r0, [pc, #408]	; (800230c <main+0x60c>)
  REG_INSERT(tp);
 8002174:	f8c3 10a4 	str.w	r1, [r3, #164]	; 0xa4
  tp->state     = CH_STATE_WTSTART;
 8002178:	2702      	movs	r7, #2
 800217a:	f883 70b0 	strb.w	r7, [r3, #176]	; 0xb0
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800217e:	f8c3 008c 	str.w	r0, [r3, #140]	; 0x8c
 8002182:	671c      	str	r4, [r3, #112]	; 0x70
  tp->flags     = CH_FLAG_MODE_STATIC;
 8002184:	f883 40b1 	strb.w	r4, [r3, #177]	; 0xb1
  tp->mtxlist   = NULL;
 8002188:	f8c3 40c8 	str.w	r4, [r3, #200]	; 0xc8
  tp->epending  = (eventmask_t)0;
 800218c:	f8c3 40c4 	str.w	r4, [r3, #196]	; 0xc4
  REG_INSERT(tp);
 8002190:	f8c3 50a0 	str.w	r5, [r3, #160]	; 0xa0
  tp->wabase = tdp->wbase;
 8002194:	f8c3 30ac 	str.w	r3, [r3, #172]	; 0xac
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002198:	f8c3 e06c 	str.w	lr, [r3, #108]	; 0x6c
  tlp->next = (thread_t *)tlp;
 800219c:	f103 07b8 	add.w	r7, r3, #184	; 0xb8
  REG_INSERT(tp);
 80021a0:	610a      	str	r2, [r1, #16]
  tqp->next = (thread_t *)tqp;
 80021a2:	f103 01bc 	add.w	r1, r3, #188	; 0xbc
  chSchWakeupS(tp, MSG_OK);
 80021a6:	4610      	mov	r0, r2
  tlp->next = (thread_t *)tlp;
 80021a8:	f8c3 70b8 	str.w	r7, [r3, #184]	; 0xb8
  tqp->next = (thread_t *)tqp;
 80021ac:	f8c3 10bc 	str.w	r1, [r3, #188]	; 0xbc
  tqp->prev = (thread_t *)tqp;
 80021b0:	f8c3 10c0 	str.w	r1, [r3, #192]	; 0xc0
  REG_INSERT(tp);
 80021b4:	616a      	str	r2, [r5, #20]
  chSchWakeupS(tp, MSG_OK);
 80021b6:	f000 fceb 	bl	8002b90 <chSchWakeupS.constprop.10>
 80021ba:	f384 8811 	msr	BASEPRI, r4
   */
  halInit();
  chSysInit();
  /*===========================================================================*/
  /*----------------------------GPIO Init-------------------------------------*/
  palSetPadMode(GPIOD, 7, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 80021be:	4f54      	ldr	r7, [pc, #336]	; (8002310 <main+0x610>)
  palSetPadMode(GPIOB, 5, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 80021c0:	4c54      	ldr	r4, [pc, #336]	; (8002314 <main+0x614>)
  palSetPadMode(GPIOD, 7, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 80021c2:	4641      	mov	r1, r8
 80021c4:	4638      	mov	r0, r7
 80021c6:	2219      	movs	r2, #25
 80021c8:	f7ff f9ba 	bl	8001540 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 5, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 80021cc:	4659      	mov	r1, fp
 80021ce:	4620      	mov	r0, r4
 80021d0:	2219      	movs	r2, #25
 80021d2:	f7ff f9b5 	bl	8001540 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 7, PAL_MODE_INPUT_PULLDOWN);
 80021d6:	4641      	mov	r1, r8
 80021d8:	4620      	mov	r0, r4
 80021da:	2240      	movs	r2, #64	; 0x40
 80021dc:	f7ff f9b0 	bl	8001540 <_pal_lld_setgroupmode>
  palClearLine(LED1);
 80021e0:	f8a7 801a 	strh.w	r8, [r7, #26]
  palClearLine(LED2);
 80021e4:	f8a4 b01a 	strh.w	fp, [r4, #26]
 80021e8:	f38b 8811 	msr	BASEPRI, fp
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 80021ec:	7a33      	ldrb	r3, [r6, #8]
 80021ee:	2b01      	cmp	r3, #1
 80021f0:	d072      	beq.n	80022d8 <main+0x5d8>
  USART_TypeDef *u = sdp->usart;
 80021f2:	6f73      	ldr	r3, [r6, #116]	; 0x74
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 80021f4:	4a48      	ldr	r2, [pc, #288]	; (8002318 <main+0x618>)
 80021f6:	4293      	cmp	r3, r2
 80021f8:	d06a      	beq.n	80022d0 <main+0x5d0>
 80021fa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80021fe:	4293      	cmp	r3, r2
 8002200:	d066      	beq.n	80022d0 <main+0x5d0>
    u->BRR = STM32_PCLK1 / config->speed;
 8002202:	f240 4245 	movw	r2, #1093	; 0x445
 8002206:	609a      	str	r2, [r3, #8]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002208:	f04f 0940 	mov.w	r9, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800220c:	2701      	movs	r7, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800220e:	f242 112c 	movw	r1, #8492	; 0x212c
  u->SR = 0;
 8002212:	2400      	movs	r4, #0
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002214:	f8c3 9010 	str.w	r9, [r3, #16]
    sdp->rxmask = 0xFF;
 8002218:	22ff      	movs	r2, #255	; 0xff
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800221a:	615f      	str	r7, [r3, #20]
  sdp->state = SD_READY;
 800221c:	f04f 0802 	mov.w	r8, #2
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002220:	60d9      	str	r1, [r3, #12]
  u->SR = 0;
 8002222:	601c      	str	r4, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8002224:	6819      	ldr	r1, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8002226:	685b      	ldr	r3, [r3, #4]
    sdp->rxmask = 0xFF;
 8002228:	f886 2078 	strb.w	r2, [r6, #120]	; 0x78
 800222c:	f886 8008 	strb.w	r8, [r6, #8]
 8002230:	f384 8811 	msr	BASEPRI, r4
  // Default is 38400-8-N-1
  // bits :8, stopbits : 1, parity :none, flow control : none
  /* Activates the serial driver 2.
   * PD5(TX) and PD6(RX) are routed to USART2.*/
  sdStart(&SD2, &serialcfg);
  palSetPadMode(GPIOD, 5, PAL_MODE_ALTERNATE(7));
 8002234:	f240 3282 	movw	r2, #898	; 0x382
 8002238:	2120      	movs	r1, #32
 800223a:	4835      	ldr	r0, [pc, #212]	; (8002310 <main+0x610>)
 800223c:	f7ff f980 	bl	8001540 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOD, 6, PAL_MODE_ALTERNATE(7));
 8002240:	4649      	mov	r1, r9
 8002242:	f240 3282 	movw	r2, #898	; 0x382
 8002246:	4832      	ldr	r0, [pc, #200]	; (8002310 <main+0x610>)
 8002248:	f7ff f97a 	bl	8001540 <_pal_lld_setgroupmode>
  chprintf((BaseSequentialStream *)&SD2,"Debug Via Serial Using UART2 \r\n");
 800224c:	4933      	ldr	r1, [pc, #204]	; (800231c <main+0x61c>)
 800224e:	4834      	ldr	r0, [pc, #208]	; (8002320 <main+0x620>)
 8002250:	f000 fcd6 	bl	8002c00 <chprintf.constprop.0>
 8002254:	2320      	movs	r3, #32
 8002256:	f383 8811 	msr	BASEPRI, r3
  tp->wabase = (stkalign_t *)wsp;
 800225a:	4b32      	ldr	r3, [pc, #200]	; (8002324 <main+0x624>)
  REG_INSERT(tp);
 800225c:	6969      	ldr	r1, [r5, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800225e:	4a2b      	ldr	r2, [pc, #172]	; (800230c <main+0x60c>)
 8002260:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
 8002264:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 8002330 <main+0x630>
  tp->name      = name;
 8002268:	4e2f      	ldr	r6, [pc, #188]	; (8002328 <main+0x628>)
 800226a:	f8c3 6198 	str.w	r6, [r3, #408]	; 0x198
  REG_INSERT(tp);
 800226e:	f503 72c0 	add.w	r2, r3, #384	; 0x180
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002272:	f503 7cae 	add.w	ip, r3, #348	; 0x15c
  tp->prio      = prio;
 8002276:	2085      	movs	r0, #133	; 0x85
  REG_INSERT(tp);
 8002278:	f8c3 1194 	str.w	r1, [r3, #404]	; 0x194
  tp->prio      = prio;
 800227c:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  tp->realprio  = prio;
 8002280:	f8c3 01bc 	str.w	r0, [r3, #444]	; 0x1bc
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002284:	f8c3 4160 	str.w	r4, [r3, #352]	; 0x160
  tp->state     = CH_STATE_WTSTART;
 8002288:	f883 81a0 	strb.w	r8, [r3, #416]	; 0x1a0
  tp->flags     = CH_FLAG_MODE_STATIC;
 800228c:	f883 41a1 	strb.w	r4, [r3, #417]	; 0x1a1
  tp->mtxlist   = NULL;
 8002290:	f8c3 41b8 	str.w	r4, [r3, #440]	; 0x1b8
  tp->epending  = (eventmask_t)0;
 8002294:	f8c3 41b4 	str.w	r4, [r3, #436]	; 0x1b4
  tp->refs      = (trefs_t)1;
 8002298:	f883 71a2 	strb.w	r7, [r3, #418]	; 0x1a2
  REG_INSERT(tp);
 800229c:	f8c3 5190 	str.w	r5, [r3, #400]	; 0x190
  tp->wabase = (stkalign_t *)wsp;
 80022a0:	f8c3 319c 	str.w	r3, [r3, #412]	; 0x19c
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 80022a4:	f8c3 c18c 	str.w	ip, [r3, #396]	; 0x18c
 80022a8:	f8c3 e15c 	str.w	lr, [r3, #348]	; 0x15c
  tlp->next = (thread_t *)tlp;
 80022ac:	f503 76d4 	add.w	r6, r3, #424	; 0x1a8
  REG_INSERT(tp);
 80022b0:	610a      	str	r2, [r1, #16]
  tqp->next = (thread_t *)tqp;
 80022b2:	f503 71d6 	add.w	r1, r3, #428	; 0x1ac
  chSchWakeupS(tp, MSG_OK);
 80022b6:	4610      	mov	r0, r2
  tlp->next = (thread_t *)tlp;
 80022b8:	f8c3 61a8 	str.w	r6, [r3, #424]	; 0x1a8
  tqp->next = (thread_t *)tqp;
 80022bc:	f8c3 11ac 	str.w	r1, [r3, #428]	; 0x1ac
  tqp->prev = (thread_t *)tqp;
 80022c0:	f8c3 11b0 	str.w	r1, [r3, #432]	; 0x1b0
  REG_INSERT(tp);
 80022c4:	616a      	str	r2, [r5, #20]
  chSchWakeupS(tp, MSG_OK);
 80022c6:	f000 fc63 	bl	8002b90 <chSchWakeupS.constprop.10>
 80022ca:	f384 8811 	msr	BASEPRI, r4
 80022ce:	e7fe      	b.n	80022ce <main+0x5ce>
    u->BRR = STM32_PCLK2 / config->speed;
 80022d0:	f640 028b 	movw	r2, #2187	; 0x88b
 80022d4:	609a      	str	r2, [r3, #8]
 80022d6:	e797      	b.n	8002208 <main+0x508>
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccEnableUSART2(true);
 80022d8:	f8d9 3040 	ldr.w	r3, [r9, #64]	; 0x40
 80022dc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80022e0:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
 80022e4:	f8d9 3060 	ldr.w	r3, [r9, #96]	; 0x60
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80022e8:	2240      	movs	r2, #64	; 0x40
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80022ea:	21c0      	movs	r1, #192	; 0xc0
 80022ec:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80022f0:	f8c9 3060 	str.w	r3, [r9, #96]	; 0x60
 80022f4:	f88a 1326 	strb.w	r1, [sl, #806]	; 0x326
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80022f8:	f8ca 2184 	str.w	r2, [sl, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80022fc:	f8ca 2004 	str.w	r2, [sl, #4]
 8002300:	e777      	b.n	80021f2 <main+0x4f2>
 8002302:	bf00      	nop
 8002304:	20000950 	.word	0x20000950
 8002308:	08003190 	.word	0x08003190
 800230c:	080002d1 	.word	0x080002d1
 8002310:	40020c00 	.word	0x40020c00
 8002314:	40020400 	.word	0x40020400
 8002318:	40011000 	.word	0x40011000
 800231c:	08003198 	.word	0x08003198
 8002320:	20000c18 	.word	0x20000c18
 8002324:	20000a50 	.word	0x20000a50
 8002328:	080031b8 	.word	0x080031b8
 800232c:	08002441 	.word	0x08002441
 8002330:	08001c31 	.word	0x08001c31
	...

08002340 <chCoreAllocAlignedI.lto_priv.43>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8002340:	b4f0      	push	{r4, r5, r6, r7}

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002342:	4e0b      	ldr	r6, [pc, #44]	; (8002370 <chCoreAllocAlignedI.lto_priv.43+0x30>)
 8002344:	6837      	ldr	r7, [r6, #0]
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8002346:	6872      	ldr	r2, [r6, #4]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002348:	1e7c      	subs	r4, r7, #1
  size = MEM_ALIGN_NEXT(size, align);
 800234a:	1e4b      	subs	r3, r1, #1
 800234c:	424d      	negs	r5, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800234e:	440c      	add	r4, r1
  size = MEM_ALIGN_NEXT(size, align);
 8002350:	1819      	adds	r1, r3, r0
 8002352:	4029      	ands	r1, r5
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002354:	ea04 0005 	and.w	r0, r4, r5
  next = p + size;
 8002358:	4401      	add	r1, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800235a:	4291      	cmp	r1, r2
 800235c:	d804      	bhi.n	8002368 <chCoreAllocAlignedI.lto_priv.43+0x28>
 800235e:	428f      	cmp	r7, r1
 8002360:	d802      	bhi.n	8002368 <chCoreAllocAlignedI.lto_priv.43+0x28>
    return NULL;
  }

  ch_memcore.nextmem = next;
 8002362:	6031      	str	r1, [r6, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 8002364:	bcf0      	pop	{r4, r5, r6, r7}
 8002366:	4770      	bx	lr
    return NULL;
 8002368:	2000      	movs	r0, #0
 800236a:	bcf0      	pop	{r4, r5, r6, r7}
 800236c:	4770      	bx	lr
 800236e:	bf00      	nop
 8002370:	20000a28 	.word	0x20000a28
	...

08002380 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8002380:	b4f0      	push	{r4, r5, r6, r7}
 8002382:	2320      	movs	r3, #32
 8002384:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002388:	4d0d      	ldr	r5, [pc, #52]	; (80023c0 <chCoreAllocAlignedWithOffset+0x40>)
 800238a:	682f      	ldr	r7, [r5, #0]
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800238c:	686c      	ldr	r4, [r5, #4]
 800238e:	1e4e      	subs	r6, r1, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002390:	443a      	add	r2, r7
  size = MEM_ALIGN_NEXT(size, align);
 8002392:	1983      	adds	r3, r0, r6
 8002394:	4249      	negs	r1, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002396:	1990      	adds	r0, r2, r6
  size = MEM_ALIGN_NEXT(size, align);
 8002398:	400b      	ands	r3, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800239a:	4008      	ands	r0, r1
  next = p + size;
 800239c:	4403      	add	r3, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800239e:	42a3      	cmp	r3, r4
 80023a0:	d807      	bhi.n	80023b2 <chCoreAllocAlignedWithOffset+0x32>
 80023a2:	429f      	cmp	r7, r3
 80023a4:	d805      	bhi.n	80023b2 <chCoreAllocAlignedWithOffset+0x32>
  ch_memcore.nextmem = next;
 80023a6:	602b      	str	r3, [r5, #0]
 80023a8:	2300      	movs	r3, #0
 80023aa:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
 80023ae:	bcf0      	pop	{r4, r5, r6, r7}
 80023b0:	4770      	bx	lr
    return NULL;
 80023b2:	2000      	movs	r0, #0
 80023b4:	2300      	movs	r3, #0
 80023b6:	f383 8811 	msr	BASEPRI, r3
}
 80023ba:	bcf0      	pop	{r4, r5, r6, r7}
 80023bc:	4770      	bx	lr
 80023be:	bf00      	nop
 80023c0:	20000a28 	.word	0x20000a28
	...

080023d0 <wakeup>:
 80023d0:	2320      	movs	r3, #32
 80023d2:	f383 8811 	msr	BASEPRI, r3
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 80023d6:	f890 3020 	ldrb.w	r3, [r0, #32]
 80023da:	2b07      	cmp	r3, #7
 80023dc:	d80e      	bhi.n	80023fc <wakeup+0x2c>
 80023de:	e8df f003 	tbb	[pc, r3]
 80023e2:	0d28      	.short	0x0d28
 80023e4:	0408240d 	.word	0x0408240d
 80023e8:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80023ea:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 80023ec:	6893      	ldr	r3, [r2, #8]
 80023ee:	3301      	adds	r3, #1
 80023f0:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 80023f2:	e890 000c 	ldmia.w	r0, {r2, r3}
 80023f6:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80023f8:	6802      	ldr	r2, [r0, #0]
 80023fa:	6053      	str	r3, [r2, #4]
static void wakeup(void *p) {
 80023fc:	b410      	push	{r4}
  tp->state = CH_STATE_READY;
 80023fe:	2200      	movs	r2, #0
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8002400:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8002404:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8002406:	4b0d      	ldr	r3, [pc, #52]	; (800243c <wakeup+0x6c>)
  tp->u.rdymsg = MSG_TIMEOUT;
 8002408:	6244      	str	r4, [r0, #36]	; 0x24
  tp->state = CH_STATE_READY;
 800240a:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 800240e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8002410:	689a      	ldr	r2, [r3, #8]
 8002412:	428a      	cmp	r2, r1
 8002414:	d2fb      	bcs.n	800240e <wakeup+0x3e>
  tp->queue.prev             = cp->queue.prev;
 8002416:	685a      	ldr	r2, [r3, #4]
 8002418:	6042      	str	r2, [r0, #4]
  tp->queue.next             = cp;
 800241a:	6003      	str	r3, [r0, #0]
 800241c:	2100      	movs	r1, #0
  tp->queue.prev->queue.next = tp;
 800241e:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8002420:	6058      	str	r0, [r3, #4]
 8002422:	f381 8811 	msr	BASEPRI, r1
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8002426:	bc10      	pop	{r4}
 8002428:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 800242a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800242c:	2200      	movs	r2, #0
 800242e:	601a      	str	r2, [r3, #0]
 8002430:	e7e4      	b.n	80023fc <wakeup+0x2c>
 8002432:	2300      	movs	r3, #0
 8002434:	f383 8811 	msr	BASEPRI, r3
 8002438:	4770      	bx	lr
 800243a:	bf00      	nop
 800243c:	20000cc4 	.word	0x20000cc4

08002440 <_idle_thread.lto_priv.47>:
static void _idle_thread(void *p) {
 8002440:	e7fe      	b.n	8002440 <_idle_thread.lto_priv.47>
 8002442:	bf00      	nop
	...

08002450 <chSchGoSleepS>:
  thread_t *otp = currp;
 8002450:	4b08      	ldr	r3, [pc, #32]	; (8002474 <chSchGoSleepS+0x24>)
 8002452:	6999      	ldr	r1, [r3, #24]
  thread_t *tp = tqp->next;
 8002454:	681a      	ldr	r2, [r3, #0]
void chSchGoSleepS(tstate_t newstate) {
 8002456:	b410      	push	{r4}
  otp->state = newstate;
 8002458:	f881 0020 	strb.w	r0, [r1, #32]
  tqp->next             = tp->queue.next;
 800245c:	6810      	ldr	r0, [r2, #0]
 800245e:	6018      	str	r0, [r3, #0]
  currp->state = CH_STATE_CURRENT;
 8002460:	2401      	movs	r4, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8002462:	6043      	str	r3, [r0, #4]
 8002464:	f882 4020 	strb.w	r4, [r2, #32]
  chSysSwitch(currp, otp);
 8002468:	4610      	mov	r0, r2
}
 800246a:	bc10      	pop	{r4}
  currp = queue_fifo_remove(&ch.rlist.queue);
 800246c:	619a      	str	r2, [r3, #24]
  chSysSwitch(currp, otp);
 800246e:	f7fd bf27 	b.w	80002c0 <_port_switch>
 8002472:	bf00      	nop
 8002474:	20000cc4 	.word	0x20000cc4
	...

08002480 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8002480:	b5f0      	push	{r4, r5, r6, r7, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
 8002482:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8002484:	b087      	sub	sp, #28
  if (TIME_INFINITE != timeout) {
 8002486:	d04c      	beq.n	8002522 <chSchGoSleepTimeoutS+0xa2>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
 8002488:	4c41      	ldr	r4, [pc, #260]	; (8002590 <chSchGoSleepTimeoutS+0x110>)
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800248a:	4625      	mov	r5, r4
  vtp->par = par;
 800248c:	69a3      	ldr	r3, [r4, #24]
 800248e:	9305      	str	r3, [sp, #20]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002490:	f855 3f1c 	ldr.w	r3, [r5, #28]!
 8002494:	2902      	cmp	r1, #2
  return (systime_t)STM32_ST_TIM->CNT;
 8002496:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
 800249a:	4607      	mov	r7, r0
 800249c:	bf38      	it	cc
 800249e:	2102      	movcc	r1, #2
  vtp->func = vtfunc;
 80024a0:	483c      	ldr	r0, [pc, #240]	; (8002594 <chSchGoSleepTimeoutS+0x114>)
 80024a2:	f8de 2024 	ldr.w	r2, [lr, #36]	; 0x24
 80024a6:	9004      	str	r0, [sp, #16]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80024a8:	42ab      	cmp	r3, r5
 80024aa:	d05c      	beq.n	8002566 <chSchGoSleepTimeoutS+0xe6>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 80024ac:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  return (sysinterval_t)((systime_t)(end - start));
 80024ae:	1a12      	subs	r2, r2, r0

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 80024b0:	1889      	adds	r1, r1, r2
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 80024b2:	689a      	ldr	r2, [r3, #8]
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 80024b4:	d231      	bcs.n	800251a <chSchGoSleepTimeoutS+0x9a>
      p = p->next;
    }
    else if (delta < p->delta) {
 80024b6:	4291      	cmp	r1, r2
  return systime + (systime_t)interval;
 80024b8:	bf3c      	itt	cc
 80024ba:	1840      	addcc	r0, r0, r1
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80024bc:	f8ce 0034 	strcc.w	r0, [lr, #52]	; 0x34
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 80024c0:	4291      	cmp	r1, r2
 80024c2:	d904      	bls.n	80024ce <chSchGoSleepTimeoutS+0x4e>
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
    p = p->next;
 80024c4:	681b      	ldr	r3, [r3, #0]
    delta -= p->delta;
 80024c6:	1a89      	subs	r1, r1, r2
  while (p->delta < delta) {
 80024c8:	689a      	ldr	r2, [r3, #8]
 80024ca:	428a      	cmp	r2, r1
 80024cc:	d3fa      	bcc.n	80024c4 <chSchGoSleepTimeoutS+0x44>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 80024ce:	685a      	ldr	r2, [r3, #4]
 80024d0:	9202      	str	r2, [sp, #8]
  vtp->prev->next = vtp;
 80024d2:	ae01      	add	r6, sp, #4
  vtp->next = p;
 80024d4:	9301      	str	r3, [sp, #4]
  vtp->prev->next = vtp;
 80024d6:	6016      	str	r6, [r2, #0]
  p->prev = vtp;
 80024d8:	605e      	str	r6, [r3, #4]
  vtp->delta = delta;
 80024da:	9103      	str	r1, [sp, #12]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 80024dc:	689a      	ldr	r2, [r3, #8]
 80024de:	1a51      	subs	r1, r2, r1

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 80024e0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  p->delta -= delta;
 80024e4:	6099      	str	r1, [r3, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 80024e6:	6262      	str	r2, [r4, #36]	; 0x24
    chSchGoSleepS(newstate);
 80024e8:	4638      	mov	r0, r7
 80024ea:	f7ff ffb1 	bl	8002450 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80024ee:	9b04      	ldr	r3, [sp, #16]
 80024f0:	b17b      	cbz	r3, 8002512 <chSchGoSleepTimeoutS+0x92>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 80024f2:	69e3      	ldr	r3, [r4, #28]
 80024f4:	42b3      	cmp	r3, r6
 80024f6:	d01b      	beq.n	8002530 <chSchGoSleepTimeoutS+0xb0>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 80024f8:	9a02      	ldr	r2, [sp, #8]
 80024fa:	9b01      	ldr	r3, [sp, #4]
 80024fc:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 80024fe:	9b01      	ldr	r3, [sp, #4]
    vtp->func = NULL;
 8002500:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002502:	42ab      	cmp	r3, r5
    vtp->next->prev = vtp->prev;
 8002504:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8002506:	9104      	str	r1, [sp, #16]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002508:	d003      	beq.n	8002512 <chSchGoSleepTimeoutS+0x92>
      vtp->next->delta += vtp->delta;
 800250a:	689a      	ldr	r2, [r3, #8]
 800250c:	9903      	ldr	r1, [sp, #12]
 800250e:	440a      	add	r2, r1
 8002510:	609a      	str	r2, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8002512:	69a3      	ldr	r3, [r4, #24]
}
 8002514:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002516:	b007      	add	sp, #28
 8002518:	bdf0      	pop	{r4, r5, r6, r7, pc}
      p = p->next;
 800251a:	681b      	ldr	r3, [r3, #0]
      delta -= p->delta;
 800251c:	1a89      	subs	r1, r1, r2
 800251e:	689a      	ldr	r2, [r3, #8]
 8002520:	e7ce      	b.n	80024c0 <chSchGoSleepTimeoutS+0x40>
 8002522:	4c1b      	ldr	r4, [pc, #108]	; (8002590 <chSchGoSleepTimeoutS+0x110>)
    chSchGoSleepS(newstate);
 8002524:	f7ff ff94 	bl	8002450 <chSchGoSleepS>
  return currp->u.rdymsg;
 8002528:	69a3      	ldr	r3, [r4, #24]
}
 800252a:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800252c:	b007      	add	sp, #28
 800252e:	bdf0      	pop	{r4, r5, r6, r7, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8002530:	9b01      	ldr	r3, [sp, #4]
 8002532:	61e3      	str	r3, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8002534:	2200      	movs	r2, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002536:	42ab      	cmp	r3, r5
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8002538:	605d      	str	r5, [r3, #4]
  vtp->func = NULL;
 800253a:	9204      	str	r2, [sp, #16]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800253c:	d024      	beq.n	8002588 <chSchGoSleepTimeoutS+0x108>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 800253e:	689a      	ldr	r2, [r3, #8]
 8002540:	9803      	ldr	r0, [sp, #12]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8002542:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8002544:	4402      	add	r2, r0
  return (systime_t)STM32_ST_TIM->CNT;
 8002546:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800254a:	609a      	str	r2, [r3, #8]
 800254c:	6a43      	ldr	r3, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 800254e:	1a5b      	subs	r3, r3, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8002550:	429a      	cmp	r2, r3
 8002552:	d9de      	bls.n	8002512 <chSchGoSleepTimeoutS+0x92>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8002554:	1ad0      	subs	r0, r2, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8002556:	2801      	cmp	r0, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002558:	bf98      	it	ls
 800255a:	1c9a      	addls	r2, r3, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800255c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 8002560:	440a      	add	r2, r1
 8002562:	635a      	str	r2, [r3, #52]	; 0x34
 8002564:	e7d5      	b.n	8002512 <chSchGoSleepTimeoutS+0x92>
      ch.vtlist.lasttime = now;
 8002566:	62a2      	str	r2, [r4, #40]	; 0x28
 8002568:	1888      	adds	r0, r1, r2
      ch.vtlist.next = vtp;
 800256a:	ae01      	add	r6, sp, #4
  STM32_ST_TIM->SR     = 0;
 800256c:	2200      	movs	r2, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800256e:	2302      	movs	r3, #2
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8002570:	9501      	str	r5, [sp, #4]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8002572:	9502      	str	r5, [sp, #8]
      vtp->delta = delay;
 8002574:	9103      	str	r1, [sp, #12]
      ch.vtlist.next = vtp;
 8002576:	61e6      	str	r6, [r4, #28]
      ch.vtlist.prev = vtp;
 8002578:	6226      	str	r6, [r4, #32]
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800257a:	f8ce 0034 	str.w	r0, [lr, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800257e:	f8ce 2010 	str.w	r2, [lr, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8002582:	f8ce 300c 	str.w	r3, [lr, #12]
 8002586:	e7af      	b.n	80024e8 <chSchGoSleepTimeoutS+0x68>
  STM32_ST_TIM->DIER = 0;
 8002588:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800258c:	60da      	str	r2, [r3, #12]
 800258e:	e7c0      	b.n	8002512 <chSchGoSleepTimeoutS+0x92>
 8002590:	20000cc4 	.word	0x20000cc4
 8002594:	080023d1 	.word	0x080023d1
	...

080025a0 <_port_irq_epilogue>:
 80025a0:	2320      	movs	r3, #32
 80025a2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80025a6:	4b0f      	ldr	r3, [pc, #60]	; (80025e4 <_port_irq_epilogue+0x44>)
 80025a8:	685b      	ldr	r3, [r3, #4]
 80025aa:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80025ae:	d102      	bne.n	80025b6 <_port_irq_epilogue+0x16>
 80025b0:	f383 8811 	msr	BASEPRI, r3
 80025b4:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80025b6:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80025ba:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80025be:	f843 2c04 	str.w	r2, [r3, #-4]
    ctxp--;
 80025c2:	f1a3 0220 	sub.w	r2, r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80025c6:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80025ca:	4a07      	ldr	r2, [pc, #28]	; (80025e8 <_port_irq_epilogue+0x48>)
 80025cc:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 80025ce:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80025d0:	6889      	ldr	r1, [r1, #8]
 80025d2:	6892      	ldr	r2, [r2, #8]
 80025d4:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80025d6:	bf8c      	ite	hi
 80025d8:	4a04      	ldrhi	r2, [pc, #16]	; (80025ec <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80025da:	4a05      	ldrls	r2, [pc, #20]	; (80025f0 <_port_irq_epilogue+0x50>)
 80025dc:	f843 2c08 	str.w	r2, [r3, #-8]
 80025e0:	4770      	bx	lr
 80025e2:	bf00      	nop
 80025e4:	e000ed00 	.word	0xe000ed00
 80025e8:	20000cc4 	.word	0x20000cc4
 80025ec:	080002e1 	.word	0x080002e1
 80025f0:	080002e4 	.word	0x080002e4
	...

08002600 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002600:	f3ef 8309 	mrs	r3, PSP
  ctxp++;
 8002604:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8002606:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800260a:	2300      	movs	r3, #0
 800260c:	f383 8811 	msr	BASEPRI, r3
 8002610:	4770      	bx	lr
 8002612:	bf00      	nop
	...

08002620 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8002620:	4b0e      	ldr	r3, [pc, #56]	; (800265c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8002622:	4a0f      	ldr	r2, [pc, #60]	; (8002660 <chTMStopMeasurementX+0x40>)
 8002624:	685b      	ldr	r3, [r3, #4]
  tmp->n++;
 8002626:	68c1      	ldr	r1, [r0, #12]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8002628:	b4f0      	push	{r4, r5, r6, r7}
  tmp->last = (now - tmp->last) - offset;
 800262a:	6887      	ldr	r7, [r0, #8]
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800262c:	6f56      	ldr	r6, [r2, #116]	; 0x74
  if (tmp->last > tmp->worst) {
 800262e:	6842      	ldr	r2, [r0, #4]
  tmp->cumulative += (rttime_t)tmp->last;
 8002630:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 8002634:	1bdb      	subs	r3, r3, r7
 8002636:	1b9b      	subs	r3, r3, r6
  tmp->cumulative += (rttime_t)tmp->last;
 8002638:	18e4      	adds	r4, r4, r3
 800263a:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 800263e:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 8002640:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
 8002642:	bf88      	it	hi
 8002644:	6043      	strhi	r3, [r0, #4]
  tmp->n++;
 8002646:	3101      	adds	r1, #1
  if (tmp->last < tmp->best) {
 8002648:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 800264a:	e9c0 4504 	strd	r4, r5, [r0, #16]
  tmp->n++;
 800264e:	60c1      	str	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8002650:	6083      	str	r3, [r0, #8]
    tmp->best = tmp->last;
 8002652:	bf38      	it	cc
 8002654:	6003      	strcc	r3, [r0, #0]
}
 8002656:	bcf0      	pop	{r4, r5, r6, r7}
 8002658:	4770      	bx	lr
 800265a:	bf00      	nop
 800265c:	e0001000 	.word	0xe0001000
 8002660:	20000cc4 	.word	0x20000cc4
	...

08002670 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
 8002670:	b161      	cbz	r1, 800268c <chThdEnqueueTimeoutS+0x1c>
  queue_insert(currp, tqp);
 8002672:	4b08      	ldr	r3, [pc, #32]	; (8002694 <chThdEnqueueTimeoutS+0x24>)
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8002674:	b410      	push	{r4}
 8002676:	4602      	mov	r2, r0
  tp->queue.prev             = tqp->prev;
 8002678:	6844      	ldr	r4, [r0, #4]
  queue_insert(currp, tqp);
 800267a:	699b      	ldr	r3, [r3, #24]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800267c:	2004      	movs	r0, #4
 800267e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->queue.prev->queue.next = tp;
 8002682:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 8002684:	6053      	str	r3, [r2, #4]
}
 8002686:	bc10      	pop	{r4}
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8002688:	f7ff befa 	b.w	8002480 <chSchGoSleepTimeoutS>
}
 800268c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8002690:	4770      	bx	lr
 8002692:	bf00      	nop
 8002694:	20000cc4 	.word	0x20000cc4
	...

080026a0 <chSchDoReschedule>:
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;
 80026a0:	4a0e      	ldr	r2, [pc, #56]	; (80026dc <chSchDoReschedule+0x3c>)
  thread_t *tp = tqp->next;
 80026a2:	6810      	ldr	r0, [r2, #0]
  tqp->next             = tp->queue.next;
 80026a4:	6803      	ldr	r3, [r0, #0]
void chSchDoRescheduleAhead(void) {
 80026a6:	b430      	push	{r4, r5}

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80026a8:	2101      	movs	r1, #1
  thread_t *otp = currp;
 80026aa:	6994      	ldr	r4, [r2, #24]
  tqp->next->queue.prev = (thread_t *)tqp;
 80026ac:	605a      	str	r2, [r3, #4]
  tp->state = CH_STATE_READY;
 80026ae:	2500      	movs	r5, #0
  currp->state = CH_STATE_CURRENT;
 80026b0:	f880 1020 	strb.w	r1, [r0, #32]

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
 80026b4:	68a1      	ldr	r1, [r4, #8]
  tqp->next             = tp->queue.next;
 80026b6:	6013      	str	r3, [r2, #0]
  currp = queue_fifo_remove(&ch.rlist.queue);
 80026b8:	6190      	str	r0, [r2, #24]
  tp->state = CH_STATE_READY;
 80026ba:	f884 5020 	strb.w	r5, [r4, #32]
 80026be:	e000      	b.n	80026c2 <chSchDoReschedule+0x22>
 80026c0:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 80026c2:	689a      	ldr	r2, [r3, #8]
 80026c4:	4291      	cmp	r1, r2
 80026c6:	d3fb      	bcc.n	80026c0 <chSchDoReschedule+0x20>
  tp->queue.prev             = cp->queue.prev;
 80026c8:	685a      	ldr	r2, [r3, #4]
 80026ca:	6062      	str	r2, [r4, #4]
  tp->queue.next             = cp;
 80026cc:	6023      	str	r3, [r4, #0]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80026ce:	4621      	mov	r1, r4
  tp->queue.prev->queue.next = tp;
 80026d0:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80026d2:	605c      	str	r4, [r3, #4]
}
 80026d4:	bc30      	pop	{r4, r5}
  chSysSwitch(currp, otp);
 80026d6:	f7fd bdf3 	b.w	80002c0 <_port_switch>
 80026da:	bf00      	nop
 80026dc:	20000cc4 	.word	0x20000cc4

080026e0 <chSchReadyI>:
  tp->state = CH_STATE_READY;
 80026e0:	2200      	movs	r2, #0
 80026e2:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 80026e4:	4b08      	ldr	r3, [pc, #32]	; (8002708 <chSchReadyI+0x28>)
thread_t *chSchReadyI(thread_t *tp) {
 80026e6:	b410      	push	{r4}
 80026e8:	4604      	mov	r4, r0
  tp->state = CH_STATE_READY;
 80026ea:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 80026ee:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80026f0:	689a      	ldr	r2, [r3, #8]
 80026f2:	428a      	cmp	r2, r1
 80026f4:	d2fb      	bcs.n	80026ee <chSchReadyI+0xe>
  tp->queue.prev             = cp->queue.prev;
 80026f6:	685a      	ldr	r2, [r3, #4]
 80026f8:	6062      	str	r2, [r4, #4]
  tp->queue.next             = cp;
 80026fa:	6023      	str	r3, [r4, #0]
}
 80026fc:	4620      	mov	r0, r4
  tp->queue.prev->queue.next = tp;
 80026fe:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8002700:	605c      	str	r4, [r3, #4]
}
 8002702:	bc10      	pop	{r4}
 8002704:	4770      	bx	lr
 8002706:	bf00      	nop
 8002708:	20000cc4 	.word	0x20000cc4
 800270c:	00000000 	.word	0x00000000

08002710 <ReadThermocouple>:
uint16_t ReadThermocouple(SPIConfig spicfg){
 8002710:	b084      	sub	sp, #16
 8002712:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002716:	b082      	sub	sp, #8
  uint8_t rxbuf[2] = {0,0};
 8002718:	2400      	movs	r4, #0
uint16_t ReadThermocouple(SPIConfig spicfg){
 800271a:	ad0a      	add	r5, sp, #40	; 0x28
 800271c:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  uint8_t rxbuf[2] = {0,0};
 8002720:	f88d 4004 	strb.w	r4, [sp, #4]
 8002724:	f88d 4005 	strb.w	r4, [sp, #5]
 8002728:	2320      	movs	r3, #32
 800272a:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 800272e:	4ca8      	ldr	r4, [pc, #672]	; (80029d0 <ReadThermocouple+0x2c0>)
  thread_t *ctp = currp;
 8002730:	4da8      	ldr	r5, [pc, #672]	; (80029d4 <ReadThermocouple+0x2c4>)
  if (mp->owner != NULL) {
 8002732:	6960      	ldr	r0, [r4, #20]
  thread_t *ctp = currp;
 8002734:	69ae      	ldr	r6, [r5, #24]
  if (mp->owner != NULL) {
 8002736:	2800      	cmp	r0, #0
 8002738:	f000 8143 	beq.w	80029c2 <ReadThermocouple+0x2b2>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 800273c:	68b2      	ldr	r2, [r6, #8]
 800273e:	6883      	ldr	r3, [r0, #8]
 8002740:	4293      	cmp	r3, r2
 8002742:	d20b      	bcs.n	800275c <ReadThermocouple+0x4c>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8002744:	f890 3020 	ldrb.w	r3, [r0, #32]
        tp->prio = ctp->prio;
 8002748:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
 800274a:	2b06      	cmp	r3, #6
 800274c:	f000 811c 	beq.w	8002988 <ReadThermocouple+0x278>
 8002750:	2b07      	cmp	r3, #7
 8002752:	f000 8105 	beq.w	8002960 <ReadThermocouple+0x250>
 8002756:	2b00      	cmp	r3, #0
 8002758:	f000 80d6 	beq.w	8002908 <ReadThermocouple+0x1f8>
  thread_t *cp = (thread_t *)tqp;
 800275c:	4f9e      	ldr	r7, [pc, #632]	; (80029d8 <ReadThermocouple+0x2c8>)
 800275e:	463b      	mov	r3, r7
 8002760:	e003      	b.n	800276a <ReadThermocouple+0x5a>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002762:	6899      	ldr	r1, [r3, #8]
 8002764:	68b2      	ldr	r2, [r6, #8]
 8002766:	4291      	cmp	r1, r2
 8002768:	d302      	bcc.n	8002770 <ReadThermocouple+0x60>
    cp = cp->queue.next;
 800276a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800276c:	42bb      	cmp	r3, r7
 800276e:	d1f8      	bne.n	8002762 <ReadThermocouple+0x52>
  tp->queue.prev             = cp->queue.prev;
 8002770:	685a      	ldr	r2, [r3, #4]
 8002772:	6072      	str	r2, [r6, #4]
  tp->queue.next             = cp;
 8002774:	6033      	str	r3, [r6, #0]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8002776:	2006      	movs	r0, #6
  tp->queue.prev->queue.next = tp;
 8002778:	6016      	str	r6, [r2, #0]
  cp->queue.prev             = tp;
 800277a:	605e      	str	r6, [r3, #4]
      ctp->u.wtmtxp = mp;
 800277c:	6277      	str	r7, [r6, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800277e:	f7ff fe67 	bl	8002450 <chSchGoSleepS>
 8002782:	2300      	movs	r3, #0
 8002784:	f383 8811 	msr	BASEPRI, r3
 8002788:	2320      	movs	r3, #32
 800278a:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 800278e:	7823      	ldrb	r3, [r4, #0]
  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
 8002790:	aa0a      	add	r2, sp, #40	; 0x28
 8002792:	2b01      	cmp	r3, #1
 8002794:	6062      	str	r2, [r4, #4]
 8002796:	f000 80c6 	beq.w	8002926 <ReadThermocouple+0x216>
 800279a:	a80a      	add	r0, sp, #40	; 0x28
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 800279c:	8a01      	ldrh	r1, [r0, #16]
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800279e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 80027a0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 80027a2:	050e      	lsls	r6, r1, #20
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 80027a4:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 80027a8:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }

  if (spip->config->circular) {
 80027ac:	7806      	ldrb	r6, [r0, #0]
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 80027ae:	bf44      	itt	mi
 80027b0:	f442 5220 	orrmi.w	r2, r2, #10240	; 0x2800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 80027b4:	f443 5320 	orrmi.w	r3, r3, #10240	; 0x2800
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80027b8:	62a2      	str	r2, [r4, #40]	; 0x28
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80027ba:	62e3      	str	r3, [r4, #44]	; 0x2c
  if (spip->config->circular) {
 80027bc:	2e00      	cmp	r6, #0
 80027be:	f040 80ab 	bne.w	8002918 <ReadThermocouple+0x208>
    spip->rxdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
    spip->txdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
  }
  else {
    spip->rxdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 80027c2:	f422 7284 	bic.w	r2, r2, #264	; 0x108
    spip->txdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 80027c6:	f423 7384 	bic.w	r3, r3, #264	; 0x108
    spip->rxdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 80027ca:	62a2      	str	r2, [r4, #40]	; 0x28
    spip->txdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 80027cc:	62e3      	str	r3, [r4, #44]	; 0x2c
  }

  /* SPI setup and enable.*/
  spip->spi->CR1 &= ~SPI_CR1_SPE;
 80027ce:	69e3      	ldr	r3, [r4, #28]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
                    SPI_CR1_SSI;
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 80027d0:	8a42      	ldrh	r2, [r0, #18]
  spip->spi->CR1 &= ~SPI_CR1_SPE;
 80027d2:	6818      	ldr	r0, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 80027d4:	f042 0207 	orr.w	r2, r2, #7
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 80027d8:	f441 7141 	orr.w	r1, r1, #772	; 0x304
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 80027dc:	b292      	uxth	r2, r2
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 80027de:	b289      	uxth	r1, r1
  spip->spi->CR1 &= ~SPI_CR1_SPE;
 80027e0:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 80027e4:	6018      	str	r0, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 80027e6:	6019      	str	r1, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 80027e8:	605a      	str	r2, [r3, #4]
                    SPI_CR2_TXDMAEN;
  spip->spi->CR1 |= SPI_CR1_SPE;
 80027ea:	681a      	ldr	r2, [r3, #0]
  spi_lld_start(spip);
  spip->state = SPI_READY;
 80027ec:	2002      	movs	r0, #2
 80027ee:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80027f2:	601a      	str	r2, [r3, #0]
 80027f4:	f04f 0800 	mov.w	r8, #0
 80027f8:	7020      	strb	r0, [r4, #0]
 80027fa:	f388 8811 	msr	BASEPRI, r8
 80027fe:	f04f 0920 	mov.w	r9, #32
 8002802:	f389 8811 	msr	BASEPRI, r9

  osalDbgCheck(spip != NULL);

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
 8002806:	6862      	ldr	r2, [r4, #4]
 8002808:	68d3      	ldr	r3, [r2, #12]
 800280a:	6892      	ldr	r2, [r2, #8]
 800280c:	2601      	movs	r6, #1
 800280e:	fa06 f303 	lsl.w	r3, r6, r3
 8002812:	b29b      	uxth	r3, r3
 8002814:	8353      	strh	r3, [r2, #26]
 8002816:	f388 8811 	msr	BASEPRI, r8
 800281a:	f389 8811 	msr	BASEPRI, r9
  osalDbgCheck((spip->config->circular == false) || ((n & 1U) == 0U));
#endif

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartReceiveI(spip, n, rxbuf);
 800281e:	f04f 0e03 	mov.w	lr, #3
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  osalDbgAssert(n < 65536, "unsupported DMA transfer size");

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8002822:	6a21      	ldr	r1, [r4, #32]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8002824:	6a62      	ldr	r2, [r4, #36]	; 0x24
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8002826:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002828:	f884 e000 	strb.w	lr, [r4]
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800282c:	6809      	ldr	r1, [r1, #0]
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800282e:	6812      	ldr	r2, [r2, #0]
 8002830:	f8df c1b8 	ldr.w	ip, [pc, #440]	; 80029ec <ReadThermocouple+0x2dc>
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8002834:	f10d 0a04 	add.w	sl, sp, #4
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8002838:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800283c:	f8c1 a00c 	str.w	sl, [r1, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8002840:	6048      	str	r0, [r1, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8002842:	600b      	str	r3, [r1, #0]
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 8002844:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8002846:	f8c2 c00c 	str.w	ip, [r2, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800284a:	6050      	str	r0, [r2, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800284c:	6013      	str	r3, [r2, #0]

  dmaStreamEnable(spip->dmarx);
 800284e:	680b      	ldr	r3, [r1, #0]
  return ch.rlist.current;
 8002850:	f8d5 c018 	ldr.w	ip, [r5, #24]
  tp->u.wttrp = trp;
 8002854:	f8df a198 	ldr.w	sl, [pc, #408]	; 80029f0 <ReadThermocouple+0x2e0>
 8002858:	4333      	orrs	r3, r6
 800285a:	600b      	str	r3, [r1, #0]
  dmaStreamEnable(spip->dmatx);
 800285c:	6813      	ldr	r3, [r2, #0]
 800285e:	4333      	orrs	r3, r6
 8002860:	6013      	str	r3, [r2, #0]
    chSchGoSleepS(newstate);
 8002862:	4670      	mov	r0, lr
 8002864:	f8cc a024 	str.w	sl, [ip, #36]	; 0x24
  *trp = tp;
 8002868:	f8c4 c008 	str.w	ip, [r4, #8]
 800286c:	f7ff fdf0 	bl	8002450 <chSchGoSleepS>
 8002870:	f388 8811 	msr	BASEPRI, r8
 8002874:	f389 8811 	msr	BASEPRI, r9
  spiUnselectI(spip);
 8002878:	6863      	ldr	r3, [r4, #4]
 800287a:	68da      	ldr	r2, [r3, #12]
 800287c:	689b      	ldr	r3, [r3, #8]
 800287e:	4096      	lsls	r6, r2
 8002880:	b2b6      	uxth	r6, r6
 8002882:	831e      	strh	r6, [r3, #24]
 8002884:	f388 8811 	msr	BASEPRI, r8
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8002888:	69a8      	ldr	r0, [r5, #24]
 800288a:	f389 8811 	msr	BASEPRI, r9
  return (bool)(tqp->next != (const thread_t *)tqp);
 800288e:	68e6      	ldr	r6, [r4, #12]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8002890:	69a3      	ldr	r3, [r4, #24]
 8002892:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002894:	42be      	cmp	r6, r7
 8002896:	f000 8091 	beq.w	80029bc <ReadThermocouple+0x2ac>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 800289a:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 800289c:	b14b      	cbz	r3, 80028b2 <ReadThermocouple+0x1a2>
 800289e:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80028a0:	4293      	cmp	r3, r2
 80028a2:	d003      	beq.n	80028ac <ReadThermocouple+0x19c>
 80028a4:	6892      	ldr	r2, [r2, #8]
 80028a6:	4291      	cmp	r1, r2
 80028a8:	bf38      	it	cc
 80028aa:	4611      	movcc	r1, r2
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 80028ac:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 80028ae:	2b00      	cmp	r3, #0
 80028b0:	d1f5      	bne.n	800289e <ReadThermocouple+0x18e>
  tqp->next             = tp->queue.next;
 80028b2:	6833      	ldr	r3, [r6, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 80028b4:	6bb2      	ldr	r2, [r6, #56]	; 0x38
      ctp->prio = newprio;
 80028b6:	6081      	str	r1, [r0, #8]
 80028b8:	60e3      	str	r3, [r4, #12]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80028ba:	4630      	mov	r0, r6
  tqp->next->queue.prev = (thread_t *)tqp;
 80028bc:	605f      	str	r7, [r3, #4]
      mp->next = tp->mtxlist;
 80028be:	61a2      	str	r2, [r4, #24]
      tp->mtxlist = mp;
 80028c0:	63b7      	str	r7, [r6, #56]	; 0x38
      mp->owner = tp;
 80028c2:	6166      	str	r6, [r4, #20]
      (void) chSchReadyI(tp);
 80028c4:	f7ff ff0c 	bl	80026e0 <chSchReadyI>
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 80028c8:	682a      	ldr	r2, [r5, #0]
 80028ca:	69ab      	ldr	r3, [r5, #24]
  if (chSchIsRescRequiredI()) {
 80028cc:	6892      	ldr	r2, [r2, #8]
 80028ce:	689b      	ldr	r3, [r3, #8]
 80028d0:	429a      	cmp	r2, r3
 80028d2:	d901      	bls.n	80028d8 <ReadThermocouple+0x1c8>
    chSchDoRescheduleAhead();
 80028d4:	f7ff fee4 	bl	80026a0 <chSchDoReschedule>
 80028d8:	2300      	movs	r3, #0
 80028da:	f383 8811 	msr	BASEPRI, r3
  uint16_t i = (rxbuf[0] << 8)|(rxbuf[1]);
 80028de:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80028e2:	f89d 0005 	ldrb.w	r0, [sp, #5]
  i = (i >> 3 ) *0.25; // *0.25degC
 80028e6:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 80028ea:	08c0      	lsrs	r0, r0, #3
 80028ec:	f7fd fe4e 	bl	800058c <__aeabi_i2d>
 80028f0:	2200      	movs	r2, #0
 80028f2:	4b3a      	ldr	r3, [pc, #232]	; (80029dc <ReadThermocouple+0x2cc>)
 80028f4:	f7fd feb0 	bl	8000658 <__aeabi_dmul>
 80028f8:	f7fe f8c0 	bl	8000a7c <__aeabi_d2uiz>
}
 80028fc:	b280      	uxth	r0, r0
 80028fe:	b002      	add	sp, #8
 8002900:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002904:	b004      	add	sp, #16
 8002906:	4770      	bx	lr
  tp->queue.prev->queue.next = tp->queue.next;
 8002908:	e890 000c 	ldmia.w	r0, {r2, r3}
 800290c:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800290e:	6802      	ldr	r2, [r0, #0]
 8002910:	6053      	str	r3, [r2, #4]
          (void) chSchReadyI(queue_dequeue(tp));
 8002912:	f7ff fee5 	bl	80026e0 <chSchReadyI>
 8002916:	e721      	b.n	800275c <ReadThermocouple+0x4c>
    spip->rxdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 8002918:	f442 7284 	orr.w	r2, r2, #264	; 0x108
    spip->txdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 800291c:	f443 7384 	orr.w	r3, r3, #264	; 0x108
    spip->rxdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 8002920:	62a2      	str	r2, [r4, #40]	; 0x28
    spip->txdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
 8002922:	62e3      	str	r3, [r4, #44]	; 0x2c
 8002924:	e753      	b.n	80027ce <ReadThermocouple+0xbe>
      b = dmaStreamAllocate(spip->dmarx,
 8002926:	492e      	ldr	r1, [pc, #184]	; (80029e0 <ReadThermocouple+0x2d0>)
 8002928:	6a20      	ldr	r0, [r4, #32]
 800292a:	f000 f8c9 	bl	8002ac0 <dmaStreamAllocate.constprop.27>
      b = dmaStreamAllocate(spip->dmatx,
 800292e:	492d      	ldr	r1, [pc, #180]	; (80029e4 <ReadThermocouple+0x2d4>)
 8002930:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8002932:	f000 f8c5 	bl	8002ac0 <dmaStreamAllocate.constprop.27>
      rccEnableSPI2(true);
 8002936:	4a2c      	ldr	r2, [pc, #176]	; (80029e8 <ReadThermocouple+0x2d8>)
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8002938:	6a20      	ldr	r0, [r4, #32]
      rccEnableSPI2(true);
 800293a:	6c11      	ldr	r1, [r2, #64]	; 0x40
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800293c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800293e:	f8d0 e000 	ldr.w	lr, [r0]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8002942:	681e      	ldr	r6, [r3, #0]
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8002944:	69e3      	ldr	r3, [r4, #28]
 8002946:	6860      	ldr	r0, [r4, #4]
      rccEnableSPI2(true);
 8002948:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 800294c:	6411      	str	r1, [r2, #64]	; 0x40
 800294e:	6e11      	ldr	r1, [r2, #96]	; 0x60
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8002950:	330c      	adds	r3, #12
      rccEnableSPI2(true);
 8002952:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8002956:	6611      	str	r1, [r2, #96]	; 0x60
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8002958:	f8ce 3008 	str.w	r3, [lr, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800295c:	60b3      	str	r3, [r6, #8]
 800295e:	e71d      	b.n	800279c <ReadThermocouple+0x8c>
  tp->queue.prev->queue.next = tp->queue.next;
 8002960:	e890 000a 	ldmia.w	r0, {r1, r3}
 8002964:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8002966:	6801      	ldr	r1, [r0, #0]
 8002968:	604b      	str	r3, [r1, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800296a:	6a47      	ldr	r7, [r0, #36]	; 0x24
 800296c:	463b      	mov	r3, r7
 800296e:	e002      	b.n	8002976 <ReadThermocouple+0x266>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002970:	6899      	ldr	r1, [r3, #8]
 8002972:	4291      	cmp	r1, r2
 8002974:	d302      	bcc.n	800297c <ReadThermocouple+0x26c>
    cp = cp->queue.next;
 8002976:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002978:	429f      	cmp	r7, r3
 800297a:	d1f9      	bne.n	8002970 <ReadThermocouple+0x260>
  tp->queue.prev             = cp->queue.prev;
 800297c:	685a      	ldr	r2, [r3, #4]
 800297e:	6042      	str	r2, [r0, #4]
  tp->queue.next             = cp;
 8002980:	6003      	str	r3, [r0, #0]
  tp->queue.prev->queue.next = tp;
 8002982:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8002984:	6058      	str	r0, [r3, #4]
 8002986:	e6e9      	b.n	800275c <ReadThermocouple+0x4c>
  tp->queue.prev->queue.next = tp->queue.next;
 8002988:	e890 000a 	ldmia.w	r0, {r1, r3}
 800298c:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800298e:	6801      	ldr	r1, [r0, #0]
 8002990:	604b      	str	r3, [r1, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8002992:	6a47      	ldr	r7, [r0, #36]	; 0x24
 8002994:	463b      	mov	r3, r7
 8002996:	e002      	b.n	800299e <ReadThermocouple+0x28e>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002998:	6899      	ldr	r1, [r3, #8]
 800299a:	4291      	cmp	r1, r2
 800299c:	d302      	bcc.n	80029a4 <ReadThermocouple+0x294>
    cp = cp->queue.next;
 800299e:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80029a0:	429f      	cmp	r7, r3
 80029a2:	d1f9      	bne.n	8002998 <ReadThermocouple+0x288>
  tp->queue.prev             = cp->queue.prev;
 80029a4:	685a      	ldr	r2, [r3, #4]
 80029a6:	6042      	str	r2, [r0, #4]
  tp->queue.next             = cp;
 80029a8:	6003      	str	r3, [r0, #0]
  tp->queue.prev->queue.next = tp;
 80029aa:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 80029ac:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 80029ae:	68b8      	ldr	r0, [r7, #8]
      while (tp->prio < ctp->prio) {
 80029b0:	68b2      	ldr	r2, [r6, #8]
 80029b2:	6883      	ldr	r3, [r0, #8]
 80029b4:	429a      	cmp	r2, r3
 80029b6:	f63f aec5 	bhi.w	8002744 <ReadThermocouple+0x34>
 80029ba:	e6cf      	b.n	800275c <ReadThermocouple+0x4c>
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 80029bc:	f8c4 8014 	str.w	r8, [r4, #20]
 80029c0:	e78a      	b.n	80028d8 <ReadThermocouple+0x1c8>
    mp->next = ctp->mtxlist;
 80029c2:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    mp->owner = ctp;
 80029c4:	6166      	str	r6, [r4, #20]
    ctp->mtxlist = mp;
 80029c6:	f104 070c 	add.w	r7, r4, #12
    mp->next = ctp->mtxlist;
 80029ca:	61a3      	str	r3, [r4, #24]
    ctp->mtxlist = mp;
 80029cc:	63b7      	str	r7, [r6, #56]	; 0x38
 80029ce:	e6d8      	b.n	8002782 <ReadThermocouple+0x72>
 80029d0:	20000c94 	.word	0x20000c94
 80029d4:	20000cc4 	.word	0x20000cc4
 80029d8:	20000ca0 	.word	0x20000ca0
 80029dc:	3fd00000 	.word	0x3fd00000
 80029e0:	08000c51 	.word	0x08000c51
 80029e4:	08000c21 	.word	0x08000c21
 80029e8:	40023800 	.word	0x40023800
 80029ec:	080031e8 	.word	0x080031e8
 80029f0:	20000c9c 	.word	0x20000c9c
	...

08002a00 <chThdExit>:
void chThdExit(msg_t msg) {
 8002a00:	b538      	push	{r3, r4, r5, lr}
 8002a02:	2220      	movs	r2, #32
 8002a04:	4603      	mov	r3, r0
 8002a06:	f382 8811 	msr	BASEPRI, r2
  thread_t *tp = currp;
 8002a0a:	4a10      	ldr	r2, [pc, #64]	; (8002a4c <chThdExit+0x4c>)
 8002a0c:	6994      	ldr	r4, [r2, #24]
  return (bool)(tlp->next != (thread_t *)tlp);
 8002a0e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  tp->u.exitcode = msg;
 8002a10:	6263      	str	r3, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
 8002a12:	f104 0528 	add.w	r5, r4, #40	; 0x28
 8002a16:	4285      	cmp	r5, r0
 8002a18:	d006      	beq.n	8002a28 <chThdExit+0x28>
  tlp->next = tp->queue.next;
 8002a1a:	6803      	ldr	r3, [r0, #0]
 8002a1c:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8002a1e:	f7ff fe5f 	bl	80026e0 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 8002a22:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8002a24:	42a8      	cmp	r0, r5
 8002a26:	d1f8      	bne.n	8002a1a <chThdExit+0x1a>
  if ((tp->refs == (trefs_t)0) &&
 8002a28:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8002a2c:	b943      	cbnz	r3, 8002a40 <chThdExit+0x40>
 8002a2e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8002a32:	079b      	lsls	r3, r3, #30
 8002a34:	d104      	bne.n	8002a40 <chThdExit+0x40>
    REG_REMOVE(tp);
 8002a36:	6963      	ldr	r3, [r4, #20]
 8002a38:	6922      	ldr	r2, [r4, #16]
 8002a3a:	611a      	str	r2, [r3, #16]
 8002a3c:	6922      	ldr	r2, [r4, #16]
 8002a3e:	6153      	str	r3, [r2, #20]
  chSchGoSleepS(CH_STATE_FINAL);
 8002a40:	200f      	movs	r0, #15
}
 8002a42:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 8002a46:	f7ff bd03 	b.w	8002450 <chSchGoSleepS>
 8002a4a:	bf00      	nop
 8002a4c:	20000cc4 	.word	0x20000cc4

08002a50 <chEvtBroadcastFlagsI.constprop.30>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8002a50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8002a52:	4f17      	ldr	r7, [pc, #92]	; (8002ab0 <chEvtBroadcastFlagsI.constprop.30+0x60>)
 8002a54:	f857 4f04 	ldr.w	r4, [r7, #4]!
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8002a58:	42bc      	cmp	r4, r7
 8002a5a:	d021      	beq.n	8002aa0 <chEvtBroadcastFlagsI.constprop.30+0x50>
 8002a5c:	4605      	mov	r5, r0
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8002a5e:	2600      	movs	r6, #0
 8002a60:	e002      	b.n	8002a68 <chEvtBroadcastFlagsI.constprop.30+0x18>
    elp = elp->next;
 8002a62:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8002a64:	42bc      	cmp	r4, r7
 8002a66:	d01b      	beq.n	8002aa0 <chEvtBroadcastFlagsI.constprop.30+0x50>
    elp->flags |= flags;
 8002a68:	68e3      	ldr	r3, [r4, #12]
 8002a6a:	432b      	orrs	r3, r5
 8002a6c:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 8002a6e:	b115      	cbz	r5, 8002a76 <chEvtBroadcastFlagsI.constprop.30+0x26>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 8002a70:	6922      	ldr	r2, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 8002a72:	4213      	tst	r3, r2
 8002a74:	d0f5      	beq.n	8002a62 <chEvtBroadcastFlagsI.constprop.30+0x12>
      chEvtSignalI(elp->listener, elp->events);
 8002a76:	6860      	ldr	r0, [r4, #4]
  tp->epending |= events;
 8002a78:	68a3      	ldr	r3, [r4, #8]
 8002a7a:	6b41      	ldr	r1, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002a7c:	f890 2020 	ldrb.w	r2, [r0, #32]
  tp->epending |= events;
 8002a80:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002a82:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 8002a84:	6343      	str	r3, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002a86:	d00c      	beq.n	8002aa2 <chEvtBroadcastFlagsI.constprop.30+0x52>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8002a88:	2a0b      	cmp	r2, #11
 8002a8a:	d1ea      	bne.n	8002a62 <chEvtBroadcastFlagsI.constprop.30+0x12>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8002a8c:	6a42      	ldr	r2, [r0, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 8002a8e:	ea32 0303 	bics.w	r3, r2, r3
 8002a92:	d1e6      	bne.n	8002a62 <chEvtBroadcastFlagsI.constprop.30+0x12>
    tp->u.rdymsg = MSG_OK;
 8002a94:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002a96:	f7ff fe23 	bl	80026e0 <chSchReadyI>
    elp = elp->next;
 8002a9a:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8002a9c:	42bc      	cmp	r4, r7
 8002a9e:	d1e3      	bne.n	8002a68 <chEvtBroadcastFlagsI.constprop.30+0x18>
 8002aa0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8002aa2:	6a42      	ldr	r2, [r0, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002aa4:	4213      	tst	r3, r2
 8002aa6:	d0dc      	beq.n	8002a62 <chEvtBroadcastFlagsI.constprop.30+0x12>
    tp->u.rdymsg = MSG_OK;
 8002aa8:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002aaa:	f7ff fe19 	bl	80026e0 <chSchReadyI>
 8002aae:	e7f4      	b.n	8002a9a <chEvtBroadcastFlagsI.constprop.30+0x4a>
 8002ab0:	20000c18 	.word	0x20000c18
	...

08002ac0 <dmaStreamAllocate.constprop.27>:
 * @retval false        no error, stream taken.
 * @retval true         error, stream already taken.
 *
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
 8002ac0:	b4f0      	push	{r4, r5, r6, r7}
                       void *param) {

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8002ac2:	4e2d      	ldr	r6, [pc, #180]	; (8002b78 <dmaStreamAllocate.constprop.27+0xb8>)
 8002ac4:	7a44      	ldrb	r4, [r0, #9]
 8002ac6:	6837      	ldr	r7, [r6, #0]
 8002ac8:	2301      	movs	r3, #1
 8002aca:	fa03 f204 	lsl.w	r2, r3, r4
 8002ace:	423a      	tst	r2, r7
 8002ad0:	d14c      	bne.n	8002b6c <dmaStreamAllocate.constprop.27+0xac>
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8002ad2:	4d2a      	ldr	r5, [pc, #168]	; (8002b7c <dmaStreamAllocate.constprop.27+0xbc>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8002ad4:	4b2a      	ldr	r3, [pc, #168]	; (8002b80 <dmaStreamAllocate.constprop.27+0xc0>)
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8002ad6:	f845 1034 	str.w	r1, [r5, r4, lsl #3]
  dma_streams_mask |= (1U << dmastp->selfindex);
 8002ada:	433a      	orrs	r2, r7
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8002adc:	eb05 04c4 	add.w	r4, r5, r4, lsl #3

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 8002ae0:	f012 0fff 	tst.w	r2, #255	; 0xff
  dma_streams_mask |= (1U << dmastp->selfindex);
 8002ae4:	6032      	str	r2, [r6, #0]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8002ae6:	6063      	str	r3, [r4, #4]
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 8002ae8:	d008      	beq.n	8002afc <dmaStreamAllocate.constprop.27+0x3c>
    rccEnableDMA1(true);
 8002aea:	4b26      	ldr	r3, [pc, #152]	; (8002b84 <dmaStreamAllocate.constprop.27+0xc4>)
 8002aec:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8002aee:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
 8002af2:	631c      	str	r4, [r3, #48]	; 0x30
 8002af4:	6d1c      	ldr	r4, [r3, #80]	; 0x50
 8002af6:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
 8002afa:	651c      	str	r4, [r3, #80]	; 0x50
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
 8002afc:	f412 4f7f 	tst.w	r2, #65280	; 0xff00
 8002b00:	d12a      	bne.n	8002b58 <dmaStreamAllocate.constprop.27+0x98>
    rccEnableDMA2(true);
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8002b02:	6802      	ldr	r2, [r0, #0]
 8002b04:	6813      	ldr	r3, [r2, #0]
 8002b06:	f023 031f 	bic.w	r3, r3, #31
 8002b0a:	6013      	str	r3, [r2, #0]
 8002b0c:	6813      	ldr	r3, [r2, #0]
 8002b0e:	f013 0301 	ands.w	r3, r3, #1
 8002b12:	d1fb      	bne.n	8002b0c <dmaStreamAllocate.constprop.27+0x4c>
 8002b14:	7a05      	ldrb	r5, [r0, #8]
 8002b16:	6846      	ldr	r6, [r0, #4]
 8002b18:	243d      	movs	r4, #61	; 0x3d
 8002b1a:	40ac      	lsls	r4, r5
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8002b1c:	2521      	movs	r5, #33	; 0x21
  dmaStreamDisable(dmastp);
 8002b1e:	6034      	str	r4, [r6, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8002b20:	6013      	str	r3, [r2, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8002b22:	6155      	str	r5, [r2, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 8002b24:	b329      	cbz	r1, 8002b72 <dmaStreamAllocate.constprop.27+0xb2>
    nvicEnableVector(dmastp->vector, priority);
 8002b26:	7a81      	ldrb	r1, [r0, #10]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b28:	094a      	lsrs	r2, r1, #5
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b2a:	f101 4460 	add.w	r4, r1, #3758096384	; 0xe0000000
 8002b2e:	0092      	lsls	r2, r2, #2
 8002b30:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 8002b34:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 8002b38:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b3c:	2001      	movs	r0, #1
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b3e:	25a0      	movs	r5, #160	; 0xa0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b40:	f001 011f 	and.w	r1, r1, #31
 8002b44:	fa00 f101 	lsl.w	r1, r0, r1
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b48:	f884 5300 	strb.w	r5, [r4, #768]	; 0x300
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b4c:	4618      	mov	r0, r3
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b4e:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b52:	6011      	str	r1, [r2, #0]
  }

  return false;
}
 8002b54:	bcf0      	pop	{r4, r5, r6, r7}
 8002b56:	4770      	bx	lr
    rccEnableDMA2(true);
 8002b58:	4b0a      	ldr	r3, [pc, #40]	; (8002b84 <dmaStreamAllocate.constprop.27+0xc4>)
 8002b5a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002b5c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8002b60:	631a      	str	r2, [r3, #48]	; 0x30
 8002b62:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002b64:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8002b68:	651a      	str	r2, [r3, #80]	; 0x50
 8002b6a:	e7ca      	b.n	8002b02 <dmaStreamAllocate.constprop.27+0x42>
    return true;
 8002b6c:	4618      	mov	r0, r3
}
 8002b6e:	bcf0      	pop	{r4, r5, r6, r7}
 8002b70:	4770      	bx	lr
  if (func != NULL) {
 8002b72:	4608      	mov	r0, r1
}
 8002b74:	bcf0      	pop	{r4, r5, r6, r7}
 8002b76:	4770      	bx	lr
 8002b78:	20000dbc 	.word	0x20000dbc
 8002b7c:	20000d3c 	.word	0x20000d3c
 8002b80:	20000c94 	.word	0x20000c94
 8002b84:	40023800 	.word	0x40023800
	...

08002b90 <chSchWakeupS.constprop.10>:
  thread_t *otp = currp;
 8002b90:	4b15      	ldr	r3, [pc, #84]	; (8002be8 <chSchWakeupS.constprop.10+0x58>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8002b92:	b470      	push	{r4, r5, r6}
  ntp->u.rdymsg = msg;
 8002b94:	2200      	movs	r2, #0
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8002b96:	4604      	mov	r4, r0
  thread_t *otp = currp;
 8002b98:	699d      	ldr	r5, [r3, #24]
  ntp->u.rdymsg = msg;
 8002b9a:	6242      	str	r2, [r0, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 8002b9c:	68a8      	ldr	r0, [r5, #8]
 8002b9e:	68a1      	ldr	r1, [r4, #8]
 8002ba0:	4281      	cmp	r1, r0
 8002ba2:	d80c      	bhi.n	8002bbe <chSchWakeupS.constprop.10+0x2e>
  tp->state = CH_STATE_READY;
 8002ba4:	f884 2020 	strb.w	r2, [r4, #32]
    cp = cp->queue.next;
 8002ba8:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8002baa:	689a      	ldr	r2, [r3, #8]
 8002bac:	4291      	cmp	r1, r2
 8002bae:	d9fb      	bls.n	8002ba8 <chSchWakeupS.constprop.10+0x18>
  tp->queue.prev             = cp->queue.prev;
 8002bb0:	685a      	ldr	r2, [r3, #4]
 8002bb2:	6062      	str	r2, [r4, #4]
  tp->queue.next             = cp;
 8002bb4:	6023      	str	r3, [r4, #0]
  tp->queue.prev->queue.next = tp;
 8002bb6:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8002bb8:	605c      	str	r4, [r3, #4]
}
 8002bba:	bc70      	pop	{r4, r5, r6}
 8002bbc:	4770      	bx	lr
  tp->state = CH_STATE_READY;
 8002bbe:	f885 2020 	strb.w	r2, [r5, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8002bc2:	461a      	mov	r2, r3
    cp = cp->queue.next;
 8002bc4:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 8002bc6:	6891      	ldr	r1, [r2, #8]
 8002bc8:	4288      	cmp	r0, r1
 8002bca:	d9fb      	bls.n	8002bc4 <chSchWakeupS.constprop.10+0x34>
  tp->queue.prev             = cp->queue.prev;
 8002bcc:	6850      	ldr	r0, [r2, #4]
 8002bce:	6068      	str	r0, [r5, #4]
    ntp->state = CH_STATE_CURRENT;
 8002bd0:	2601      	movs	r6, #1
  tp->queue.next             = cp;
 8002bd2:	602a      	str	r2, [r5, #0]
  tp->queue.prev->queue.next = tp;
 8002bd4:	6005      	str	r5, [r0, #0]
  cp->queue.prev             = tp;
 8002bd6:	6055      	str	r5, [r2, #4]
    ntp->state = CH_STATE_CURRENT;
 8002bd8:	f884 6020 	strb.w	r6, [r4, #32]
    chSysSwitch(ntp, otp);
 8002bdc:	4629      	mov	r1, r5
 8002bde:	4620      	mov	r0, r4
    currp = ntp;
 8002be0:	619c      	str	r4, [r3, #24]
}
 8002be2:	bc70      	pop	{r4, r5, r6}
    chSysSwitch(ntp, otp);
 8002be4:	f7fd bb6c 	b.w	80002c0 <_port_switch>
 8002be8:	20000cc4 	.word	0x20000cc4
 8002bec:	00000000 	.word	0x00000000

08002bf0 <chTMStartMeasurementX.constprop.5>:
 8002bf0:	4b01      	ldr	r3, [pc, #4]	; (8002bf8 <chTMStartMeasurementX.constprop.5+0x8>)
 8002bf2:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 8002bf4:	6083      	str	r3, [r0, #8]
 8002bf6:	4770      	bx	lr
 8002bf8:	e0001000 	.word	0xe0001000
 8002bfc:	00000000 	.word	0x00000000

08002c00 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8002c00:	b40e      	push	{r1, r2, r3}
 8002c02:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002c06:	b086      	sub	sp, #24
 8002c08:	af0f      	add	r7, sp, #60	; 0x3c
 8002c0a:	4d9f      	ldr	r5, [pc, #636]	; (8002e88 <chprintf.constprop.0+0x288>)
 8002c0c:	f857 6b04 	ldr.w	r6, [r7], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8002c10:	9702      	str	r7, [sp, #8]
  int n = 0;
 8002c12:	f04f 0b00 	mov.w	fp, #0
    c = *fmt++;
 8002c16:	7831      	ldrb	r1, [r6, #0]
 8002c18:	1c73      	adds	r3, r6, #1
    if (c == 0)
 8002c1a:	b161      	cbz	r1, 8002c36 <chprintf.constprop.0+0x36>
    if (c != '%') {
 8002c1c:	2925      	cmp	r1, #37	; 0x25
 8002c1e:	d010      	beq.n	8002c42 <chprintf.constprop.0+0x42>
      streamPut(chp, (uint8_t)c);
 8002c20:	682a      	ldr	r2, [r5, #0]
 8002c22:	4899      	ldr	r0, [pc, #612]	; (8002e88 <chprintf.constprop.0+0x288>)
 8002c24:	68d2      	ldr	r2, [r2, #12]
    c = *fmt++;
 8002c26:	461e      	mov	r6, r3
      streamPut(chp, (uint8_t)c);
 8002c28:	4790      	blx	r2
    c = *fmt++;
 8002c2a:	7831      	ldrb	r1, [r6, #0]
      n++;
 8002c2c:	f10b 0b01 	add.w	fp, fp, #1
    c = *fmt++;
 8002c30:	1c73      	adds	r3, r6, #1
    if (c == 0)
 8002c32:	2900      	cmp	r1, #0
 8002c34:	d1f2      	bne.n	8002c1c <chprintf.constprop.0+0x1c>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 8002c36:	4658      	mov	r0, fp
 8002c38:	b006      	add	sp, #24
 8002c3a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002c3e:	b003      	add	sp, #12
 8002c40:	4770      	bx	lr
    if (*fmt == '-') {
 8002c42:	7872      	ldrb	r2, [r6, #1]
 8002c44:	2a2d      	cmp	r2, #45	; 0x2d
 8002c46:	bf03      	ittte	eq
 8002c48:	78b2      	ldrbeq	r2, [r6, #2]
      fmt++;
 8002c4a:	1cb3      	addeq	r3, r6, #2
      left_align = TRUE;
 8002c4c:	f04f 0c01 	moveq.w	ip, #1
    left_align = FALSE;
 8002c50:	f04f 0c00 	movne.w	ip, #0
    if (*fmt == '0') {
 8002c54:	2a30      	cmp	r2, #48	; 0x30
 8002c56:	bf03      	ittte	eq
 8002c58:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 8002c5a:	3301      	addeq	r3, #1
      filler = '0';
 8002c5c:	f04f 0930 	moveq.w	r9, #48	; 0x30
    filler = ' ';
 8002c60:	f04f 0920 	movne.w	r9, #32
 8002c64:	1c59      	adds	r1, r3, #1
    width = 0;
 8002c66:	2400      	movs	r4, #0
 8002c68:	e005      	b.n	8002c76 <chprintf.constprop.0+0x76>
        c = va_arg(ap, int);
 8002c6a:	783b      	ldrb	r3, [r7, #0]
 8002c6c:	3704      	adds	r7, #4
 8002c6e:	f811 2b01 	ldrb.w	r2, [r1], #1
      width = width * 10 + c;
 8002c72:	eb03 0440 	add.w	r4, r3, r0, lsl #1
      if (c >= '0' && c <= '9')
 8002c76:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8002c7a:	b2db      	uxtb	r3, r3
 8002c7c:	2b09      	cmp	r3, #9
      c = *fmt++;
 8002c7e:	460e      	mov	r6, r1
      width = width * 10 + c;
 8002c80:	eb04 0084 	add.w	r0, r4, r4, lsl #2
      if (c >= '0' && c <= '9')
 8002c84:	d9f3      	bls.n	8002c6e <chprintf.constprop.0+0x6e>
      else if (c == '*')
 8002c86:	2a2a      	cmp	r2, #42	; 0x2a
 8002c88:	d0ef      	beq.n	8002c6a <chprintf.constprop.0+0x6a>
    if (c == '.') {
 8002c8a:	2a2e      	cmp	r2, #46	; 0x2e
 8002c8c:	f04f 0100 	mov.w	r1, #0
 8002c90:	d043      	beq.n	8002d1a <chprintf.constprop.0+0x11a>
    if (c == 'l' || c == 'L') {
 8002c92:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8002c96:	2b4c      	cmp	r3, #76	; 0x4c
 8002c98:	d04e      	beq.n	8002d38 <chprintf.constprop.0+0x138>
    switch (c) {
 8002c9a:	f1a2 0044 	sub.w	r0, r2, #68	; 0x44
 8002c9e:	2834      	cmp	r0, #52	; 0x34
 8002ca0:	f200 8151 	bhi.w	8002f46 <chprintf.constprop.0+0x346>
 8002ca4:	e8df f010 	tbh	[pc, r0, lsl #1]
 8002ca8:	014f00fe 	.word	0x014f00fe
 8002cac:	014f014f 	.word	0x014f014f
 8002cb0:	00fe014f 	.word	0x00fe014f
 8002cb4:	014f014f 	.word	0x014f014f
 8002cb8:	014f014f 	.word	0x014f014f
 8002cbc:	00f8014f 	.word	0x00f8014f
 8002cc0:	014f014f 	.word	0x014f014f
 8002cc4:	014f014f 	.word	0x014f014f
 8002cc8:	0088014f 	.word	0x0088014f
 8002ccc:	014f014f 	.word	0x014f014f
 8002cd0:	014f00fb 	.word	0x014f00fb
 8002cd4:	014f014f 	.word	0x014f014f
 8002cd8:	014f014f 	.word	0x014f014f
 8002cdc:	014f014f 	.word	0x014f014f
 8002ce0:	014f014f 	.word	0x014f014f
 8002ce4:	0143014f 	.word	0x0143014f
 8002ce8:	014f00fe 	.word	0x014f00fe
 8002cec:	014f014f 	.word	0x014f014f
 8002cf0:	00fe014f 	.word	0x00fe014f
 8002cf4:	014f014f 	.word	0x014f014f
 8002cf8:	014f014f 	.word	0x014f014f
 8002cfc:	00f8014f 	.word	0x00f8014f
 8002d00:	014f014f 	.word	0x014f014f
 8002d04:	0129014f 	.word	0x0129014f
 8002d08:	0088014f 	.word	0x0088014f
 8002d0c:	014f014f 	.word	0x014f014f
 8002d10:	00fb      	.short	0x00fb
          c = va_arg(ap, int);
 8002d12:	783b      	ldrb	r3, [r7, #0]
 8002d14:	3704      	adds	r7, #4
        precision += c;
 8002d16:	eb03 0140 	add.w	r1, r3, r0, lsl #1
        c = *fmt++;
 8002d1a:	f816 2b01 	ldrb.w	r2, [r6], #1
        if (c >= '0' && c <= '9')
 8002d1e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8002d22:	b2db      	uxtb	r3, r3
 8002d24:	2b09      	cmp	r3, #9
        precision *= 10;
 8002d26:	eb01 0081 	add.w	r0, r1, r1, lsl #2
        if (c >= '0' && c <= '9')
 8002d2a:	d9f4      	bls.n	8002d16 <chprintf.constprop.0+0x116>
        else if (c == '*')
 8002d2c:	2a2a      	cmp	r2, #42	; 0x2a
 8002d2e:	d0f0      	beq.n	8002d12 <chprintf.constprop.0+0x112>
    if (c == 'l' || c == 'L') {
 8002d30:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8002d34:	2b4c      	cmp	r3, #76	; 0x4c
 8002d36:	d1b0      	bne.n	8002c9a <chprintf.constprop.0+0x9a>
      if (*fmt)
 8002d38:	7833      	ldrb	r3, [r6, #0]
 8002d3a:	b10b      	cbz	r3, 8002d40 <chprintf.constprop.0+0x140>
        c = *fmt++;
 8002d3c:	3601      	adds	r6, #1
 8002d3e:	461a      	mov	r2, r3
    switch (c) {
 8002d40:	f1a2 0344 	sub.w	r3, r2, #68	; 0x44
 8002d44:	2b34      	cmp	r3, #52	; 0x34
 8002d46:	f200 80fe 	bhi.w	8002f46 <chprintf.constprop.0+0x346>
 8002d4a:	e8df f013 	tbh	[pc, r3, lsl #1]
 8002d4e:	00ab      	.short	0x00ab
 8002d50:	00fc00fc 	.word	0x00fc00fc
 8002d54:	00fc00fc 	.word	0x00fc00fc
 8002d58:	00fc00ab 	.word	0x00fc00ab
 8002d5c:	00fc00fc 	.word	0x00fc00fc
 8002d60:	00fc00fc 	.word	0x00fc00fc
 8002d64:	00fc00a5 	.word	0x00fc00a5
 8002d68:	00fc00fc 	.word	0x00fc00fc
 8002d6c:	00fc00fc 	.word	0x00fc00fc
 8002d70:	00fc0035 	.word	0x00fc0035
 8002d74:	00a800fc 	.word	0x00a800fc
 8002d78:	00fc00fc 	.word	0x00fc00fc
 8002d7c:	00fc00fc 	.word	0x00fc00fc
 8002d80:	00fc00fc 	.word	0x00fc00fc
 8002d84:	00fc00fc 	.word	0x00fc00fc
 8002d88:	00fc00fc 	.word	0x00fc00fc
 8002d8c:	00ab00f0 	.word	0x00ab00f0
 8002d90:	00fc00fc 	.word	0x00fc00fc
 8002d94:	00fc00fc 	.word	0x00fc00fc
 8002d98:	00fc00ab 	.word	0x00fc00ab
 8002d9c:	00fc00fc 	.word	0x00fc00fc
 8002da0:	00fc00fc 	.word	0x00fc00fc
 8002da4:	00fc00a5 	.word	0x00fc00a5
 8002da8:	00fc00fc 	.word	0x00fc00fc
 8002dac:	00fc00d6 	.word	0x00fc00d6
 8002db0:	00fc0035 	.word	0x00fc0035
 8002db4:	00a800fc 	.word	0x00a800fc
 8002db8:	f04f 080a 	mov.w	r8, #10
        l = va_arg(ap, unsigned int);
 8002dbc:	683a      	ldr	r2, [r7, #0]
  q = p + MAX_FILLER;
 8002dbe:	f10d 0117 	add.w	r1, sp, #23
        l = va_arg(ap, unsigned int);
 8002dc2:	3704      	adds	r7, #4
 8002dc4:	e000      	b.n	8002dc8 <chprintf.constprop.0+0x1c8>
  } while ((ll /= radix) != 0);
 8002dc6:	4601      	mov	r1, r0
    i = (int)(l % radix);
 8002dc8:	fbb2 fef8 	udiv	lr, r2, r8
 8002dcc:	fb08 221e 	mls	r2, r8, lr, r2
    i += '0';
 8002dd0:	f102 0330 	add.w	r3, r2, #48	; 0x30
    if (i > '9')
 8002dd4:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8002dd6:	bfc8      	it	gt
 8002dd8:	f102 0337 	addgt.w	r3, r2, #55	; 0x37
    *--q = i;
 8002ddc:	b2db      	uxtb	r3, r3
    l /= radix;
 8002dde:	4672      	mov	r2, lr
    *--q = i;
 8002de0:	f801 3c01 	strb.w	r3, [r1, #-1]
 8002de4:	1e48      	subs	r0, r1, #1
  } while ((ll /= radix) != 0);
 8002de6:	2a00      	cmp	r2, #0
 8002de8:	d1ed      	bne.n	8002dc6 <chprintf.constprop.0+0x1c6>
  i = (int)(p + MAX_FILLER - q);
 8002dea:	f10d 0217 	add.w	r2, sp, #23
 8002dee:	f10d 080c 	add.w	r8, sp, #12
 8002df2:	1a12      	subs	r2, r2, r0
 8002df4:	46c6      	mov	lr, r8
 8002df6:	4410      	add	r0, r2
 8002df8:	e001      	b.n	8002dfe <chprintf.constprop.0+0x1fe>
 8002dfa:	f811 3b01 	ldrb.w	r3, [r1], #1
    *p++ = *q++;
 8002dfe:	f80e 3b01 	strb.w	r3, [lr], #1
  while (--i);
 8002e02:	4288      	cmp	r0, r1
 8002e04:	d1f9      	bne.n	8002dfa <chprintf.constprop.0+0x1fa>
 8002e06:	1e53      	subs	r3, r2, #1
 8002e08:	9301      	str	r3, [sp, #4]
    if ((width -= i) < 0)
 8002e0a:	1aa4      	subs	r4, r4, r2
 8002e0c:	d43e      	bmi.n	8002e8c <chprintf.constprop.0+0x28c>
    if (left_align == FALSE)
 8002e0e:	f1bc 0f00 	cmp.w	ip, #0
 8002e12:	f040 80a1 	bne.w	8002f58 <chprintf.constprop.0+0x358>
 8002e16:	f1c4 0a00 	rsb	sl, r4, #0
    if (width < 0) {
 8002e1a:	2c00      	cmp	r4, #0
 8002e1c:	f000 809b 	beq.w	8002f56 <chprintf.constprop.0+0x356>
      if (*s == '-' && filler == '0') {
 8002e20:	f898 1000 	ldrb.w	r1, [r8]
 8002e24:	292d      	cmp	r1, #45	; 0x2d
 8002e26:	f000 80a6 	beq.w	8002f76 <chprintf.constprop.0+0x376>
        streamPut(chp, (uint8_t)filler);
 8002e2a:	682b      	ldr	r3, [r5, #0]
 8002e2c:	4649      	mov	r1, r9
 8002e2e:	68db      	ldr	r3, [r3, #12]
 8002e30:	4628      	mov	r0, r5
 8002e32:	4798      	blx	r3
      } while (++width != 0);
 8002e34:	f11a 0a01 	adds.w	sl, sl, #1
 8002e38:	d1f7      	bne.n	8002e2a <chprintf.constprop.0+0x22a>
    while (--i >= 0) {
 8002e3a:	9b01      	ldr	r3, [sp, #4]
 8002e3c:	2b00      	cmp	r3, #0
 8002e3e:	44a3      	add	fp, r4
 8002e40:	bfa8      	it	ge
 8002e42:	4654      	movge	r4, sl
 8002e44:	f6ff aee7 	blt.w	8002c16 <chprintf.constprop.0+0x16>
 8002e48:	f8dd a004 	ldr.w	sl, [sp, #4]
      streamPut(chp, (uint8_t)*s++);
 8002e4c:	682b      	ldr	r3, [r5, #0]
 8002e4e:	f818 1b01 	ldrb.w	r1, [r8], #1
 8002e52:	68db      	ldr	r3, [r3, #12]
    while (--i >= 0) {
 8002e54:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
      streamPut(chp, (uint8_t)*s++);
 8002e58:	4628      	mov	r0, r5
 8002e5a:	4798      	blx	r3
    while (--i >= 0) {
 8002e5c:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
 8002e60:	d1f4      	bne.n	8002e4c <chprintf.constprop.0+0x24c>
 8002e62:	9b01      	ldr	r3, [sp, #4]
 8002e64:	f10b 0b01 	add.w	fp, fp, #1
 8002e68:	449b      	add	fp, r3
    while (width) {
 8002e6a:	2c00      	cmp	r4, #0
 8002e6c:	f43f aed3 	beq.w	8002c16 <chprintf.constprop.0+0x16>
 8002e70:	46a0      	mov	r8, r4
      streamPut(chp, (uint8_t)filler);
 8002e72:	682b      	ldr	r3, [r5, #0]
 8002e74:	4649      	mov	r1, r9
 8002e76:	68db      	ldr	r3, [r3, #12]
 8002e78:	4628      	mov	r0, r5
 8002e7a:	4798      	blx	r3
    while (width) {
 8002e7c:	f1b8 0801 	subs.w	r8, r8, #1
 8002e80:	d1f7      	bne.n	8002e72 <chprintf.constprop.0+0x272>
 8002e82:	44a3      	add	fp, r4
 8002e84:	e6c7      	b.n	8002c16 <chprintf.constprop.0+0x16>
 8002e86:	bf00      	nop
 8002e88:	20000c18 	.word	0x20000c18
    while (--i >= 0) {
 8002e8c:	9b01      	ldr	r3, [sp, #4]
 8002e8e:	2b00      	cmp	r3, #0
      width = 0;
 8002e90:	bfa8      	it	ge
 8002e92:	2400      	movge	r4, #0
    while (--i >= 0) {
 8002e94:	dad8      	bge.n	8002e48 <chprintf.constprop.0+0x248>
 8002e96:	e6be      	b.n	8002c16 <chprintf.constprop.0+0x16>
    switch (c) {
 8002e98:	f04f 0808 	mov.w	r8, #8
 8002e9c:	e78e      	b.n	8002dbc <chprintf.constprop.0+0x1bc>
 8002e9e:	f04f 0810 	mov.w	r8, #16
 8002ea2:	e78b      	b.n	8002dbc <chprintf.constprop.0+0x1bc>
        l = va_arg(ap, int);
 8002ea4:	6839      	ldr	r1, [r7, #0]
      if (l < 0) {
 8002ea6:	2900      	cmp	r1, #0
        l = va_arg(ap, int);
 8002ea8:	f107 0704 	add.w	r7, r7, #4
      if (l < 0) {
 8002eac:	db73      	blt.n	8002f96 <chprintf.constprop.0+0x396>
    p = tmpbuf;
 8002eae:	f10d 080c 	add.w	r8, sp, #12
 8002eb2:	4642      	mov	r2, r8
  q = p + MAX_FILLER;
 8002eb4:	f102 030b 	add.w	r3, r2, #11
 8002eb8:	9301      	str	r3, [sp, #4]
 8002eba:	4618      	mov	r0, r3
    i = (int)(l % radix);
 8002ebc:	4b3e      	ldr	r3, [pc, #248]	; (8002fb8 <chprintf.constprop.0+0x3b8>)
 8002ebe:	fba3 e301 	umull	lr, r3, r3, r1
 8002ec2:	08db      	lsrs	r3, r3, #3
 8002ec4:	eb03 0a83 	add.w	sl, r3, r3, lsl #2
 8002ec8:	469e      	mov	lr, r3
 8002eca:	eba1 034a 	sub.w	r3, r1, sl, lsl #1
    i += '0';
 8002ece:	3330      	adds	r3, #48	; 0x30
    *--q = i;
 8002ed0:	b2db      	uxtb	r3, r3
  } while ((ll /= radix) != 0);
 8002ed2:	4671      	mov	r1, lr
    *--q = i;
 8002ed4:	f800 3d01 	strb.w	r3, [r0, #-1]!
  } while ((ll /= radix) != 0);
 8002ed8:	2900      	cmp	r1, #0
 8002eda:	d1ef      	bne.n	8002ebc <chprintf.constprop.0+0x2bc>
  i = (int)(p + MAX_FILLER - q);
 8002edc:	9901      	ldr	r1, [sp, #4]
 8002ede:	1a09      	subs	r1, r1, r0
 8002ee0:	4411      	add	r1, r2
 8002ee2:	e001      	b.n	8002ee8 <chprintf.constprop.0+0x2e8>
 8002ee4:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    *p++ = *q++;
 8002ee8:	f802 3b01 	strb.w	r3, [r2], #1
  while (--i);
 8002eec:	428a      	cmp	r2, r1
 8002eee:	d1f9      	bne.n	8002ee4 <chprintf.constprop.0+0x2e4>
 8002ef0:	eba2 0208 	sub.w	r2, r2, r8
 8002ef4:	1e53      	subs	r3, r2, #1
 8002ef6:	9301      	str	r3, [sp, #4]
 8002ef8:	e787      	b.n	8002e0a <chprintf.constprop.0+0x20a>
      if ((s = va_arg(ap, char *)) == 0)
 8002efa:	f8d7 8000 	ldr.w	r8, [r7]
 8002efe:	3704      	adds	r7, #4
 8002f00:	f1b8 0f00 	cmp.w	r8, #0
 8002f04:	d050      	beq.n	8002fa8 <chprintf.constprop.0+0x3a8>
      for (p = s; *p && (--precision >= 0); p++)
 8002f06:	f898 3000 	ldrb.w	r3, [r8]
      if (precision == 0)
 8002f0a:	b351      	cbz	r1, 8002f62 <chprintf.constprop.0+0x362>
      for (p = s; *p && (--precision >= 0); p++)
 8002f0c:	b36b      	cbz	r3, 8002f6a <chprintf.constprop.0+0x36a>
 8002f0e:	3901      	subs	r1, #1
 8002f10:	4642      	mov	r2, r8
 8002f12:	e001      	b.n	8002f18 <chprintf.constprop.0+0x318>
 8002f14:	3901      	subs	r1, #1
 8002f16:	d403      	bmi.n	8002f20 <chprintf.constprop.0+0x320>
 8002f18:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8002f1c:	2b00      	cmp	r3, #0
 8002f1e:	d1f9      	bne.n	8002f14 <chprintf.constprop.0+0x314>
 8002f20:	eba2 0208 	sub.w	r2, r2, r8
 8002f24:	1e53      	subs	r3, r2, #1
 8002f26:	9301      	str	r3, [sp, #4]
      filler = ' ';
 8002f28:	f04f 0920 	mov.w	r9, #32
 8002f2c:	e76d      	b.n	8002e0a <chprintf.constprop.0+0x20a>
      *p++ = va_arg(ap, int);
 8002f2e:	f10d 0818 	add.w	r8, sp, #24
 8002f32:	683b      	ldr	r3, [r7, #0]
 8002f34:	f808 3d0c 	strb.w	r3, [r8, #-12]!
 8002f38:	2300      	movs	r3, #0
 8002f3a:	3704      	adds	r7, #4
 8002f3c:	9301      	str	r3, [sp, #4]
 8002f3e:	2201      	movs	r2, #1
      filler = ' ';
 8002f40:	f04f 0920 	mov.w	r9, #32
 8002f44:	e761      	b.n	8002e0a <chprintf.constprop.0+0x20a>
      *p++ = c;
 8002f46:	f10d 0818 	add.w	r8, sp, #24
 8002f4a:	2300      	movs	r3, #0
 8002f4c:	f808 2d0c 	strb.w	r2, [r8, #-12]!
 8002f50:	9301      	str	r3, [sp, #4]
 8002f52:	2201      	movs	r2, #1
 8002f54:	e759      	b.n	8002e0a <chprintf.constprop.0+0x20a>
    if (width < 0) {
 8002f56:	4654      	mov	r4, sl
    while (--i >= 0) {
 8002f58:	9b01      	ldr	r3, [sp, #4]
 8002f5a:	2b00      	cmp	r3, #0
 8002f5c:	f6bf af74 	bge.w	8002e48 <chprintf.constprop.0+0x248>
 8002f60:	e783      	b.n	8002e6a <chprintf.constprop.0+0x26a>
      for (p = s; *p && (--precision >= 0); p++)
 8002f62:	f647 71fe 	movw	r1, #32766	; 0x7ffe
 8002f66:	2b00      	cmp	r3, #0
 8002f68:	d1d2      	bne.n	8002f10 <chprintf.constprop.0+0x310>
 8002f6a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002f6e:	9301      	str	r3, [sp, #4]
 8002f70:	f04f 0920 	mov.w	r9, #32
 8002f74:	e74b      	b.n	8002e0e <chprintf.constprop.0+0x20e>
      if (*s == '-' && filler == '0') {
 8002f76:	f1b9 0f30 	cmp.w	r9, #48	; 0x30
 8002f7a:	f47f af56 	bne.w	8002e2a <chprintf.constprop.0+0x22a>
        streamPut(chp, (uint8_t)*s++);
 8002f7e:	682a      	ldr	r2, [r5, #0]
 8002f80:	480e      	ldr	r0, [pc, #56]	; (8002fbc <chprintf.constprop.0+0x3bc>)
 8002f82:	68d2      	ldr	r2, [r2, #12]
 8002f84:	4790      	blx	r2
 8002f86:	9b01      	ldr	r3, [sp, #4]
 8002f88:	3b01      	subs	r3, #1
 8002f8a:	f108 0801 	add.w	r8, r8, #1
        n++;
 8002f8e:	f10b 0b01 	add.w	fp, fp, #1
 8002f92:	9301      	str	r3, [sp, #4]
 8002f94:	e749      	b.n	8002e2a <chprintf.constprop.0+0x22a>
        *p++ = '-';
 8002f96:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8002f98:	4249      	negs	r1, r1
        *p++ = '-';
 8002f9a:	f88d 300c 	strb.w	r3, [sp, #12]
 8002f9e:	f10d 020d 	add.w	r2, sp, #13
 8002fa2:	f10d 080c 	add.w	r8, sp, #12
 8002fa6:	e785      	b.n	8002eb4 <chprintf.constprop.0+0x2b4>
        s = "(null)";
 8002fa8:	f8df 8014 	ldr.w	r8, [pc, #20]	; 8002fc0 <chprintf.constprop.0+0x3c0>
      if (precision == 0)
 8002fac:	2900      	cmp	r1, #0
 8002fae:	d1ae      	bne.n	8002f0e <chprintf.constprop.0+0x30e>
        precision = 32767;
 8002fb0:	f647 71ff 	movw	r1, #32767	; 0x7fff
 8002fb4:	e7ab      	b.n	8002f0e <chprintf.constprop.0+0x30e>
 8002fb6:	bf00      	nop
 8002fb8:	cccccccd 	.word	0xcccccccd
 8002fbc:	20000c18 	.word	0x20000c18
 8002fc0:	080031ec 	.word	0x080031ec
